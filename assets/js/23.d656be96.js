(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{402:function(t,n,e){"use strict";e.r(n);var i={},s=e(45),v=Object(s.a)(i,(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("Content",{attrs:{"slot-key":"title-index1"}}),t._v(" "),e("p",[t._v("\n    To coordinate events, user interaction, scripts, rendering,\n    networking, and so forth, user agents must use event loops\n    as described in this section. Each agent has an associated\n    event loop, which is unique to that agent.\n  ")]),t._v(" "),e("p",[t._v("\n    根据标准中对事件循环的定义描述，我们可以发现事件循环本质上\n    是 user agent (如浏览器端) ⽤用于协调⽤用户交互（鼠标、键盘）、脚\n    本（如 JavaScript）、渲染（如 HTML DOM、CSS 样式）、网络\n    等行为的一个机制。\n  ")]),t._v(" "),e("p",[t._v("\n    了解到这个定义之后，我们就能够清楚的明白，与其说是\n    JavaScript 提供了事件循环，不如说是嵌入 JavaScript 的 user\n    agent 需要通过事件循环来与多种事件源交互。\n  ")]),t._v(" "),e("p",[t._v("\n    各种浏览器事件同时触发时，肯定有一个先来后到的排队问题。决定这些事件如何\n    排队触发的机制，就是事件循环。这个排队行为以 JavaScript 开发者的角度来看，\n    主要是分成两个队列：\n  ")]),t._v(" "),t._m(0),t._v(" "),e("p",[t._v("\n    值得注意的是，虽然为了好理理解我们管这个叫队列 (Queue)，但是本质上是有序集\n    合 (Set)，因为传统的队列都是先进先出（FIFO）的，而这里的队列则不然，排到最\n    前面但是没有满足条件也是不会执行的（比如外部队列里只有一个 setTimeout 的定\n    时任务，但是时间还没有到，没有满足条件也不会把他出列来执行）。\n  ")]),t._v(" "),e("Content",{attrs:{"slot-key":"title-index2"}}),t._v(" "),e("p",[t._v("\n    部队列列（Task Queue），顾名思义就是 JavaScript 外部的事件的\n    队列，这里我们可以先列列举一下浏览器中这些外部事件源（Task\n    Source），他们主要有：\n  ")]),t._v(" "),t._m(1),t._v(" "),e("p",[t._v("\n    可以观察到，这些外部的事件源可能很多，为了方便浏览器器厂商优化，\n    HTML 标准中明确指出一个事件循环由一个或多个外部队列列，而每一个\n    外部事件源都有一个对应的外部队列。不同事件源的队列可以有不同的\n    优先级（例如在网络事件和用户交互之间，浏览器可以优先处理鼠标行\n    为，从而让用户感觉更加流程）\n  ")]),t._v(" "),e("Content",{attrs:{"slot-key":"title-index3"}}),t._v(" "),e("p",[t._v("\n    内部队列（Microtask Queue），即 JavaScript 语言内部的事件队列，\n    在 HTML 标准中，并没有明确规定这个队列的事件源，通常认为有以下\n    ⼏种\n  ")]),t._v(" "),t._m(2),t._v(" "),e("Content",{attrs:{"slot-key":"title-index4"}}),t._v(" "),e("p",[t._v("\n    To coordinate events, user interaction, scripts, rendering,\n    networking, and so forth, user agents must use event loops\n    as described in this section. Each agent has an associated\n    event loop, which is unique to that agent.\n  ")]),t._v(" "),e("p",[t._v("\n    看到这里，大家可能就反应过来了，scripts 执行也是一个事件，我\n    们只要归类一下就会发现 JavaScript 的执行也是⼀个浏览器发起的外\n    部事件。所以本质的执行顺序还是\n  ")]),t._v(" "),t._m(3),t._v(" "),e("Content",{attrs:{"slot-key":"title-index5"}}),t._v(" "),e("p",[t._v("\n    如果说浏览器端是将 JavaScript 集成到 HTML 的事件循环之中，那么\n    Node.js 则是将 JavaScript 集成到 libuv 的 I/O 循环之中。\n  ")]),t._v(" "),e("p",[t._v("\n    简而言之，二者都是把 JavaScript 集成到他们各⾃自的环境中，但是 HTML (浏览器端) 与\n    libuv (服务端) 面对的场景有很大的差异。⾸首先能直观感受到的区别是\n  ")]),t._v(" "),t._m(4),t._v(" "),e("p",[t._v("\n    至于内在的差异，有一个很重要的地方是 Node.js （libuv）在最初设计的时候是允许执\n    行多次外部的事件再切换到内部队列的，而浏览器端一次事件循环只允许执行一次外部\n    事件。这个经典的内在差异，可以通过一个例子来观察。\n  ")]),t._v(" "),e("p",[t._v("\n    究其原因，主要是因为浏览器端有外部队列一次事件循环只能执行\n    一个的限制，而在 Node.js 中则放开了这个限制，允许外部队列中\n    所有任务都执行完再切换到内部队列。\n  ")]),t._v(" "),e("p",[t._v("\n    虽然 Node.js 的这个问题在 11 之后的版本里修复了了，但是为了继续探究这个\n    影响，我们引入一个新的外部事件 setImmediate。这个方法目前是 Node.js\n    独有的，浏览器端没有\n  ")]),t._v(" "),e("p",[t._v("\n    setImmediate 的引入是为了解决 setTimeout 的精度问题，由于 setTimeout\n    指定的延迟时间是毫秒（ms）但实际一次时间循环的时间可能是纳秒级的，\n    所以在一次事件循环的多个外部队列列中，找到某一个队列直接执行其中的\n    callback 可以得到比 setTimeout 更早执行的效果。\n  ")]),t._v(" "),e("Content",{attrs:{"slot-key":"title-index6"}}),t._v(" "),t._m(5),t._v(" "),e("Content",{attrs:{"slot-key":"title-index7"}}),t._v(" "),e("ul",[e("li",[t._v("GUI渲染线程 （渲染页面的）")]),t._v(" "),e("li",[t._v("js引擎线程 他和页面渲染时互斥")]),t._v(" "),e("li",[t._v("事件触发线程 独立的线程 EventLoop")]),t._v(" "),e("li",[t._v("事件 click、setTimeout、ajax也是一个独立线程")]),t._v(" "),e("img",{attrs:{src:t.$withBase("/es6/loop.jpg")}})])],1)}),[function(){var t=this.$createElement,n=this._self._c||t;return n("ul",[n("li",[this._v("\n      一个是 JavaScript 外部的队列。外部的队列主要是浏览器协调的各类事件的队\n      列，标准⽂文件中称之为 Task Queue。下⽂文中为了方便理解统一称为外部队\n      列。\n    ")]),this._v(" "),n("li",[this._v("\n      另一个是 JavaScript 内部的队列。这部分主要是 JavaScript 内部执行的任务队\n      列，标准中称之为 Microtask Queue。下⽂文中为了方便理解统一称为内部队\n      列。\n    ")])])},function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ul",[e("li",[t._v("DOM 操作 (⻚页⾯面渲染)")]),t._v(" "),e("li",[t._v("用户交互 (⿏鼠标、键盘)")]),t._v(" "),e("li",[t._v("网络请求 (Ajax 等)")]),t._v(" "),e("li",[t._v("History API 操作")]),t._v(" "),e("li",[t._v("定时器器 (setTimeout 等)")])])},function(){var t=this.$createElement,n=this._self._c||t;return n("ul",[n("li",[this._v("Promise的成功 (.then) 与失败 (.catch)")]),this._v(" "),n("li",[this._v("MutationObserver [6]")]),this._v(" "),n("li",[this._v("Object.observe (已废弃)")])])},function(){var t=this.$createElement,n=this._self._c||t;return n("ul",[n("li",[this._v("一次外部事件")]),this._v(" "),n("li",[this._v("所有内部事件")]),this._v(" "),n("li",[this._v("HTML 渲染")]),this._v(" "),n("li",[this._v("回到1")])])},function(){var t=this.$createElement,n=this._self._c||t;return n("ul",[n("li",[this._v("事件循环的过程没有 HTML 渲染。只剩下了外部队列和内部队列这两个部分。")]),this._v(" "),n("li",[this._v("外部队列的事件源不同。Node.js 端没有了鼠标等外设但是新增了文件等 IO。")]),this._v(" "),n("li",[this._v("内部队列的事件仅剩下 Promise 的 then 和 catch")])])},function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ul",[e("li",[t._v("每一个页卡都是进程 (互不影响)")]),t._v(" "),e("li",[t._v("浏览器也有一个主进程 (用户界面)")]),t._v(" "),e("li",[t._v("渲染进程 每个页卡里 都有一个渲染进程 (浏览器内核)")]),t._v(" "),e("li",[t._v("网络进程 （处理请求）")]),t._v(" "),e("li",[t._v("GPU进程 3d绘制")]),t._v(" "),e("li",[t._v("第三方插件的进程")])])}],!1,null,"7d2e87d0",null);n.default=v.exports}}]);
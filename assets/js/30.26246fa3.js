(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{407:function(t,n,e){"use strict";e.r(n);var v={},_=e(45),i=Object(_.a)(v,(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("Content",{attrs:{"slot-key":"title-for"}}),t._v(" "),e("h3",[t._v("v-if与v-for哪个优先级更高，为什么")]),t._v(" "),e("p",[t._v("从源码中找到答案compiler/codegen/index.js")]),t._v(" "),e("Content",{attrs:{"slot-key":"code-for"}}),t._v(" "),e("p",[t._v("\n    在上面的vue源码genElement函数中，可以明显看到是先判断v-for之后执行后再判断v-if是否存在并执行\n  ")]),t._v(" "),e("h3",[t._v("v-if与v-for同时作用于同一元素会怎么样，如何解决")]),t._v(" "),e("p",[t._v("\n    如果同时出现，每次渲染都会先执行循环再判断条件，循环不可避免，导致浪费性能，可以在外层嵌套template，在该层进行v-if判断，然后内部进行v-for循环，如果需要在每一项进行判断，可以在js中完成过滤\n  ")]),t._v(" "),e("h4",[t._v("两者同级时demo代码如下")]),t._v(" "),e("Content",{attrs:{"slot-key":"code-demo"}}),t._v(" "),e("h4",[t._v("两者同级时渲染函数结果如下")]),t._v(" "),e("Content",{attrs:{"slot-key":"code-render"}}),t._v(" "),e("h4",[t._v("两者不同级时demo代码如下")]),t._v(" "),e("Content",{attrs:{"slot-key":"code-isdemo"}}),t._v(" "),e("h4",[t._v("两者不同级时渲染函数结果如下")]),t._v(" "),e("Content",{attrs:{"slot-key":"code-isRender"}}),t._v(" "),e("Content",{attrs:{"slot-key":"title-data"}}),t._v(" "),e("h3",[t._v("vue组件中的data为什么必须是函数，而vue的根实例没有此限制")]),t._v(" "),e("p",[t._v("\n    组件中的data写成一个函数,数据以函数返回值形式定义,这样每复用一次组件,就会返回一份新的data,类似于给每个组件实例创建一个私有的数据空间,让各个组件实例维护各自的数据。而单纯的写成对象形式,就使得所有组件实例共用了一份data,就会造成一个变了全都会变的结果。根实例创建过程中不存在该限制因为根实例只有一个。\n  ")]),t._v(" "),e("Content",{attrs:{"slot-key":"title-key"}}),t._v(" "),e("h3",[t._v("vue中key的作用和工作原理，说说你的理解")]),t._v(" "),e("Content",{attrs:{"slot-key":"code-key"}}),t._v(" "),e("img",{attrs:{src:t.$withBase("/about/about1.png")}}),t._v(" "),e("p",[t._v("不使用key")]),t._v(" "),e("img",{attrs:{src:t.$withBase("/about/about3.png")}}),t._v(" "),e("p",[t._v("使用key")]),t._v(" "),e("img",{attrs:{src:t.$withBase("/about/about2.png")}}),t._v(" "),e("h4",[t._v("结论")]),t._v(" "),t._m(0),t._v(" "),e("Content",{attrs:{"slot-key":"title-diff"}}),t._v(" "),t._m(1),t._v(" "),e("Content",{attrs:{"slot-key":"title-component"}}),t._v(" "),e("Content",{attrs:{"slot-key":"code-component"}}),t._v(" "),t._m(2),t._v(" "),e("Content",{attrs:{"slot-key":"title-Vue"}}),t._v(" "),e("p",[t._v("渐进式 JavaScript 框架：")]),t._v(" "),e("p",[t._v("\n    与其它大型框架不同的是， Vue 被设计为可以自底向上逐层应用。 Vue\n    的核心库只关注视图层，不仅 易\n    于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结\n    合使 用时， Vue 也完全能够为复杂的单页应用提供驱动。\n  ")]),t._v(" "),t._m(3),t._v(" "),e("Content",{attrs:{"slot-key":"title-MVVM"}}),t._v(" "),e("p",[t._v("\n    在 web1.0 时代，并没有前端的概念。开发一个 web 应用多数采用 ASP\n    .NET/Java/PHP 编写，项目通 常由 多个 aspx/jsp/php\n    文件构成，每个文件中同时包含了 HTML、 CSS 、 JavaScript 、 C#/Java/PHP 代\n    码，系 统整体架构可能是这样子的\n  ")]),t._v(" "),e("img",{attrs:{src:t.$withBase("/about/about9.png")}}),t._v(" "),e("p",[t._v("这种架构的好处是简单快捷，但是，缺点也非常明显： JSP 代码难以维护")]),t._v(" "),e("p",[t._v("\n    为了让开发更加便捷，代码更易维护，前后端职责更清晰。便衍生出 MVC\n    开发模式和框架，前端展 示以 模板的形式出现。典型的框架就是\n    Spring、Structs、Hibernate。整体框架如图所示\n  ")]),t._v(" "),e("img",{attrs:{src:t.$withBase("/about/about10.png")}}),t._v(" "),e("p",[t._v("\n    使用这种分层架构，职责清晰，代码易维护。但这里的 MVC\n    仅限于后端，前后端形成了一定的分离， 前 端只完成了后端开发中的 view 层。\n    但是，同样的这种模式存在着一些： 1 . 前端页面开发效率不高 2 .\n    前后端职责不清\n  ")]),t._v(" "),e("p",[t._v("\n    web 2.0 时代 自从 Gmail 的出现，ajax 技术开始风靡全球。有了 ajax\n    之后，前后端的职责就更加清晰了。因为前 端可 以通过 Ajax\n    与后端进行数据交互，因此，整体的架构图也变化成了下面这幅图：\n  ")]),t._v(" "),e("img",{attrs:{src:t.$withBase("/about/about11.png")}}),t._v(" "),e("p",[t._v("\n    通过 ajax\n    与后台服务器进行数据交换，前端开发人员，只需要开发页面这部分内容，数据可由后台进\n    行 提供。而且 ajax\n    可以使得页面实现部分刷新，减少了服务端负载和流量消耗，用户体验也更佳。\n    这时，\n    才开始有专职的前端工程师。同时前端的类库也慢慢的开始发展，最著名的就是\n    jQuery 了。\n    当然，此架构也存在问题：缺乏可行的开发模式承载更复杂的业务需求，页面内容都杂糅在一起，一\n    旦 应用规模增大，就会导致难以维护了。因此，前端的 MVC 也随之而来。\n  ")]),t._v(" "),e("p",[t._v("\n    前后端分离后的架构演变 ——MVC 、 MVP 和 MVVM MVC 前端的 MVC\n    与后端类似，具备着 Vi ew、Controller 和 Model。\n    Model：负责保存应用数据，与后端数据进行同步\n    Controller：负责业务逻辑，根据用户行为对 Model 数据进行修 改 Vi\n    ew：负责视图展示，将 model 中的数据可视化出来。\n    三者形成了一个如图所示的模型：\n  ")]),t._v(" "),e("img",{attrs:{src:t.$withBase("/about/about4.png")}}),t._v(" "),e("p",[t._v("\n    这样的模型，在理论上是可行的。但往往在实际开发中，并不会这样操作。因为开发过程并不灵活。\n    例\n    如，一个小小的事件操作，都必须经过这样的一个流程，那么开发就不再便捷了。\n    在实际场景中，我们往往会看到另一种模式，如图：\n  ")]),t._v(" "),e("img",{attrs:{src:t.$withBase("/about/about5.png")}}),t._v(" "),e("p",[t._v("这种模式在开发中更加的灵活，backbone.js 框架就是这种的模式。")]),t._v(" "),e("p",[t._v("但是，这种灵活可能导致严重的问题：")]),t._v(" "),e("ul",[e("li",[t._v("\n      1 . 数据流混乱。如下图：\n      "),e("img",{attrs:{src:t.$withBase("/about/about6.png")}})]),t._v(" "),e("li",[t._v("\n      2 . View 比较庞大，而 Controller 比较单薄：由于很多的开发者都会在 view\n      中写一些逻辑代码，逐渐的 就导致 view 中的内容越来越庞大，而 controller\n      变得越来越单薄。\n    ")])]),t._v(" "),e("p",[t._v("\n    既然有缺陷，就会有变革。前端的变化中，似乎少了 MVP 的这种模式，是因为\n    AngularJS 早早地将 MVVM 框架模式带入了前端。 MVP\n    模式虽然前端开发并不常见，但是在安卓等原生开发中，开发者还 是 会考虑到它。\n  ")]),t._v(" "),e("h4",[t._v("MVP")]),t._v(" "),e("P",[t._v("\n    MVP 与 MVC 很接近， P 指的是 P resenter，presenter\n    可以理解为一个中间人，它负责着 Vi ew 和 Model 之 间的数据流动，防止 Vi ew\n    和 Model 之间直接交流。我们可以看一下图示：\n  ")]),t._v(" "),e("img",{attrs:{src:t.$withBase("/about/about7.png")}}),t._v(" "),e("p",[t._v("\n    我们可以通过看到，presenter 负责和 Model 进行双向交互，还和 Vi ew\n    进行双向交互。这种交互方 式， 相对于 MVC 来说少了一些灵活， VIew\n    变成了被动视图，并且本身变得很小。虽然它分离了 View\n    和Model。但是应用逐渐变大之后，导致 presenter\n    的体积增大，难以维护。要解决这个问题，或许可 以 从 MVVM 的思想中找到答案。\n  ")]),t._v(" "),e("h4",[t._v("MVVM")]),t._v(" "),e("p",[t._v("\n    首先，何为 MVVM 呢？ MVVM 可以分解成(Model-View-VIewModel)。 Vi ewModel\n    可以理解为在 presenter 基础上的进阶版。如图所示：\n  ")]),t._v(" "),e("img",{attrs:{src:t.$withBase("/about/about8.png")}}),t._v(" "),e("p",[t._v("\n    Vi ewModel 通过实现一套数据响应式机制自动响应 Model 中数据变化； 同时 Vi\n    ewmodel 会实现一套更新策略自动将数据变化转换为视图更新； 通过事件监听响应\n    Vi ew 中用户交互修改 Model 中数据。 这样在 Vi ewModel 中就减少了大量 DOM\n    操作代码。 MVVM 在保持 Vi ew 和 Model\n    松耦合的同时，还减少了维护它们关系的代码，使用户专注于业务逻辑， 兼\n    顾开发效率和可维护性。\n  ")]),t._v(" "),e("h4",[t._v("总结")]),t._v(" "),t._m(4),t._v(" "),e("Content",{attrs:{"slot-key":"title-youhua"}}),t._v(" "),t._m(5),t._v(" "),e("Content",{attrs:{"slot-key":"title-vue3"}}),t._v(" "),t._m(6),t._v(" "),e("h4",[t._v("虚拟 DOM 重写")]),t._v(" "),e("p",[t._v("\n    期待更多的编译时提示来减少运行时开销，使用更有效的代码来创建虚拟节点。\n    组件快速路径 + 单个调用 + 子节点类型检测\n  ")]),t._v(" "),t._m(7),t._v(" "),e("p",[t._v("优化 slots 生成")]),t._v(" "),e("p",[t._v("vue3 中可以单独重新渲染父级和子级")]),t._v(" "),t._m(8),t._v(" "),e("p",[t._v("静态树提升(Static T ree Hoisting)")]),t._v(" "),e("p",[t._v("\n    使用静态树提升，这意味着 Vue 3\n    的编译器将能够检测到什么是静态的，然后将其提升，从而降低了 渲 染成本。\n  ")]),t._v(" "),t._m(9),t._v(" "),e("p",[t._v("\n    静态属性提升,使用静态属性提升， Vue 3\n    打补丁时将跳过这些属性不会改变的节点。\n  ")]),t._v(" "),e("p",[t._v("基于 P ro xy 的数据响应式")]),t._v(" "),e("p",[t._v("\n    Vue 2 的响应式系统使用 Object.defineProperty 的 getter 和 setter。 Vue 3\n    将使用 ES2015 P ro xy 作为 其观察机制，这将会带来如下变化：\n  ")]),t._v(" "),t._m(10),t._v(" "),e("p",[t._v("\n    高可维护性:Vue 3 将带来更可维护的源代码。它不仅会使用 T\n    ypeScript，而且许多包被解耦，更加模块化。\n  ")]),t._v(" "),e("Content",{attrs:{"slot-key":"title-vuex"}}),t._v(" "),e("p",[t._v("\n    Vuex 实现了一个单向数据流，在全局拥有一个 State 存放数据，当组件要更 改\n    State 中的数据时，必须通过 Mutation 提交修改信息，Mutation 同时 提供\n    了订阅者模式供外部插件调用获取 State 数据的更新。\n    而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作\n    需要走 Action ，但 Action 也是无法直接修改 State 的，还是需要通过 Mutation\n    来修改 State 的数据。最后，根据 State 的变化，渲染到视图 上\n  ")]),t._v(" "),e("h4",[t._v("vuex 中核心概念")]),t._v(" "),e("ul",[e("li",[t._v("\n      state ： vuex 的唯一数据源，如果获取多个 state , 可以使用 ...mapState 。\n    ")]),t._v(" "),e("Content",{attrs:{"slot-key":"code-vuex1"}}),t._v(" "),e("li",[t._v("\n      getter : 可以将 getter 理解为计算属性， getter\n      的返回值根据他的依赖缓存起来，依 赖发 生变化才会被重新计算。\n    ")]),t._v(" "),e("Content",{attrs:{"slot-key":"code-vuex2"}}),t._v(" "),e("li",[t._v("\n      mutation ：更改 state 中唯一的方法是提交 mutation\n      都有一个字符串和一个回调函 数。\n      回调函数就是使劲进行状态修改的地方。并且会接收 state 作为第一个参数\n      payload 为第二 个参数， payload 为自定义函数， mutation 必须是同步函数。\n    ")]),t._v(" "),e("Content",{attrs:{"slot-key":"code-vuex3"}}),t._v(" "),t._m(11),t._v(" "),e("Content",{attrs:{"slot-key":"code-vuex4"}}),t._v(" "),e("li",[t._v("\n      module\n      ：由于是使用单一状态树，应用的所有状态集中到比较大的对象，当应用变得非\n      常 复杂是， store 对象就有可能变得相当臃肿。为了解决以上问题， vuex\n      允许我们将 store 分割成模块，每个模块拥有自己的\n      state,mutation,action,getter , 甚至是嵌套 子模块从\n      上至下进行同样方式分割。\n    ")]),t._v(" "),e("Content",{attrs:{"slot-key":"code-vuex5"}})],1),t._v(" "),e("h4",[t._v("vuex 中数据存储 localStorage")]),t._v(" "),e("p",[t._v("\n    vuex 是 vue 的状态管理器，存储的数据是响应式的。但是并不会保存起\n    来，刷新之后就回到了初始状态，具体做法应该在 vuex 里数据改变的时候把\n    数据拷贝一份保存到 localStorage 里面，刷新之后，如果 localStorage\n    里有保存的数据，取出来再替换 store 里的 state 。 例：\n  ")]),t._v(" "),e("Content",{attrs:{"slot-key":"code-vuex6"}}),t._v(" "),e("Content",{attrs:{"slot-key":"title-vuex6"}})],1)}),[function(){var t=this.$createElement,n=this._self._c||t;return n("ul",[n("li",[this._v("\n      key 的作用主要是为了高效的更新虚拟 DOM，其原理是 vue 在 patch 过程中通过\n      key 可以精准判断两个节点是否是同一个，从而避免频繁更新不同元素，使得整个\n      patch 过程更加高效，减少 DOM操作量，提高性能。\n    ")]),this._v(" "),n("li",[this._v("另外，若不设置 key 还可能在列表更新时引发一些隐蔽的 bug")]),this._v(" "),n("li",[this._v("\n      vue 中在使用相同标签名元素的过渡切换时，也会使用到 key\n      属性，其目的也是为了让 vue 可以区分它们，否则 vue\n      只会替换其内部属性而不会触发过渡效果。\n    ")])])},function(){var t=this.$createElement,n=this._self._c||t;return n("ul",[n("li",[this._v("\n      diff 算法是虚拟 DOM 技术的必然产物：通过新旧虚拟 DOM 作对比（即\n      diff），将变化的地方更新 在真 实 DOM 上；另外，也需要 diff\n      高效的执行对比过程，从而降低时间复杂度为 O(n)\n    ")]),this._v(" "),n("li",[this._v("\n      vue 2.x 中为了降低 Watcher 粒度，每个组件只有一个 Watcher\n      与之对应，只有引入 diff 才能精确 找到 发生变化的地方\n    ")]),this._v(" "),n("li",[this._v("\n      vue 中 diff 执行的时刻是组件实例执行其更新函数时，它会比对上一次渲染结果\n      oldVnode 和新的 渲染 结果 newVnode，此过程称为 patch\n    ")]),this._v(" "),n("li",[this._v("\n      diff\n      过程整体遵循深度优先、同层比较的策略；两个节点之间比较会根据它们是否拥有子节点或者\n      文\n      本节点做不同操作；比较两组子节点是算法的重点，首先假设头尾节点可能相同做\n      4 次比对尝试， 如果\n      没有找到相同节点才按照通用方式遍历查找，查找结束再按情况处理剩下的节点；借助\n      key 通 常可以非 常精确找到相同节点，因此整个 patch 过程非常高效\n    ")])])},function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ul",[e("li",[t._v("\n      组件是独立和可复用的代码组织单元。组件系统是 Vue\n      核心特性之一，它使开发者使用小型、独立和通常可复用的组件构建大型应用；\n    ")]),t._v(" "),e("li",[t._v("组件化开发能大幅提高应用开发效率、测试性、复用性等；")]),t._v(" "),e("li",[t._v("组件使用按分类有：页面组件、业务组件、通用组件；")]),t._v(" "),e("li",[t._v("\n      vue\n      的组件是基于配置的，我们通常编写的组件是组件配置而非组件，框架后续会生成其构造函数，它们基于\n      VueComponent，扩展于 Vue ；\n    ")]),t._v(" "),e("li",[t._v("\n      vue 中常见组件化技术有：属性\n      prop，自定义事件，插槽等，它们主要用于组件通信、扩展等；\n    ")]),t._v(" "),e("li",[t._v("合理的划分组件，有助于提升应用性能；")]),t._v(" "),e("li",[t._v("组件应该是高内聚、低耦合的；")]),t._v(" "),e("li",[t._v("遵循单向数据流的原则。")])])},function(){var t=this.$createElement,n=this._self._c||t;return n("ul",[n("li",[this._v("\n      易用性:vue\n      提供数据响应式、声明式模板语法和基于配置的组件系统等核心特性。这些使我们只需要关注应\n      用 的核心业务即可，只要会写 js 、html 和 css 就能轻松编写 vue 应用。\n    ")]),this._v(" "),n("li",[this._v("\n      灵活性:渐进式框架的最大优点就是灵活性，如果应用足够小，我们可能仅需要\n      vue 核心特性即可完成功能； 随\n      着应用规模不断扩大，我们才可能逐渐引入路由、状态管理、vue-cli\n      等库和工具，不管是应用体积 还是 学习难度都是一个逐渐增加的平和曲线。\n    ")]),this._v(" "),n("li",[this._v("\n      高效性:超快的虚拟 DOM 和 diff 算法使我们的应用拥有最佳的性能表现。\n      追求高效的过程还在继续，vue3 中引入 P ro xy\n      对数据响应式改进以及编译器中对于静态内容编译的改 进 都会让 vue\n      更加高效。\n    ")])])},function(){var t=this.$createElement,n=this._self._c||t;return n("ul",[n("li",[this._v("\n      这三者都是框架模式，它们设计的目标都是为了解决 Model 和 Vi ew\n      的耦合问题。\n    ")]),this._v(" "),n("li",[this._v("\n      MVC 模式出现较早主要应用在后端，如 Spring MVC 、 AS P .NET MVC\n      等，在前端领域的早期也有 应 用，如\n      Backbone.js。它的优点是分层清晰，缺点是数据流混乱，灵活性带来的维护性问题。\n    ")]),this._v(" "),n("li",[this._v("\n      MVP 模式在是 MVC 的进化形式， P resenter 作为中间层负责 MV\n      通信，解决了两者耦合问题，但 P 层 过于臃肿会导致维护问题。\n    ")]),this._v(" "),n("li",[this._v("\n      MVVM 模式在前端领域有广泛应用，它不仅解决 MV\n      耦合问题，还同时解决了维护两者映射关系 的 大量繁杂代码和 DOM\n      操作代码，在提高开发效率、可读性同时还保持了优越的性能表现。\n    ")])])},function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ul",[e("li",[t._v("路由懒加载")]),t._v(" "),e("li",[t._v("keep-alive 缓存页面")]),t._v(" "),e("li",[t._v("使用 v-show 复用 DOM")]),t._v(" "),e("li",[t._v("v-for 遍历避免同时使用 v-if")]),t._v(" "),e("li",[t._v("\n      长列表性能优化\n      "),e("ul",[e("li",[t._v("如果列表是纯粹的数据展示，不会有任何改变，就不需要做响应化")]),t._v(" "),e("li",[t._v("如果是大数据长列表，可采用虚拟滚动，只渲染少部分区域的内容")])])]),t._v(" "),e("li",[t._v("\n      事件的销毁,Vue\n      组件销毁时，会自动解绑它的全部指令及事件监听器，但是仅限于组件本身的事件\n    ")]),t._v(" "),e("li",[t._v("\n      图片懒加载:对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区\n      域内的图片先不做加载,等到滚动到可视区域后再去加载。\n    ")]),t._v(" "),e("li",[t._v("\n      第三方插件按需引入:像 element-ui\n      这样的第三方组件库可以按需引入避免体积太大。\n    ")]),t._v(" "),e("li",[t._v("子组件分割")]),t._v(" "),e("li",[t._v("变量本地化")]),t._v(" "),e("li",[t._v("ssr")])])},function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ul",[e("li",[t._v("\n      更快\n      "),e("ul",[e("li",[t._v("虚拟 DOM 重写")]),t._v(" "),e("li",[t._v("优化 slots 的生成")]),t._v(" "),e("li",[t._v("静态树提升")]),t._v(" "),e("li",[t._v("静态属性提升")]),t._v(" "),e("li",[t._v("基于 P ro xy 的响应式系统")])])]),t._v(" "),e("li",[t._v("更小：通过摇树优化核心库体积")]),t._v(" "),e("li",[t._v("更容易维护： T ypeScript + 模块化")]),t._v(" "),e("li",[t._v("\n      跨平台：编译器核心和运行时核心与平台无关，使得 Vue 更容易与任何平台（ W\n      eb、 Android、 iOS ）一起使用\n    ")]),t._v(" "),e("li",[t._v("\n      更容易使用\n      "),e("ul",[e("li",[t._v("\n          改进的 T ypeScript 支持，编辑器能提供强有力的类型检查和错误及警告\n        ")]),t._v(" "),e("li",[t._v("更好的调试支持")]),t._v(" "),e("li",[t._v("独立的响应化模块")]),t._v(" "),e("li",[t._v("Composition API")])])])])},function(){var t=this.$createElement,n=this._self._c||t;return n("ul",[n("li",[this._v("跳过不必要的条件分支")]),this._v(" "),n("li",[this._v("JS 引擎更容易优化")])])},function(){var t=this.$createElement,n=this._self._c||t;return n("ul",[n("li",[this._v("确保实例正确的跟踪依赖关系")]),this._v(" "),n("li",[this._v("J避免不必要的父子组件重新渲染")])])},function(){var t=this.$createElement,n=this._self._c||t;return n("ul",[n("li",[this._v("跳过修补整棵树，从而降低渲染成本")]),this._v(" "),n("li",[this._v("即使多次出现也能正常工作")])])},function(){var t=this.$createElement,n=this._self._c||t;return n("ul",[n("li",[this._v("组件实例初始化的速度提高 100％")]),this._v(" "),n("li",[this._v("\n      使用 P ro xy\n      节省以前一半的内存开销，加快速度，但是存在低浏览器版本的不兼容\n    ")]),this._v(" "),n("li",[this._v("\n      为了继续支持 IE11 ， Vue 3 将发布一个支持旧观察者机制和新 P ro xy\n      版本的构建\n    ")])])},function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("li",[t._v("\n      action ： action 类似 mutation 都是修改状态，不同之处,\n      "),e("ul",[e("li",[t._v("action 提交的 mutation 不是直接修改状态")]),t._v(" "),e("li",[t._v("action 可以包含异步操作，而 mutation 不行")]),t._v(" "),e("li",[t._v("\n          action 中的回调函数第一个参数是 context ，是一个与 store\n          实例具有相同属 性的 方法的对象\n        ")]),t._v(" "),e("li",[t._v("\n          action 通过 store.dispatch 触发， mutation 通过 store.commit 提交\n        ")])])])}],!1,null,"1bcb6358",null);n.default=i.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{326:function(t,e,n){"use strict";n.r(e);var v=n(327),o=n.n(v);for(var _ in v)["default"].indexOf(_)<0&&function(t){n.d(e,t,(function(){return v[t]}))}(_);e.default=o.a},327:function(t,e){},348:function(t,e,n){},380:function(t,e,n){"use strict";n(348)},384:function(t,e,n){"use strict";n.d(e,"a",(function(){return v})),n.d(e,"b",(function(){return o}));var v=function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",{staticClass:"demo"},[n("Content",{attrs:{"slot-key":"title-list"}}),t._v(" "),n("Content",{attrs:{"slot-key":"code-list"}}),t._v(" "),n("Content",{attrs:{"slot-key":"header1"}}),t._v(" "),n("h4",[t._v("术语解释")]),t._v(" "),t._m(0),t._v(" "),n("p",[t._v("安装依赖： npm i")]),t._v(" "),n("p",[t._v("安装rollup: npm i -g rollup")]),t._v(" "),n("p",[t._v("\n    修改dev脚本，添加sourcemap,dev命令dist文件生成vue.js文件，添加sourcemap后dist还会生成vue.map.js文件，在浏览器端调试时可以看到src源码文件\n  ")]),t._v(" "),n("p",[t._v("运行开发命令：npm run dev")]),t._v(" "),n("Content",{attrs:{"slot-key":"header2"}}),t._v(" "),n("Content",{attrs:{"slot-key":"code1"}}),t._v(" "),n("Content",{attrs:{"slot-key":"code2"}}),t._v(" "),n("Content",{attrs:{"slot-key":"code3"}}),t._v(" "),n("Content",{attrs:{"slot-key":"code4"}}),t._v(" "),n("p",[t._v("\n    找到入口文件：src/platforms/web/entry-runtime-with-compiler.js，顺着该文件寻找Vue构造函数\n  ")]),t._v(" "),n("Content",{attrs:{"slot-key":"code-mount"}}),t._v(" "),n("img",{staticStyle:{height:"300px"},attrs:{src:t.$withBase("/vue/source1.png")}}),t._v(" "),t._m(1),t._v(" "),n("Content",{attrs:{"slot-key":"header3"}}),t._v(" "),n("Content",{attrs:{"slot-key":"code-Vue"}}),t._v(" "),n("p",[t._v("进入Vue的_init方法，我们可以看到内部又包含了很多初始化的过程")]),t._v(" "),n("Content",{attrs:{"slot-key":"code-initMixin"}}),t._v(" "),n("h4",[t._v("四个导出Vue的模块")]),t._v(" "),t._m(2),t._v(" "),n("Content",{attrs:{"slot-key":"header11"}}),t._v(" "),n("h3",[t._v("数据劫持")]),t._v(" "),n("p",[t._v("在上节中我们已经知道，vue在哪里做了状态的初始化（initState）")]),t._v(" "),n("Content",{attrs:{"slot-key":"code-initState"}}),t._v(" "),n("p",[t._v("\n    这里又进行了细化和拆分，对不同的属性做了不同的初始化操作,原来我们常用的api都在这里做的初始化~data存在进入initData函数\n  ")]),t._v(" "),n("h4",[t._v("数据初始化")]),t._v(" "),n("p",[t._v("这里我们先关心数据是如何进行初始化操作的")]),t._v(" "),n("Content",{attrs:{"slot-key":"code-initData"}}),t._v(" "),n("p",[t._v("这里主要是检测属性是否被重复声明，并对属性进行观测")]),t._v(" "),n("h4",[t._v("观测数据")]),t._v(" "),n("Content",{attrs:{"slot-key":"code-observe"}}),t._v(" "),n("p",[t._v("\n    只观测对象数据类型，已经观测的不在进行观测，不能扩展的属性不进行观测。\n  ")]),t._v(" "),n("Content",{attrs:{"slot-key":"code-Observer"}}),t._v(" "),n("p",[t._v("\n    这里要区分对象和数组，如果是数组不能使用Object.defineProperty会造成性能浪费，所以采用重写可以更改数组本身的方法的方式。\n  ")]),t._v(" "),n("h4",[t._v("对象的观测")]),t._v(" "),n("p",[t._v("对象的观测就是将所有属性使用defineProperty进行重新定义")]),t._v(" "),n("Content",{attrs:{"slot-key":"code-defineReactive"}}),t._v(" "),n("p",[t._v("\n    对象的属性劫持已经烂大街了，非常简单就是通过defineProperty来实现的,如果你还不会那得好好反思一下了。这里提一下：想减少观测可以使用Object.freeze冻结对象\n  ")]),t._v(" "),n("img",{staticStyle:{height:"300px"},attrs:{src:t.$withBase("/vue/source2.png")}}),t._v(" "),n("h4",[t._v("数组的观测")]),t._v(" "),n("p",[t._v("数组的观测就是通过重写原型方法来实现的")]),t._v(" "),n("Content",{attrs:{"slot-key":"code-arrayMethods"}}),t._v(" "),n("p",[t._v("\n    这里我们所谓的数据观测就是当数据变化时我们可以知道，像对象更改时可以出发set方法,像数组调用push方法可以触发我们自己写的push\n  ")]),t._v(" "),n("img",{staticStyle:{height:"300px"},attrs:{src:t.$withBase("/vue/source3.png")}}),t._v(" "),n("Content",{attrs:{"slot-key":"header4"}}),t._v(" "),n("p",[t._v("这里我们要回想一下vue的渲染过程是通过renderWatcher来实现的")]),t._v(" "),n("Content",{attrs:{"slot-key":"code-updateComponent"}}),t._v(" "),n("p",[t._v("在我们创建watcher时，会对变量进行取值")]),t._v(" "),n("h3",[t._v("对象依赖收集")]),t._v(" "),n("p",[t._v("\n    对于对象而言,取值就会触发get方法,我们可以在defineProperty的get中触发dep.depend方法进行依赖收集,在set中通知watcher进行更新操作\n  ")]),t._v(" "),n("Content",{attrs:{"slot-key":"code-Watcher"}}),t._v(" "),n("p",[t._v("\n    渲染watcher，默认会调用get方法也就是我们传入的updateComponent方法,在调用此方法前先将watcher存到全局中，这样再取值时可以获取到这个watcher。\n  ")]),t._v(" "),n("Content",{attrs:{"slot-key":"code-defineReactive"}}),t._v(" "),n("p",[t._v("\n    这里的watcher和dep的关系是多对多的关系，一个属性一个dep，每个dep里存放着多个watcher，同时watcher也会记住对应的dep。\n  ")]),t._v(" "),n("Content",{attrs:{"slot-key":"code-Dep"}}),t._v(" "),n("p",[t._v("watcher中会进行虑重操作，实现watcher和dep互相记忆")]),t._v(" "),n("Content",{attrs:{"slot-key":"header5"}}),t._v(" "),n("p",[t._v("\n    为了防止多次更改同一个属性或者多次修改不同属性（他们依赖的watcher相同）\n    会导致频繁更新渲染\n  ")]),t._v(" "),n("Content",{attrs:{"slot-key":"code-queueWatcher"}}),t._v(" "),n("p",[t._v("对相同watcher进行过滤操作，当同步的更改状态完毕时再去更新watcher")]),t._v(" "),n("img",{staticStyle:{height:"300px"},attrs:{src:t.$withBase("/vue/source4.png")}}),t._v(" "),n("Content",{attrs:{"slot-key":"header6"}}),t._v(" "),n("Content",{attrs:{"slot-key":"code25"}}),t._v(" "),n("Content",{attrs:{"slot-key":"code26"}}),t._v(" "),n("h3",[t._v("patch实现")]),t._v(" "),n("p",[t._v("首先进行树级别比较，可能有三种情况：增删改。")]),t._v(" "),t._m(3),t._v(" "),n("Content",{attrs:{"slot-key":"code27"}}),t._v(" "),n("Content",{attrs:{"slot-key":"header7"}}),t._v(" "),n("h3",[t._v("patchVnode")]),t._v(" "),n("p",[t._v("比较两个VNode，包括三种类型操作：属性更新、文本更新、子节点更新")]),t._v(" "),t._m(4),t._v(" "),n("Content",{attrs:{"slot-key":"code28"}}),t._v(" "),n("h3",[t._v("updateChildren")]),t._v(" "),n("p",[t._v("\n    updateChildren主要作用是用一种较高效的方式比对新旧两个VNode的children得出最小操作补丁。执\n    行一个双循环是传统方式，vue中针对web场景特点做了特别的算法优化，我们看图说话：\n  ")]),t._v(" "),n("img",{staticStyle:{height:"300px"},attrs:{src:t.$withBase("/vue/diff7.png")}}),t._v(" "),n("p",[t._v("\n    在新老两组VNode节点的左右头尾两侧都有一个变量标记，在遍历过程中这几个变量都会向中间靠拢。\n    当oldStartIdx > oldEndIdx或者newStartIdx > newEndIdx时结束循环\n  ")]),t._v(" "),n("ul",[n("li",[t._v("\n      首先，oldStartVnode、oldEndVnode与newStartVnode、newEndVnode两两交叉比较，共有4种比较\n      方法。当 oldStartVnode和newStartVnode 或者 oldEndVnode和newEndVnode\n      满足sameVnode，直接将该\n      VNode节点进行patchVnode即可，不需再遍历就完成了一次循环。如下图，\n    ")]),t._v(" "),n("img",{staticStyle:{height:"300px"},attrs:{src:t.$withBase("/vue/diff8.png")}}),t._v(" "),n("li",[t._v("\n      如果oldStartVnode与newEndVnode满足sameVnode。说明oldStartVnode已经跑到了oldEndVnode\n      后面去了，进行patchVnode的同时还需要将真实DOM节点移动到oldEndVnode的后面\n    ")]),t._v(" "),n("img",{staticStyle:{height:"300px"},attrs:{src:t.$withBase("/vue/diff1.png")}}),t._v(" "),n("li",[t._v("\n      如果oldEndVnode与newStartVnode满足sameVnode，说明oldEndVnode跑到了oldStartVnode的前\n      面，进行patchVnode的同时要将oldEndVnode对应DOM移动到oldStartVnode对应DOM的前面。\n    ")]),t._v(" "),n("img",{staticStyle:{height:"300px"},attrs:{src:t.$withBase("/vue/diff2.png")}}),t._v(" "),n("li",[t._v("\n      如果以上情况均不符合，则通过createKeyToOldIdx会得到一个oldKeyToIdx，里面存放了一个key\n      为旧的VNode，value为对应index序列的哈希表。从这个哈希表中可以找到是否有与newStartVnode一致key的\n      旧的VNode节点，如果同时满足sameVnode，patchVnode的同时会将这个真实DOM（elmToMove）移动到oldStartVnode对应的真实DOM的前面。\n    ")]),t._v(" "),n("img",{staticStyle:{height:"300px"},attrs:{src:t.$withBase("/vue/diff3.png")}}),t._v(" "),n("li",[t._v("\n      当然也有可能newStartVnode在old\n      VNode节点中找不到一致的key，或者是即便key相同却不是\n      sameVnode，这个时候会调用createElm创建一个新的DOM节点。\n    ")]),t._v(" "),n("img",{staticStyle:{height:"300px"},attrs:{src:t.$withBase("/vue/diff4.png")}})]),t._v(" "),n("p",[t._v("至此循环结束，但是我们还需要处理剩下的节点。")]),t._v(" "),n("p",[t._v("\n    当结束时oldStartIdx >\n    oldEndIdx，这个时候旧的VNode节点已经遍历完了，但是新的节点还没有。说\n    明了新的VNode节点实际上比老的VNode节点多，需要将剩下的VNode对应的DOM插入到真实DOM\n    中，此时调用addVnodes（批量调用createElm接口）。\n  ")]),t._v(" "),n("img",{staticStyle:{height:"300px"},attrs:{src:t.$withBase("/vue/diff5.png")}}),t._v(" "),n("p",[t._v("\n    但是，当结束时newStartIdx >\n    newEndIdx时，说明新的VNode节点已经遍历完了，但是老的节点还有剩余，需要从文档中删的节点删除。\n  ")]),t._v(" "),n("img",{staticStyle:{height:"300px"},attrs:{src:t.$withBase("/vue/diff6.png")}}),t._v(" "),n("Content",{attrs:{"slot-key":"code29"}}),t._v(" "),n("Content",{attrs:{"slot-key":"header8"}}),t._v(" "),n("Content",{attrs:{"slot-key":"code30"}}),t._v(" "),n("Content",{attrs:{"slot-key":"code31"}}),t._v(" "),n("Content",{attrs:{"slot-key":"code32"}}),t._v(" "),n("Content",{attrs:{"slot-key":"code33"}}),t._v(" "),n("Content",{attrs:{"slot-key":"code34"}}),t._v(" "),n("Content",{attrs:{"slot-key":"code35"}}),t._v(" "),n("Content",{attrs:{"slot-key":"code36"}}),t._v(" "),n("Content",{attrs:{"slot-key":"code37"}}),t._v(" "),n("Content",{attrs:{"slot-key":"header9"}}),t._v(" "),n("Content",{attrs:{"slot-key":"code38"}}),t._v(" "),n("Content",{attrs:{"slot-key":"code39"}}),t._v(" "),n("Content",{attrs:{"slot-key":"code40"}}),t._v(" "),n("Content",{attrs:{"slot-key":"header10"}}),t._v(" "),n("p",[t._v("这里需要大家掌握Vue的基本应用，对Vue的全局API有一定的掌握")]),t._v(" "),n("h3",[t._v("Vue.util")]),t._v(" "),n("Content",{attrs:{"slot-key":"code-util"}}),t._v(" "),n("p",[t._v("\n    暴露的工具方法。这些方法不被视为公共API的一部分，除非你知道里面的风险，否则避免使用。（这个util是Vue内部的工具方法，可能会发生变动），例如：在Vue.router中就使用了这个工具方法\n  ")]),t._v(" "),n("h3",[t._v("Vue.set / Vue.delete")]),t._v(" "),n("Content",{attrs:{"slot-key":"code-set"}}),t._v(" "),n("Content",{attrs:{"slot-key":"code-del"}}),t._v(" "),n("p",[t._v("\n    Vue的缺陷：新增之前不存在的属性不会发生视图更新，修改数组索引不会发生视图更新\n    (解决方案就是通过$set方法,数组通过splice进行更新视图，对象则手动通知)\n  ")]),t._v(" "),n("h3",[t._v("Vue.nextTick")]),t._v(" "),n("Content",{attrs:{"slot-key":"code-nextTick"}}),t._v(" "),n("p",[t._v("\n    不难看出nextTick原理就是将回调函数存入到一个队列中，最后异步的清空这个队列\n  ")]),t._v(" "),n("h3",[t._v("timerFunc")]),t._v(" "),n("Content",{attrs:{"slot-key":"code-timerFunc"}}),t._v(" "),n("p",[t._v("\n    采用EventLoop中的微任务和宏任务，先采用微任务并按照优先级优雅降级的方式实现异步刷新\n  ")]),t._v(" "),n("h3",[t._v("Vue.observable")]),t._v(" "),n("p",[t._v("\n    2.6新增的方法，将对象进行观测，并返回观测后的对象。可以用来做全局变量，实现数据共享\n  ")]),t._v(" "),n("Content",{attrs:{"slot-key":"code-observable"}}),t._v(" "),n("h3",[t._v("Vue.options")]),t._v(" "),n("p",[t._v("\n    存放全局的组件、指令、过滤器的一个对象,及拥有_base属性保存Vue的构造函数\n  ")]),t._v(" "),n("Content",{attrs:{"slot-key":"code-options"}}),t._v(" "),n("h3",[t._v("Vue.use")]),t._v(" "),n("p",[t._v("\n    Vue.use\n    主要的作用就是调用插件的install方法,并将Vue作为第一个参数传入，这样做的好处是可以避免我们编写插件时需要依赖Vue导致版本问题。\n  ")]),t._v(" "),n("Content",{attrs:{"slot-key":"code-use"}}),t._v(" "),n("h3",[t._v("Vue.mixin")]),t._v(" "),n("p",[t._v("\n    全局混合方法,可以用来提取公共方法及状态等.Vue对不同的属性做了不同的合并策略\n  ")]),t._v(" "),n("Content",{attrs:{"slot-key":"code-mixin"}}),t._v(" "),n("p",[t._v("你可以通过查看strats这个对象来了解不同的合并策略。")]),t._v(" "),n("h3",[t._v("Vue.extend")]),t._v(" "),n("p",[t._v("\n    Vue中非常核心的一个方法，可以通过传入的对象获取这个对象的构造函数，后续在组件初始化过程中会用到此方法\n  ")]),t._v(" "),n("Content",{attrs:{"slot-key":"code-extend"}}),t._v(" "),n("p",[t._v("\n    extend 创建的是 Vue 构造器,我们可以自己实例化并且将其挂载在任意的元素上\n  ")]),t._v(" "),n("h3",[t._v("组件、指令、过滤器")]),t._v(" "),n("Content",{attrs:{"slot-key":"code-initAssetRegisters"}}),t._v(" "),n("p",[t._v("\n    初始化全局的api，Vue.component、Vue.directive、Vue.filter，这里仅仅是格式化用户传入的内容，将其绑定在Vue.options选项上\n  ")])],1)},o=[function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ul",[n("li",[t._v("完整版：同时包含编译器和运行时的版本")]),t._v(" "),n("li",[t._v("编译器：用来将模板字符串编译成js渲染函数的代码，体积大，效率低")]),t._v(" "),n("li",[t._v("\n      运行时（runtime）:\n      仅包含运行时,不包含编译器,创建Vue实例、渲染并处理虚拟DOM等的代码，体积小，效率高，是轻量级版本\n    ")]),t._v(" "),n("li",[t._v("CommonJS: cjs规范,用于配合老的打包工具比如：webpack1")]),t._v(" "),n("li",[t._v("ES Module: ES模块,用于webpack2")]),t._v(" "),n("li",[t._v("\n      UMD:\n      通用的模板版本，兼容cjs和amd,用于浏览器,vue.js默认文件就是运行时+编译器的UMD版本，本文统一使用该版本进行探究\n    ")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("instance/index.js 真正的Vue的构造函数,并在Vue的原型上扩展方法")]),this._v(" "),e("li",[this._v("core/index.js 增加全局API方法")]),this._v(" "),e("li",[this._v("untime/index.js 扩展$mount方法及平台对应的代码")])])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ul",[n("li",[t._v("\n      src/platforms/web/entry-runtime-with-compiler.js\n      "),n("ul",[n("li",[t._v("web平台相关的入口")]),t._v(" "),n("li",[t._v("重写了平台相关的$mount()方法")]),t._v(" "),n("li",[t._v("注册了Vue.compile()方法，传递一个HTML字符串返回render函数")])])]),t._v(" "),n("li",[t._v("\n      src/platforms/web/runtime/index.js\n      "),n("ul",[n("li",[t._v("web平台相关")]),t._v(" "),n("li",[t._v("注册和平台相关的全局指令：v-model/v-show")]),t._v(" "),n("li",[t._v("注册和平台相关的全局组件：v-transition/v-transition-group")]),t._v(" "),n("li",[t._v("\n          全局方法：\n          "),n("ul",[n("li",[t._v("__patch__:把虚拟DOM转换成真实DOM")]),t._v(" "),n("li",[t._v("$mount: 挂载方法")])])])])]),t._v(" "),n("li",[t._v("\n      src/core/index.js\n      "),n("ul",[n("li",[t._v("与平台无关")]),t._v(" "),n("li",[t._v("设置了Vue的静态方法，initGlobalAPI(Vue)")])])]),t._v(" "),n("li",[t._v("\n      src/core/instance/index.js\n      "),n("ul",[n("li",[t._v("与平台无关")]),t._v(" "),n("li",[t._v("定义了构造函数，调用了this._init(options)方法")]),t._v(" "),n("li",[t._v("与Vue中混入了常用的实例成员")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("new VNode不存在就删；")]),this._v(" "),e("li",[this._v("old VNode不存在就增；")]),this._v(" "),e("li",[this._v("都存在就执行diff执行更新")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("\n      新老节点均有children子节点，则对子节点进行diff操作，调用updateChildren\n    ")]),this._v(" "),e("li",[this._v("\n      如果老节点没有子节点而新节点有子节点，先清空老节点的文本内容，然后为其新增子节点。\n    ")]),this._v(" "),e("li",[this._v("\n      当新节点没有子节点而老节点有子节点的时候，则移除该节点的所有子节点。\n    ")]),this._v(" "),e("li",[this._v("当新老节点都无子节点的时候，只是文本的替换。")])])}]},387:function(t,e,n){"use strict";n.r(e);var v=n(384),o=n(326);for(var _ in o)["default"].indexOf(_)<0&&function(t){n.d(e,t,(function(){return o[t]}))}(_);n(380);var s=n(45),i=Object(s.a)(o.default,v.a,v.b,!1,null,"529ed510",null);e.default=i.exports}}]);
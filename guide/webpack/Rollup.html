<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>小匪肥肥的游乐场</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/blog/img/logo1.jpg">
    <meta name="description" content="VuePress">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/blog/assets/css/0.styles.f51e841c.css" as="style"><link rel="preload" href="/blog/assets/js/app.5a07472d.js" as="script"><link rel="preload" href="/blog/assets/js/3.1a789601.js" as="script"><link rel="preload" href="/blog/assets/js/74.280f6a1f.js" as="script"><link rel="preload" href="/blog/assets/js/37.00d23916.js" as="script"><link rel="prefetch" href="/blog/assets/js/1.7edf47c2.js"><link rel="prefetch" href="/blog/assets/js/10.cf932b27.js"><link rel="prefetch" href="/blog/assets/js/11.428e9a7f.js"><link rel="prefetch" href="/blog/assets/js/12.d5fcbca6.js"><link rel="prefetch" href="/blog/assets/js/13.01f0776c.js"><link rel="prefetch" href="/blog/assets/js/14.116beb90.js"><link rel="prefetch" href="/blog/assets/js/15.1654677c.js"><link rel="prefetch" href="/blog/assets/js/16.a06c2f60.js"><link rel="prefetch" href="/blog/assets/js/17.a4d25310.js"><link rel="prefetch" href="/blog/assets/js/18.8e8204fc.js"><link rel="prefetch" href="/blog/assets/js/19.614c33de.js"><link rel="prefetch" href="/blog/assets/js/20.e6609b0d.js"><link rel="prefetch" href="/blog/assets/js/21.e3d25715.js"><link rel="prefetch" href="/blog/assets/js/22.d36a5209.js"><link rel="prefetch" href="/blog/assets/js/23.d656be96.js"><link rel="prefetch" href="/blog/assets/js/24.3c4e3f5f.js"><link rel="prefetch" href="/blog/assets/js/25.51dd6038.js"><link rel="prefetch" href="/blog/assets/js/26.650bd0cd.js"><link rel="prefetch" href="/blog/assets/js/27.bf7610d6.js"><link rel="prefetch" href="/blog/assets/js/28.65684b31.js"><link rel="prefetch" href="/blog/assets/js/29.82a0d372.js"><link rel="prefetch" href="/blog/assets/js/30.26246fa3.js"><link rel="prefetch" href="/blog/assets/js/31.1b14eed9.js"><link rel="prefetch" href="/blog/assets/js/32.08d7107b.js"><link rel="prefetch" href="/blog/assets/js/33.a6afb1b5.js"><link rel="prefetch" href="/blog/assets/js/34.1624be65.js"><link rel="prefetch" href="/blog/assets/js/35.f6fced37.js"><link rel="prefetch" href="/blog/assets/js/36.13cfd92d.js"><link rel="prefetch" href="/blog/assets/js/38.6c83d131.js"><link rel="prefetch" href="/blog/assets/js/39.12d06d9f.js"><link rel="prefetch" href="/blog/assets/js/4.33c8349b.js"><link rel="prefetch" href="/blog/assets/js/40.cad1baab.js"><link rel="prefetch" href="/blog/assets/js/41.a3992672.js"><link rel="prefetch" href="/blog/assets/js/42.a64aac28.js"><link rel="prefetch" href="/blog/assets/js/43.de68db82.js"><link rel="prefetch" href="/blog/assets/js/44.83884ed2.js"><link rel="prefetch" href="/blog/assets/js/45.60f82d8a.js"><link rel="prefetch" href="/blog/assets/js/46.97923c1d.js"><link rel="prefetch" href="/blog/assets/js/47.7031b903.js"><link rel="prefetch" href="/blog/assets/js/48.c5d4a93a.js"><link rel="prefetch" href="/blog/assets/js/49.2789f4ad.js"><link rel="prefetch" href="/blog/assets/js/5.164e014d.js"><link rel="prefetch" href="/blog/assets/js/50.bdcac65e.js"><link rel="prefetch" href="/blog/assets/js/51.04cbcc3b.js"><link rel="prefetch" href="/blog/assets/js/52.7dfb48cd.js"><link rel="prefetch" href="/blog/assets/js/53.ea283efc.js"><link rel="prefetch" href="/blog/assets/js/54.7b0c0a07.js"><link rel="prefetch" href="/blog/assets/js/55.324243a6.js"><link rel="prefetch" href="/blog/assets/js/56.ba16ec33.js"><link rel="prefetch" href="/blog/assets/js/57.53c09e7c.js"><link rel="prefetch" href="/blog/assets/js/58.3b1341de.js"><link rel="prefetch" href="/blog/assets/js/59.8e1561c7.js"><link rel="prefetch" href="/blog/assets/js/6.f3e9d1b0.js"><link rel="prefetch" href="/blog/assets/js/60.5e1f4fbd.js"><link rel="prefetch" href="/blog/assets/js/61.c30006de.js"><link rel="prefetch" href="/blog/assets/js/62.c7f09eb3.js"><link rel="prefetch" href="/blog/assets/js/63.3cb1dcb3.js"><link rel="prefetch" href="/blog/assets/js/64.59cd9234.js"><link rel="prefetch" href="/blog/assets/js/65.bed8eb43.js"><link rel="prefetch" href="/blog/assets/js/66.e9b78c3b.js"><link rel="prefetch" href="/blog/assets/js/67.a5fbd73b.js"><link rel="prefetch" href="/blog/assets/js/68.1a675a1d.js"><link rel="prefetch" href="/blog/assets/js/69.f1e7cdf0.js"><link rel="prefetch" href="/blog/assets/js/7.ad3d8631.js"><link rel="prefetch" href="/blog/assets/js/70.3028d286.js"><link rel="prefetch" href="/blog/assets/js/71.2f6e220c.js"><link rel="prefetch" href="/blog/assets/js/72.69917eee.js"><link rel="prefetch" href="/blog/assets/js/73.293765b4.js"><link rel="prefetch" href="/blog/assets/js/75.020cbed2.js"><link rel="prefetch" href="/blog/assets/js/76.546b1fb3.js"><link rel="prefetch" href="/blog/assets/js/77.41135229.js"><link rel="prefetch" href="/blog/assets/js/8.eee9cac4.js"><link rel="prefetch" href="/blog/assets/js/9.71ccef2b.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.f51e841c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/img/logo1.jpg" alt="小匪肥肥的游乐场" class="logo"> <span class="site-name can-hide">小匪肥肥的游乐场</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/guide/login/login.html" class="nav-link">
  指南
</a></div><div class="nav-item"><a href="/blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/blog/base/" class="nav-link">
  指南
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/guide/login/login.html" class="nav-link">
  指南
</a></div><div class="nav-item"><a href="/blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/blog/base/" class="nav-link">
  指南
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><a href="/blog/guide/es6/deep" class="sidebar-heading clickable"><span>Escript</span> <span class="arrow right"></span></a> <!----></section></li><li><a href="/blog/guide/ts/ts.html" class="sidebar-link">Tscript</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/guide/css/css" class="sidebar-heading clickable"><span>CSS世界</span> <span class="arrow right"></span></a> <!----></section></li><li><a href="/blog/guide/network/network.html" class="sidebar-link">网络协议</a></li><li><a href="/blog/guide/browser/browser.html" class="sidebar-link">浏览器工作原理</a></li><li><a href="/blog/guide/network/network.html" class="sidebar-link">前端性能优化</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/guide/webpack/webpack" class="sidebar-heading clickable open"><span>前端工程化</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/guide/webpack/webpack.html" class="sidebar-link">Webpack深入理解</a></li><li><a href="/blog/guide/webpack/Rollup.html" aria-current="page" class="active sidebar-link">Rollup与Parcel</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/guide/webpack/Rollup.html#rollup与webpack" class="sidebar-link">Rollup与Webpack</a></li><li class="sidebar-sub-header"><a href="/blog/guide/webpack/Rollup.html#parcel零配置完成打包" class="sidebar-link">Parcel零配置完成打包</a></li></ul></li><li><a href="/blog/guide/webpack/package.html" class="sidebar-link">Package配置</a></li><li><a href="/blog/guide/webpack/engineered.html" class="sidebar-link">前端工程化</a></li></ul></section></li><li><a href="/blog/guide/control/control.html" class="sidebar-link">前端监控</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/guide/algorithm/two-points" class="sidebar-heading clickable"><span>算法</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/guide/vue/communication" class="sidebar-heading clickable"><span>Vue模块</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/guide/react/sourceCode" class="sidebar-heading clickable"><span>React模块</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/guide/node/base" class="sidebar-heading clickable"><span>Node模块</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><div data-v-64770dde><div class="content__title-rollup" data-v-64770dde><h2 id="rollup与webpack"><a href="#rollup与webpack" class="header-anchor">#</a> Rollup与Webpack</h2></div> <p data-v-64770dde>Rollup 是一款 ES Modules 打包器。它也可以将项目中散落的细小模块打包为整块代码，从而使得这些划分的模块可以更好地运行在浏览器环境或者 Node.js 环境。</p> <p data-v-64770dde>从作用上来看，Rollup 与 Webpack 非常类似。不过相比于 Webpack，Rollup 要小巧的多。因为 Webpack 在配合一些插件的使用下，几乎可以完成开发过程中绝大多数前端工程化的工作。而 Rollup 可以说仅仅是一个 ES Modules 打包器，没有更多其他的功能了。</p> <p data-v-64770dde>例如，在 Webpack 中支持 HMR 这种对开发过程十分友好的功能，而在 Rollup 中就没有办法完全支持。</p> <p data-v-64770dde>Rollup 诞生的目的并不是要与 Webpack 这样的工具全面竞争。它的初衷只是希望能够提供一个高效的 ES Modules 打包器，充分利用 ES Modules 的各项特性，构建出结构扁平，性能出众的类库。</p> <p data-v-64770dde>至于它的其他特点和优势，我们需要上手过后才能深入了解。</p> <h3 data-v-64770dde>快速上手</h3> <p data-v-64770dde>这里我准备了一个简单的示例，具体结构如下：</p> <div class="content__code-rollup1" data-v-64770dde><div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">.</span>
├── src
│   ├── index<span class="token punctuation">.</span>js
│   ├── logger<span class="token punctuation">.</span>js
│   └── messages<span class="token punctuation">.</span>js
└── <span class="token keyword">package</span><span class="token punctuation">.</span>json

</code></pre></div></div> <p data-v-64770dde>在这个示例的源代码中我准备了三个文件，并且使用 ES Modules 组织的代码模块化。部分代码如下：</p> <div class="content__code-rollup2" data-v-64770dde><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./src/messages.js</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  hi<span class="token operator">:</span> <span class="token string">'Hey Guys, I am zce~'</span>
<span class="token punctuation">}</span>
<span class="token comment">// ./src/logger.js</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">log</span> <span class="token operator">=</span> <span class="token parameter">msg</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'---------- INFO ----------'</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'--------------------------'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">error</span> <span class="token operator">=</span> <span class="token parameter">msg</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'---------- ERROR ----------'</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'---------------------------'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// ./src/index.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> log <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./logger'</span>
<span class="token keyword">import</span> messages <span class="token keyword">from</span> <span class="token string">'./messages'</span>
<span class="token function">log</span><span class="token punctuation">(</span>messages<span class="token punctuation">.</span>hi<span class="token punctuation">)</span>

</code></pre></div></div> <p data-v-64770dde>如上述代码所示，其中：</p> <ul data-v-64770dde><li data-v-64770dde>messages.js 文件中以默认导出的方式导出了一个对象；</li> <li data-v-64770dde>logger.js 文件中单个导出了两个函数成员；</li> <li data-v-64770dde>最后在 index.js 文件中导入了这两个模块，并且使用了它们。</li></ul> <p data-v-64770dde>接下来，我们尝试使用 Rollup 完成这个示例应用的打包。这里需要先通过 npm 安装 rollup 这个模块。具体命令如下：</p> <p data-v-64770dde>$ npm i rollup --save-dev</p> <p data-v-64770dde>安装完成过后，rollup 这个模块同样会在 node_modules/.bin 目录中为我们提供一个 CLI 程序，我们就可以通过这个 CLI 去使用 Rollup 打包。具体命令如下：</p> <p data-v-64770dde>$ npx rollup</p> <p data-v-64770dde>P.S. 对于 node_modules/.bin 目录下的 CLI，我们可以使用 npx 命令或者 yarn 命令直接启动。</p> <p data-v-64770dde>执行 rollup 命令，在不传递任何参数的情况下，这个命令会自动打印出它的帮助信息。具体如下图：</p> <img src="/blog/webpack/rollup1.png" data-v-64770dde> <p data-v-64770dde>在这个帮助信息的一开始，就已经告诉我们 rollup 命令的正确用法了：我们应该通过参数指定一个打包入口文件。正确命令如下：</p> <p data-v-64770dde>$ npx rollup ./src/index.js</p> <p data-v-64770dde>这里指定的打包入口是 src/index.js 文件。再次执行 rollup 命令，具体执行结果如下：</p> <img src="/blog/webpack/rollup2.png" data-v-64770dde> <p data-v-64770dde>根据控制台的输出结果，我们发现 Rollup 直接将打包结果打印到控制台中了。</p> <p data-v-64770dde>当然，正常情况下我们还是需要将打包结果输出到一个文件中。具体就是通过 CLI 的 --file 参数指定输出文件路径，具体命令如下：</p> <p data-v-64770dde>$ npx rollup ./src/index.js --file ./dist/bundle.js</p> <p data-v-64770dde>这样打包的结果就会输出到文件中。</p> <p data-v-64770dde>完成以后，我们找到 Rollup 打包输出的文件，具体结果如下</p> <img src="/blog/webpack/rollup3.png" data-v-64770dde> <p data-v-64770dde>在这个文件中我们的第一印象就是，Rollup 打包结果惊人的简洁，基本上就跟我们手写的代码一样。相比于 Webpack 大量的引导代码和一堆的模块函数，这里的输出结果没有任何多余代码，就是把打包过程中的各个模块按照依赖顺序，先后拼接到了一起。</p> <p data-v-64770dde>而且我们仔细观察打包结果，你会发现，在我们输出的结果中只会保留那些用到的部分，对于未引用部分都没有输出。这是因为 Rollup 默认会自动开启 Tree-shaking 优化输出结果，Tree-shaking 的概念最早也就是 Rollup 这个工具提出的。</p> <h3 data-v-64770dde>配置文件</h3> <p data-v-64770dde>Rollup 同样支持以配置文件的方式去配置打包过程中的各项参数，我们可以在项目的根目录下新建一个 rollup.config.js 的配置文件。具体结构如下：</p> <div class="content__code-rollup3" data-v-64770dde><div class="language-js extra-class"><pre class="language-js"><code> <span class="token punctuation">.</span>
 ├── src
 │   ├── index<span class="token punctuation">.</span>js
 │   ├── logger<span class="token punctuation">.</span>js
 │   └── messages<span class="token punctuation">.</span>js
 ├── <span class="token keyword">package</span><span class="token punctuation">.</span>json
<span class="token operator">+</span>└── rollup<span class="token punctuation">.</span>config<span class="token punctuation">.</span>js

</code></pre></div></div> <p data-v-64770dde>这个文件虽然同样是运行在 Node.js 环境中，但是 Rollup 会额外处理配置文件，所以在 rollup.config.js 中我们可以直接使用 ES Modules 标准。具体代码如下：</p> <div class="content__code-rollup4" data-v-64770dde><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./rollup.config.js</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  input<span class="token operator">:</span> <span class="token string">'src/index.js'</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    file<span class="token operator">:</span> <span class="token string">'dist/bundle.js'</span><span class="token punctuation">,</span>
    format<span class="token operator">:</span> <span class="token string">'es'</span> <span class="token comment">// 输出格式</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-64770dde>这个文件中需要导出一个配置对象，在这个对象中我们可以通过 input 属性指定打包的入口文件路径，通过 output 指定输出相关配置，output 属性是一个对象，在 output 对象中可以使用 file 属性指定输出的文件名，format 属性指定输出代码的格式。</p> <p data-v-64770dde>完成以后，我们回到命令行，再次执行 rollup 命令，不过需要注意的是，这里需要通过 --config 参数来表明使用项目中的配置文件。你也可以通过这个参数来指定不同的配置文件名称。具体命令如下：</p> <p data-v-64770dde>$ npx rollup --config # 使用默认配置文件</p> <p data-v-64770dde>$ npx rollup --config rollup.prod.js # 指定配置文件路径</p> <h3 data-v-64770dde>输出格式</h3> <p data-v-64770dde>Rollup 打包支持多种输出格式，这里我们回到配置文件中，配置同时输出所有格式下的文件，具体配置如下：</p> <div class="content__code-rollup5" data-v-64770dde><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./rollup.config.js</span>
<span class="token comment">// 所有 Rollup 支持的格式</span>
<span class="token keyword">const</span> formats <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'es'</span><span class="token punctuation">,</span> <span class="token string">'amd'</span><span class="token punctuation">,</span> <span class="token string">'cjs'</span><span class="token punctuation">,</span> <span class="token string">'iife'</span><span class="token punctuation">,</span> <span class="token string">'umd'</span><span class="token punctuation">,</span> <span class="token string">'system'</span><span class="token punctuation">]</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> formats<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">format</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
  input<span class="token operator">:</span> <span class="token string">'src/index.js'</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    file<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">dist/bundle.</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>format<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.js</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
    format
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

</code></pre></div></div> <p data-v-64770dde>在这个配置当中我们导出了一个数组，数组中的每个成员都是一个单独的打包配置，这样 Rollup 就会分别按照每个配置单独打包。这一点与 Webpack 非常相似。</p> <p data-v-64770dde>配置完成之后，我们回到命令行终端，再次运行 Rollup 打包。那这次打包过后，dist 目录下就会生成不同格式的输出结果，如下图所示：</p> <img src="/blog/webpack/rollup4.png" data-v-64770dde> <p data-v-64770dde>你可以自己依次去了解一下每种格式的输出结果，其实不同的输出格式大都是为了适配不同的运行环境，并没有什么需要额外理解的地方。</p> <h3 data-v-64770dde>使用插件</h3> <p data-v-64770dde>Rollup 自身的功能就只是 ES Modules 模块的合并，如果有更高级的要求，例如加载其他类型的资源文件或者支持导入 CommonJS 模块，又或是编译 ES 新特性，这些额外的需求 Rollup 同样支持使用插件去扩展实现。</p> <p data-v-64770dde>Webpack 中划分了 Loader、Plugin 和 Minimizer 三种扩展方式，而插件是 Rollup 的唯一的扩展方式。</p> <p data-v-64770dde>这里我们先来尝试使用一个可以让我们在代码中导入 JSON 文件的插件：@rollup/plugin-json，通过这个过程来了解如何在 Rollup 中使用插件。</p> <p data-v-64770dde>首先我们需要将 @rollup/plugin-json 作为项目的开发依赖安装进来。具体安装命令：</p> <p data-v-64770dde>$ npm i @rollup/plugin-json --save-dev</p> <p data-v-64770dde>安装完成过后，我们打开配置文件。由于 rollup 的配置文件中可以直接使用 ES Modules，所以我们这里使用 import 导入这个插件模块。具体代码如下：</p> <div class="content__code-rollup6" data-v-64770dde><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./rollup.config.js</span>
<span class="token keyword">import</span> json <span class="token keyword">from</span> <span class="token string">'@rollup/plugin-json'</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  input<span class="token operator">:</span> <span class="token string">'src/index.js'</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    file<span class="token operator">:</span> <span class="token string">'dist/bundle.js'</span><span class="token punctuation">,</span>
    format<span class="token operator">:</span> <span class="token string">'es'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-64770dde>@rollup/plugin-json 模块的默认导出就是一个插件函数。我们可以将这个函数的调用结果添加到配置对象的 plugins 数组中，注意这里是将调用结果放到数组中，而不是将这个函数直接放进去。</p> <p data-v-64770dde>配置好这个插件过后，我们就可以在代码中通过 import 导入 json 文件了。我们回到 index.js 文件中，这里我们尝试通过 import 导入 package.json，具体代码如下：</p> <div class="content__code-rollup7" data-v-64770dde><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./src/index.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> name<span class="token punctuation">,</span> version <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'../package.json'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> version<span class="token punctuation">)</span>
</code></pre></div></div> <p data-v-64770dde>那这个 JSON 文件中的每一个属性都会作为单独的导出成员。我们可以提取一下 JSON 中的 name 和 version，然后把它打印出来。</p> <p data-v-64770dde>完成以后，我们打开命令行终端，再次运行 Rollup 打包。打包完成以后，我们找到输出的 bundle.js，具体结果如下：</p> <img src="/blog/webpack/rollup5.png" data-v-64770dde> <p data-v-64770dde>此时你就能看到，package.json 中的 name 和 version 正常被打包进来了，而且其他没用到的属性也都被 Tree-shaking 移除掉了。</p> <p data-v-64770dde>以上就是 Rollup 中插件的使用。</p> <h3 data-v-64770dde>加载 NPM 模块</h3> <p data-v-64770dde>Rollup 默认只能够按照文件路径的方式加载本地的模块文件，对于 node_modules 目录中的第三方模块，并不能像 Webpack 一样，直接通过模块名称直接导入。</p> <p data-v-64770dde>为了抹平这个差异，Rollup 给出了一个 @rollup/plugin-node-resolve 插件，通过使用这个插件，我们就可以在代码中直接使用模块名称导入模块了。</p> <p data-v-64770dde>同样，我们需要先安装这个插件，具体命令如下：</p> <p data-v-64770dde>$ npm i @rollup/plugin-node-resolve --save-dev</p> <p data-v-64770dde>安装完成过后，打开配置文件，这里同样导入插件函数，然后把它配置到 plugins 数组中。具体配置如下：</p> <div class="content__code-rollup8" data-v-64770dde><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./rollup.config.js</span>
<span class="token keyword">import</span> json <span class="token keyword">from</span> <span class="token string">'@rollup/plugin-json'</span>
<span class="token keyword">import</span> resolve <span class="token keyword">from</span> <span class="token string">'@rollup/plugin-node-resolve'</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  input<span class="token operator">:</span> <span class="token string">'src/index.js'</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    file<span class="token operator">:</span> <span class="token string">'dist/bundle.js'</span><span class="token punctuation">,</span>
    format<span class="token operator">:</span> <span class="token string">'es'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-64770dde>完成以后我们就可以回到代码中直接导入 node_modules 中的第三方模块了。例如：</p> <div class="content__code-rollup9" data-v-64770dde><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./src/index.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> camelCase <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'lodash-es'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">camelCase</span><span class="token punctuation">(</span><span class="token string">'hello rollup'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

</code></pre></div></div> <p data-v-64770dde>这里我导入的是我提前安装好的一个 lodash-es 模块，这个模块就是常用的 lodash 模块的 ESM 版本。导入过后我们就可以使用这个模块所提供的工具方法了。</p> <p data-v-64770dde>P.S. 相比于普通的 lodash，lodash-es 可以更好地支持 Tree-shaking。</p> <p data-v-64770dde>完成过后我们再次打开命令行终端，运行 Rollup 打包，此时 lodash 就能够打包到我们的 bundle.js 中了。</p> <p data-v-64770dde>这里使用 Lodash 的 ESM 版本而不是 Lodash 普通版本的原因是 Rollup 默认只能处理 ESM 模块。如果要使用普通版本则需要额外处理。</p> <h3 data-v-64770dde>加载 CommonJS 模块</h3> <p data-v-64770dde>由于 Rollup 设计的是只处理 ES Modules 模块的打包，所以如果在代码中导入 CommonJS 模块，默认是不被支持的。但是目前大量的 NPM 模块还是使用 CommonJS 方式导出成员，所以为了兼容这些模块。官方给出了一个插件，叫作 @rollup/plugin-commonjs。</p> <p data-v-64770dde>这个插件在用法上跟前面两个插件是一样的，我就不单独演示了。我们直接看一下这个插件的效果。这里我添加了一个 cjs-module.js 文件，具体代码如下：</p> <div class="content__code-rollup10" data-v-64770dde><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./src/cjs-module.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  foo<span class="token operator">:</span> <span class="token string">'bar'</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-64770dde>这个文件中使用 CommonJS 的方式导出了一个对象。然后回到入口文件中通过 ES Modules 的方式导入，具体代码如下：</p> <div class="content__code-rollup11" data-v-64770dde><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./src/index.js</span>
<span class="token comment">// 导入 CommonJS 模块成员</span>
<span class="token keyword">import</span> cjs <span class="token keyword">from</span> <span class="token string">'./cjs-module'</span>
<span class="token comment">// 使用模块成员</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cjs<span class="token punctuation">)</span> <span class="token comment">// cjs =&gt; { foo: 'bar' }</span>

</code></pre></div></div> <p data-v-64770dde>入口文件导入的结果就是 cjs-module.js 中导出的对象了。</p> <h3 data-v-64770dde>Code Splitting</h3> <p data-v-64770dde>Rollup 的最新版本中已经开始支持代码拆分了。我们同样可以使用符合 ES Modules 标准的动态导入方式实现模块的按需加载。例如：</p> <div class="content__code-rollup12" data-v-64770dde><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./src/index.js</span>
<span class="token comment">// 动态导入的模块会自动分包</span>
<span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./logger'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> log <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'code splitting~'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div></div> <p data-v-64770dde>Rollup 内部也会处理代码拆分。不过按照之前的配置方式，这里直接打包会报出一个错误：</p> <img src="/blog/webpack/rollup6.png" data-v-64770dde> <p data-v-64770dde>出现这个错误的原因是：在 Rollup 在分包过后会输出多个 JS 文件，需要我们在配置中指定输出的目录，而不是一个具体的文件名，具体配置如下：</p> <div class="content__code-rollup13" data-v-64770dde><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./rollup.config.js</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  input<span class="token operator">:</span> <span class="token string">'src/index.js'</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// file: 'dist/bundle.js', // code splitting 输出的是多个文件</span>
    dir<span class="token operator">:</span> <span class="token string">'dist'</span><span class="token punctuation">,</span>
    format<span class="token operator">:</span> <span class="token string">'es'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-64770dde>这里我们将 output 配置中的 file 选项删掉，取而代之的是添加一个 dir 选项，把它设置为 dist，也就是输出到 dist 目录中。</p> <p data-v-64770dde>这样的话，再次打包就可以正常输出了。具体输出结果如下：</p> <img src="/blog/webpack/rollup7.png" data-v-64770dde> <p data-v-64770dde>这次打包过程中，Rollup 就会自动提取动态导入的模块到单独的 JS 文件中了。</p> <h3 data-v-64770dde>输出格式问题</h3> <p data-v-64770dde>目前采用的输出格式是 es，所以自动分包过后，得到的代码还是使用 ES Modules 实现的动态模块加载，具体输出结果如下：</p> <img src="/blog/webpack/rollup8.png" data-v-64770dde> <p data-v-64770dde>很明显，这种方式的代码仍然会存在环境兼容性问题：如果在低版本浏览器，这种输出结果是无法正常执行的。</p> <p data-v-64770dde>解决这个问题的办法就是修改 Rollup 打包输出的格式。目前所有支持动态导入的输出格式中，只有 amd 和 system 两种格式打包的结果适合于浏览器环境。</p> <p data-v-64770dde>所以在这种情况下，我们可以选择以 amd 或者 system 格式输出。这里我们以 amd 为例，这里我们先将 Rollup 配置中的 format 设置为 amd。具体配置如下：</p> <div class="content__code-rollup14" data-v-64770dde><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./rollup.config.js</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  input<span class="token operator">:</span> <span class="token string">'src/index.js'</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    dir<span class="token operator">:</span> <span class="token string">'dist'</span><span class="token punctuation">,</span>
    format<span class="token operator">:</span> <span class="token string">'amd'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-64770dde>这样的话，再次打包输出的结果就是采用 AMD 标准组织的代码了，具体如下：</p> <img src="/blog/webpack/rollup9.png" data-v-64770dde> <p data-v-64770dde>需要注意一点，这种 AMD 标准在浏览器中也不是直接支持的，也就是说我们还是需要使用一个支持这个标准的库来加载这些输出的模块，例如 Require.js，具体使用方式参考：</p> <p data-v-64770dde>P.S. 本文中所有的案例源代码：https://github.com/zce/rollup-demo</p> <h3 data-v-64770dde>总结</h3> <p data-v-64770dde>通过以上的探索，我们发现 Rollup 确实有它的优势：</p> <ul data-v-64770dde><li data-v-64770dde>输出结果更加扁平，执行效率更高；</li> <li data-v-64770dde>自动移除未引用代码；</li> <li data-v-64770dde>打包结果依然完全可读。</li></ul> <p data-v-64770dde>但是它的缺点也同样明显：</p> <ul data-v-64770dde><li data-v-64770dde>加载非 ESM 的第三方模块比较复杂；</li> <li data-v-64770dde>因为模块最终都被打包到全局中，所以无法实现 HMR；</li> <li data-v-64770dde>浏览器环境中，代码拆分功能必须使用 Require.js 这样的 AMD 库。</li></ul> <p data-v-64770dde>综合以上特点，我们发现如果我们开发的是一个应用程序，需要大量引用第三方模块，同时还需要 HMR 提升开发体验，而且应用过大就必须要分包。那这些需求 Rollup 都无法满足。</p> <p data-v-64770dde>而如果我们是开发一个 JavaScript 框架或者库，那这些优点就特别有必要，而缺点呢几乎也都可以忽略，所以在很多像 React 或者 Vue 之类的框架中都是使用的 Rollup 作为模块打包器，而并非 Webpack。</p> <p data-v-64770dde>但是到目前为止，开源社区中大多数人还是希望这两个工具共同存在，并且能够相互支持和借鉴，原因很简单：让更专业的工具完成更专业的事情。</p> <p data-v-64770dde>总结一下：Webpack 大而全，Rollup 小而美。</p> <p data-v-64770dde>在对它们的选择上，我的基本原则是：应用开发使用 Webpack，类库或者框架开发使用 Rollup。</p> <p data-v-64770dde>不过这并不是绝对的标准，只是经验法则。因为 Rollup 也可用于构建绝大多数应用程序，而 Webpack 同样也可以构建类库或者框架。</p> <p data-v-64770dde>另外随着近几年 Webpack 的发展，Rollup 中的很多优势几乎已经抹平了，所以这种对比慢慢地也就没有太大意义了。</p> <div class="content__title-Parcel" data-v-64770dde><h2 id="parcel零配置完成打包"><a href="#parcel零配置完成打包" class="header-anchor">#</a> Parcel零配置完成打包</h2></div> <p data-v-64770dde>Parcel 是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，我们只需了解它提供的几个简单的命令，就可以直接使用它去构建我们的前端应用程序了。</p> <h3 data-v-64770dde>快速上手</h3> <p data-v-64770dde>这里我们先创建一个空目录，然后通过 npm init 初始化一个项目中的 package.json 文件。</p> <p data-v-64770dde>完成以后我们就可以安装 Parcel 模块了，具体命令如下：</p> <p data-v-64770dde>$ npm install parcel-bundler --save-dev</p> <p data-v-64770dde>这里需要注意 Parcel 的 npm 模块名称叫作 parcel-bundler，我们同样应该将它安装到项目的开发依赖中。</p> <p data-v-64770dde>安装完成过后，parcel-bundler 模块就在 node_modules/.bin 目录中提供了一个叫作 parcel 的 CLI 程序，后续我们就是使用这个 CLI 程序执行应用打包。</p> <p data-v-64770dde>既然是打包应用代码，那我们这里就得先有代码。我们回到项目中创建一些必需的文件，结构如下</p> <div class="content__code-Parcel1" data-v-64770dde><div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">.</span>
├── src
│   ├── index<span class="token punctuation">.</span>html
│   ├── logger<span class="token punctuation">.</span>js
│   └── main<span class="token punctuation">.</span>js
└── <span class="token keyword">package</span><span class="token punctuation">.</span>json

</code></pre></div></div> <p data-v-64770dde>首先在根目录下新建一个 src 目录，用于存放开发阶段编写的源代码，同时创建两个 JS 文件，分别是 logger.js 和 main.js，然后再创建一个 index.html 文件，这个 index.html 文件会将是 Parcel 打包的入口文件。</p> <p data-v-64770dde>虽然 Parcel 跟 Webpack 一样都支持以任意类型文件作为打包入口，不过 Parcel 官方还是建议我们使用 HTML 文件作为入口。官方的理由是 HTML 是应用在浏览器端运行时的入口。</p> <p data-v-64770dde>那在这个 HTML 入口文件中，我们可以像平时一样去编写代码，也可以正常去引用资源。在它里面引用的资源，最终都会被 Parcel 打包到一起。</p> <p data-v-64770dde>我们这里先尝试在 index.html 中引入 main.js 脚本文件，具体代码如下：</p> <div class="content__code-Parcel2" data-v-64770dde><div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- ./src/index.html --&gt;</span>
<span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>en<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>UTF-8<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Parcel Tutorials<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>main.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>

</code></pre></div></div> <p data-v-64770dde>紧接着，在 main.js 中按照 ES Modules 的方式导入 logger.js 中的成员，具体代码如下：</p> <div class="content__code-Parcel3" data-v-64770dde><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./src/main.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> log <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./logger'</span>
<span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello parcel'</span><span class="token punctuation">)</span>
<span class="token comment">// ./src/logger.js</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">log</span> <span class="token operator">=</span> <span class="token parameter">msg</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'---------- INFO ----------'</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-64770dde>Parcel 同样支持对 ES Modules 模块的打包。</p> <p data-v-64770dde>完成以后，我们打开命令行终端，然后使用 npx 去运行 node_modules 目录下的 parcel 命令。具体命令如下：</p> <p data-v-64770dde>$ npx parcel src/index.html</p> <p data-v-64770dde>parcel 命令需要我们传入打包入口文件路径，那我们这里就应该是 src/index.html。</p> <p data-v-64770dde>此时如果执行这个命令，Parcel 就会根据这里传入的参数，先找到 index.html，然后在根据 HTML 中的 script 标签，找到 main.js，最后再顺着 import 语句找到 logger.js 模块，从而完成整体打包。</p> <p data-v-64770dde>回车执行过后，这里我们发现 Parcel 这个命令不仅仅帮我们打包了应用，而且还同时开启了一个开发服务器，这就跟 Webpack Dev Server 一样。</p> <p data-v-64770dde>我们打开这个地址，启动浏览器，然后打开开发人员工具。Parcel 同样支持自动刷新这样的功能。具体效果如下：</p> <img src="/blog/webpack/Parcel1.png" data-v-64770dde> <p data-v-64770dde>以上就是 Parcel 的基本使用，相比于 Webpack，Parcel 在使用上的确简化了很多。</p> <h3 data-v-64770dde>模块热替换</h3> <p data-v-64770dde>如果你需要的是模块热替换的体验，Parcel 中也可以支持。我们回到 main.js 文件中，这里同样需要使用 HMR 的 API。具体代码如下：</p> <div class="content__code-Parcel4" data-v-64770dde><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./src/main.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> log <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./logger'</span>
<span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello parcel'</span><span class="token punctuation">)</span>
<span class="token comment">// HMR API</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>module<span class="token punctuation">.</span>hot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  module<span class="token punctuation">.</span>hot<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'HMR～'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-64770dde>我们需要先判断一下 module.hot 对象是否存在，如果存在则证明当前环境可以使用 HMR 的 API，那我们就可以使用 module.hot.accept 方法去处理热替换。</p> <p data-v-64770dde>不过这里的 accept 方法与 Webpack 提供的 HMR 有点不太一样，Webpack 中的 accept 方法支持接收两个参数，用来处理指定的模块更新后的逻辑。</p> <p data-v-64770dde>而这里 Parcel 提供的 accept 只需要接收一个回调参数，作用就是当前模块更新或者所依赖的模块更新过后自动执行传入的回调函数，这相比于之前 Webpack 中的用法要简单很多。</p> <p data-v-64770dde>关于模块更新后的处理逻辑，这里我们就不再过多介绍了，你可以参考我们在 08 课时 Webpack HMR 中的介绍。</p> <h3 data-v-64770dde>自动安装依赖</h3> <p data-v-64770dde>除了热替换，Parcel 还支持一个非常友好的功能：自动安装依赖。试想一下，你正在开发一个应用的过程中，突然需要使用某个第三方模块，那此时你就需要先停止正在运行的 Dev Server，然后再去安装这个模块，安装完成过后再重新启动 Dev Server。有了自动安装依赖的功能就不必如此麻烦了。</p> <p data-v-64770dde>我们回到 main.js 文件中，假设我们这里想要使用一下 jquery。虽然我们并没有安装这个模块，但是因为有了自动安装依赖功能，我们这里只管正常导入，正常使用就好了。具体效果如下：</p> <img src="/blog/webpack/Parcel1.gif" data-v-64770dde> <p data-v-64770dde>在文件保存过后，Parcel 会自动去安装刚刚导入的模块包，极大程度地避免手动操作。</p> <h3 data-v-64770dde>其他类型资源加载</h3> <p data-v-64770dde>除此以外，Parcel 同样支持加载其他类型的资源模块，而且相比于其他的打包器，在 Parcel 中加载其他类型的资源模块同样是零配置的。</p> <p data-v-64770dde>例如我们这里再来添加一个 style.css 的样式文件，并且在这个文件中添加一些简单的样式，具体如下：</p> <div class="content__code-Parcel5" data-v-64770dde><div class="language-js extra-class"><pre class="language-js"><code> <span class="token punctuation">.</span>
 ├── src
 │   ├── index<span class="token punctuation">.</span>html
 │   ├── logger<span class="token punctuation">.</span>js
 │   ├── main<span class="token punctuation">.</span>js
<span class="token operator">+</span>│   └── style<span class="token punctuation">.</span>css
 └── <span class="token keyword">package</span><span class="token punctuation">.</span>json

</code></pre></div></div> <p data-v-64770dde>然后回到 main.js 中通过 import 导入这个样式文件，具体如下：</p> <div class="content__code-Parcel6" data-v-64770dde><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./src/main.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> log <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./logger'</span>
<span class="token keyword">import</span> <span class="token string">'./style.css'</span>
<span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello parcel'</span><span class="token punctuation">)</span>

</code></pre></div></div> <p data-v-64770dde>保存过后，样式文件可以立即生效。效果如下：</p> <img src="/blog/webpack/Parcel2.png" data-v-64770dde> <p data-v-64770dde>你会发现，导入样式的操作，整个过程我们并没有停下来做额外的事情。</p> <p data-v-64770dde>总之，Parcel 希望给开发者的体验就是想做什么，只管去做，其他额外的事情就交给工具来处理。</p> <h3 data-v-64770dde>动态导入</h3> <p data-v-64770dde>另外，Parcel 同样支持直接使用动态导入，内部也会自动处理代码拆分，我们也一起来尝试一下。</p> <p data-v-64770dde>这里我们先将静态导入的 jQuery 注释掉。然后使用动态导入的方式导入 jQuery 模块。具体代码如下：</p> <div class="content__code-Parcel7" data-v-64770dde><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./src/main.js</span>
<span class="token comment">// import $ from 'jquery'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> log <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./logger'</span>
<span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello parcel'</span><span class="token punctuation">)</span>
<span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'jquery'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">$</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">$</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>body<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'&lt;h1&gt;Hello Parcel&lt;/h1&gt;'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div></div> <p data-v-64770dde>import 函数返回的就是一个 Promise 对象，在这个 Promise 对象 then 方法的回调中，我们就能够拿到导入的模块对象了，然后我们就可以把使用 jQuery 的代码移到这个回调函数中。</p> <p data-v-64770dde>保存过后，回到浏览器，找到开发人员工具的 Network 面板，这里就能够看到拆分出来的 jquery 所对应的 bundle 文件请求了。具体效果如下图：</p> <img src="/blog/webpack/Parcel3.png" data-v-64770dde> <p data-v-64770dde>那以上基本上就是 Parcel 最常用的一些特性了，使用上根本没有任何难度，从头到尾我们都只是执行了一个 Parcel 命令。</p> <h3 data-v-64770dde>生产模式打包</h3> <p data-v-64770dde>接下来我们来看，Parcel 如何以生产模式打包。生产模式打包，具体命令如下：</p> <p data-v-64770dde>$ npx parcel build src/index.html</p> <p data-v-64770dde>我们只需要执行 parcel build 然后跟上打包入口文件路径，就可以以生产模式运行打包了。</p> <p data-v-64770dde>这里补充一点，相同体量的项目打包，Parcel 的构建速度会比 Webpack 快很多。因为 Parcel 内部使用的是多进程同时工作，充分发挥了多核 CPU 的性能。</p> <p data-v-64770dde>P.S. Webpack 中也可以使用一个叫作 happypack 的插件实现这一点。</p> <p data-v-64770dde>那我们这里再来看一下输出的打包结果，具体结果如下：</p> <img src="/blog/webpack/Parcel4.png" data-v-64770dde> <p data-v-64770dde>此时，dist 目录下就都是本次打包的结果了。这里的输出文件也都会被压缩，而且样式代码也会被单独提取到单个文件中。</p> <p data-v-64770dde>那这就是 Parcel 的体验，整体体验下来就是一个感觉：舒服，因为它在使用上真的太简单了。</p> <h3 data-v-64770dde>总结</h3> <p data-v-64770dde>Parcel 是 2017 年发布的，出现的原因是因为当时的 Webpack 使用过于烦琐，文档也不是很清晰明了，所以 Parcel 一经推出就迅速被推上风口浪尖。其核心特点就是：</p> <ul data-v-64770dde><li data-v-64770dde>真正做到了完全零配置，对项目没有任何的侵入；</li> <li data-v-64770dde>自动安装依赖，开发过程更专注；</li> <li data-v-64770dde>构建速度更快，因为内部使用了多进程同时工作，能够充分发挥多核 CPU 的效率。</li></ul> <p data-v-64770dde>但是目前看来，如果你去观察开发者的实际使用情况，绝大多数项目的打包还是会选择 Webpack。个人认为原因有两点：</p> <ul data-v-64770dde><li data-v-64770dde>Webpack 生态更好，扩展更丰富，出现问题容易解决；</li> <li data-v-64770dde>随着这两年的发展，Webpack 越来越好用，开发者也越来越熟悉。</li></ul> <p data-v-64770dde>所以，Parcel 这样的工具对于开发者而言，我们去了解它，也就是为了保持对新鲜技术和工具的敏感度，从而更好地把握技术趋势和走向，仅此而已。</p></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/guide/webpack/webpack.html" class="prev">
        Webpack深入理解
      </a></span> <span class="next"><a href="/blog/guide/webpack/package.html">
        Package配置
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.5a07472d.js" defer></script><script src="/blog/assets/js/3.1a789601.js" defer></script><script src="/blog/assets/js/74.280f6a1f.js" defer></script><script src="/blog/assets/js/37.00d23916.js" defer></script>
  </body>
</html>

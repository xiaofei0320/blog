<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>小匪肥肥的游乐场</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/blog/img/logo1.jpg">
    <meta name="description" content="VuePress">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/blog/assets/css/0.styles.f51e841c.css" as="style"><link rel="preload" href="/blog/assets/js/app.5a07472d.js" as="script"><link rel="preload" href="/blog/assets/js/3.1a789601.js" as="script"><link rel="preload" href="/blog/assets/js/77.41135229.js" as="script"><link rel="preload" href="/blog/assets/js/40.cad1baab.js" as="script"><link rel="prefetch" href="/blog/assets/js/1.7edf47c2.js"><link rel="prefetch" href="/blog/assets/js/10.cf932b27.js"><link rel="prefetch" href="/blog/assets/js/11.428e9a7f.js"><link rel="prefetch" href="/blog/assets/js/12.d5fcbca6.js"><link rel="prefetch" href="/blog/assets/js/13.01f0776c.js"><link rel="prefetch" href="/blog/assets/js/14.116beb90.js"><link rel="prefetch" href="/blog/assets/js/15.1654677c.js"><link rel="prefetch" href="/blog/assets/js/16.a06c2f60.js"><link rel="prefetch" href="/blog/assets/js/17.a4d25310.js"><link rel="prefetch" href="/blog/assets/js/18.8e8204fc.js"><link rel="prefetch" href="/blog/assets/js/19.614c33de.js"><link rel="prefetch" href="/blog/assets/js/20.e6609b0d.js"><link rel="prefetch" href="/blog/assets/js/21.e3d25715.js"><link rel="prefetch" href="/blog/assets/js/22.d36a5209.js"><link rel="prefetch" href="/blog/assets/js/23.d656be96.js"><link rel="prefetch" href="/blog/assets/js/24.3c4e3f5f.js"><link rel="prefetch" href="/blog/assets/js/25.51dd6038.js"><link rel="prefetch" href="/blog/assets/js/26.650bd0cd.js"><link rel="prefetch" href="/blog/assets/js/27.bf7610d6.js"><link rel="prefetch" href="/blog/assets/js/28.65684b31.js"><link rel="prefetch" href="/blog/assets/js/29.82a0d372.js"><link rel="prefetch" href="/blog/assets/js/30.26246fa3.js"><link rel="prefetch" href="/blog/assets/js/31.1b14eed9.js"><link rel="prefetch" href="/blog/assets/js/32.08d7107b.js"><link rel="prefetch" href="/blog/assets/js/33.a6afb1b5.js"><link rel="prefetch" href="/blog/assets/js/34.1624be65.js"><link rel="prefetch" href="/blog/assets/js/35.f6fced37.js"><link rel="prefetch" href="/blog/assets/js/36.13cfd92d.js"><link rel="prefetch" href="/blog/assets/js/37.00d23916.js"><link rel="prefetch" href="/blog/assets/js/38.6c83d131.js"><link rel="prefetch" href="/blog/assets/js/39.12d06d9f.js"><link rel="prefetch" href="/blog/assets/js/4.33c8349b.js"><link rel="prefetch" href="/blog/assets/js/41.a3992672.js"><link rel="prefetch" href="/blog/assets/js/42.a64aac28.js"><link rel="prefetch" href="/blog/assets/js/43.de68db82.js"><link rel="prefetch" href="/blog/assets/js/44.83884ed2.js"><link rel="prefetch" href="/blog/assets/js/45.60f82d8a.js"><link rel="prefetch" href="/blog/assets/js/46.97923c1d.js"><link rel="prefetch" href="/blog/assets/js/47.7031b903.js"><link rel="prefetch" href="/blog/assets/js/48.c5d4a93a.js"><link rel="prefetch" href="/blog/assets/js/49.2789f4ad.js"><link rel="prefetch" href="/blog/assets/js/5.164e014d.js"><link rel="prefetch" href="/blog/assets/js/50.bdcac65e.js"><link rel="prefetch" href="/blog/assets/js/51.04cbcc3b.js"><link rel="prefetch" href="/blog/assets/js/52.7dfb48cd.js"><link rel="prefetch" href="/blog/assets/js/53.ea283efc.js"><link rel="prefetch" href="/blog/assets/js/54.7b0c0a07.js"><link rel="prefetch" href="/blog/assets/js/55.324243a6.js"><link rel="prefetch" href="/blog/assets/js/56.ba16ec33.js"><link rel="prefetch" href="/blog/assets/js/57.53c09e7c.js"><link rel="prefetch" href="/blog/assets/js/58.3b1341de.js"><link rel="prefetch" href="/blog/assets/js/59.8e1561c7.js"><link rel="prefetch" href="/blog/assets/js/6.f3e9d1b0.js"><link rel="prefetch" href="/blog/assets/js/60.5e1f4fbd.js"><link rel="prefetch" href="/blog/assets/js/61.c30006de.js"><link rel="prefetch" href="/blog/assets/js/62.c7f09eb3.js"><link rel="prefetch" href="/blog/assets/js/63.3cb1dcb3.js"><link rel="prefetch" href="/blog/assets/js/64.59cd9234.js"><link rel="prefetch" href="/blog/assets/js/65.bed8eb43.js"><link rel="prefetch" href="/blog/assets/js/66.e9b78c3b.js"><link rel="prefetch" href="/blog/assets/js/67.a5fbd73b.js"><link rel="prefetch" href="/blog/assets/js/68.1a675a1d.js"><link rel="prefetch" href="/blog/assets/js/69.f1e7cdf0.js"><link rel="prefetch" href="/blog/assets/js/7.ad3d8631.js"><link rel="prefetch" href="/blog/assets/js/70.3028d286.js"><link rel="prefetch" href="/blog/assets/js/71.2f6e220c.js"><link rel="prefetch" href="/blog/assets/js/72.69917eee.js"><link rel="prefetch" href="/blog/assets/js/73.293765b4.js"><link rel="prefetch" href="/blog/assets/js/74.280f6a1f.js"><link rel="prefetch" href="/blog/assets/js/75.020cbed2.js"><link rel="prefetch" href="/blog/assets/js/76.546b1fb3.js"><link rel="prefetch" href="/blog/assets/js/8.eee9cac4.js"><link rel="prefetch" href="/blog/assets/js/9.71ccef2b.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.f51e841c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/img/logo1.jpg" alt="小匪肥肥的游乐场" class="logo"> <span class="site-name can-hide">小匪肥肥的游乐场</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/guide/login/login.html" class="nav-link">
  指南
</a></div><div class="nav-item"><a href="/blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/blog/base/" class="nav-link">
  指南
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/guide/login/login.html" class="nav-link">
  指南
</a></div><div class="nav-item"><a href="/blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/blog/base/" class="nav-link">
  指南
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><a href="/blog/guide/es6/deep" class="sidebar-heading clickable"><span>Escript</span> <span class="arrow right"></span></a> <!----></section></li><li><a href="/blog/guide/ts/ts.html" class="sidebar-link">Tscript</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/guide/css/css" class="sidebar-heading clickable"><span>CSS世界</span> <span class="arrow right"></span></a> <!----></section></li><li><a href="/blog/guide/network/network.html" class="sidebar-link">网络协议</a></li><li><a href="/blog/guide/browser/browser.html" class="sidebar-link">浏览器工作原理</a></li><li><a href="/blog/guide/network/network.html" class="sidebar-link">前端性能优化</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/guide/webpack/webpack" class="sidebar-heading clickable open active"><span>前端工程化</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/guide/webpack/webpack.html" aria-current="page" class="active sidebar-link">Webpack深入理解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/guide/webpack/webpack.html#webpack背景" class="sidebar-link">webpack背景</a></li><li class="sidebar-sub-header"><a href="/blog/guide/webpack/webpack.html#webpack实现模块化打包" class="sidebar-link">webpack实现模块化打包</a></li><li class="sidebar-sub-header"><a href="/blog/guide/webpack/webpack.html#webpack实现loader资源加载" class="sidebar-link">webpack实现loader资源加载</a></li><li class="sidebar-sub-header"><a href="/blog/guide/webpack/webpack.html#webpack插件机制" class="sidebar-link">webpack插件机制</a></li><li class="sidebar-sub-header"><a href="/blog/guide/webpack/webpack.html#webpack运行机制与工作原理" class="sidebar-link">webpack运行机制与工作原理</a></li><li class="sidebar-sub-header"><a href="/blog/guide/webpack/webpack.html#dev-server使用" class="sidebar-link">Dev Server使用</a></li><li class="sidebar-sub-header"><a href="/blog/guide/webpack/webpack.html#webpack-sourcemap" class="sidebar-link">Webpack SourceMap</a></li><li class="sidebar-sub-header"><a href="/blog/guide/webpack/webpack.html#webpack热替换-hmr-机制" class="sidebar-link">Webpack热替换（HMR）机制</a></li><li class="sidebar-sub-header"><a href="/blog/guide/webpack/webpack.html#webpack特性" class="sidebar-link">Webpack特性</a></li><li class="sidebar-sub-header"><a href="/blog/guide/webpack/webpack.html#优化-webpack-的构建速度和打包结果" class="sidebar-link">优化 Webpack 的构建速度和打包结果</a></li><li class="sidebar-sub-header"><a href="/blog/guide/webpack/webpack.html#webpack配置" class="sidebar-link">webpack配置</a></li></ul></li><li><a href="/blog/guide/webpack/Rollup.html" class="sidebar-link">Rollup与Parcel</a></li><li><a href="/blog/guide/webpack/package.html" class="sidebar-link">Package配置</a></li><li><a href="/blog/guide/webpack/engineered.html" class="sidebar-link">前端工程化</a></li></ul></section></li><li><a href="/blog/guide/control/control.html" class="sidebar-link">前端监控</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/guide/algorithm/two-points" class="sidebar-heading clickable"><span>算法</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/guide/vue/communication" class="sidebar-heading clickable"><span>Vue模块</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/guide/react/sourceCode" class="sidebar-heading clickable"><span>React模块</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/guide/node/base" class="sidebar-heading clickable"><span>Node模块</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><div data-v-0246861c><div class="content__title-background" data-v-0246861c><h2 id="webpack背景"><a href="#webpack背景" class="header-anchor">#</a> webpack背景</h2></div> <p data-v-0246861c>经过最近几年的爆炸式发展，前端已经绝不再是简简单单的页面开发了，从早期只是配合后端“切图”，到现在已经能够独立驱动整个业务，这背后就需要引入更多的思想、框架和工具。比如：</p> <ul data-v-0246861c><li data-v-0246861c>现阶段的大型应用就要求前端必须要有独立的项目，独立的项目想要有足够的效率就必须进行工程化</li> <li data-v-0246861c>具有复杂数据状态的应用开发过程就必须要有合适的框架，采用数据驱动开发的方式增强可维护性</li> <li data-v-0246861c>复杂项目结构必须进行模块化管理，一来提高部分公共内容的可复用性，二来增强团队并行协作能力</li> <li data-v-0246861c>重复规律性的工作必须采用自动化工具实现，一来提高效率，二来避免人为出错</li></ul> <p data-v-0246861c>那说到 Webpack，就不得不提模块化开发，因为 Webpack 最早的出发点就是去实践前端方向的模块化开发。想要搞明白 Webpack，就先得搞明白它所要解决的问题，所以我这里先唠叨两句模块化的事情。</p> <p data-v-0246861c>模块化，可以说是当下最重要的前端开发范式之一。随着前端应用的日益复杂化，我们的项目已经逐渐膨胀到了不得不花大量时间去管理的程度。而模块化就是一种最主流的项目组织方式，它通过把复杂的代码按照功能划分为不同的模块单独维护，从而提高开发效率、降低维护成本。</p> <p data-v-0246861c>但是“模块化”，本身仅仅是一个思想或者说是一个理论，并不包含具体的实现。所以接下来，我们会一起学习如何使用 Webpack 在前端项目中实践模块化思想，以及目前行业中其他的一些优秀方案。</p> <p data-v-0246861c>Webpack 本质上仍然还是一个模块化打包工具，它通过“万物皆模块”这种设计思想，巧妙地实现了整个前端项目的模块化。在 Webpack 的理念中，前端项目中的任何资源都可以作为一个模块，任何模块都可以经过 Loader 机制的处理，最终再被打包到一起。</p> <p data-v-0246861c>Webpack 本身的架构中有两个很核心的特性，分别是 Loader 机制和插件机制。正是因为它的插件机制形成了非常繁荣的生态，所以造就了它现在“无所不能”的现状，所以让 Webpack 慢慢发展成了现在很多前端开发者眼中的构建系统。</p> <p data-v-0246861c>Webpack 最初的目标就是实现前端项目的模块化，也就是说它所解决的问题是如何在前端项目中更高效地管理和维护项目中的每一个资源。</p> <p data-v-0246861c>随着互联网的深入发展，前端技术标准发生了巨大的变化。早期的前端技术标准根本没有预料到前端行业会有今天这个规模，所以在设计上存在很多缺陷，导致我们现在去实现前端模块化时会遇到诸多问题。虽然说，如今绝大部分问题都已经被一些标准或者工具解决了，但在这个演进过程中依然有很多东西值得我们思考和学习，所以接下来我想先介绍一下前端方向落实模块化的几个代表阶段。</p> <h3 data-v-0246861c>文件划分方式</h3> <p data-v-0246861c>最早我们会基于文件划分的方式实现模块化，也就是 Web 最原始的模块系统。具体做法是将每个功能及其相关状态数据各自单独放到不同的 JS 文件中，约定每个文件是一个独立的模块。使用某个模块将这个模块引入到页面中，一个 script 标签对应一个模块，然后直接调用模块中的成员（变量 / 函数）。</p> <div class="content__code-background1" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code>└─ stage<span class="token operator">-</span><span class="token number">1</span>
    ├── module<span class="token operator">-</span>a<span class="token punctuation">.</span>js
    ├── module<span class="token operator">-</span>b<span class="token punctuation">.</span>js
    └── index<span class="token punctuation">.</span>html
</code></pre></div></div> <div class="content__code-background2" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// module-a.js </span>
<span class="token keyword">function</span> <span class="token function">foo</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'moduleA#foo'</span><span class="token punctuation">)</span> 
<span class="token punctuation">}</span>
</code></pre></div></div> <div class="content__code-background3" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// module-b.js </span>
<span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token string">'something'</span>
</code></pre></div></div> <div class="content__code-background4" data-v-0246861c><div class="language-html extra-class"><pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>UTF-8<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Stage 1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module-a.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module-b.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
    <span class="token comment">// 直接使用全局成员</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 可能存在命名冲突</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
    data <span class="token operator">=</span> <span class="token string">'other'</span> <span class="token comment">// 数据可能会被修改</span>
  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>

</code></pre></div></div> <p data-v-0246861c>缺点</p> <ul data-v-0246861c><li data-v-0246861c>模块直接在全局工作，大量模块成员污染全局作用域；</li> <li data-v-0246861c>没有私有空间，所有模块内的成员都可以在模块外部被访问或者修改；</li> <li data-v-0246861c>一旦模块增多，容易产生命名冲突；</li> <li data-v-0246861c>无法管理模块与模块之间的依赖关系；</li> <li data-v-0246861c>在维护的过程中也很难分辨每个成员所属的模块。</li></ul> <h3 data-v-0246861c>命名空间方式</h3> <p data-v-0246861c>后来，我们约定每个模块只暴露一个全局对象，所有模块成员都挂载到这个全局对象中，具体做法是在第一阶段的基础上，通过将每个模块“包裹”为一个全局对象的形式实现，这种方式就好像是为模块内的成员添加了“命名空间”，所以我们又称之为命名空间方式。</p> <div class="content__code-background5" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// module-a.js</span>
window<span class="token punctuation">.</span>moduleA <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">method1</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'moduleA#method1'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <div class="content__code-background6" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// module-b.js</span>
window<span class="token punctuation">.</span>moduleB <span class="token operator">=</span> <span class="token punctuation">{</span>
  data<span class="token operator">:</span> <span class="token string">'something'</span>
  <span class="token function-variable function">method1</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'moduleB#method1'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <div class="content__code-background7" data-v-0246861c><div class="language-html extra-class"><pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>UTF-8<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Stage 2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module-a.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module-b.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
    moduleA<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    moduleB<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 模块成员依然可以被修改</span>
    moduleA<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token string">'foo'</span>
  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>

</code></pre></div></div> <p data-v-0246861c>这种命名空间的方式只是解决了命名冲突的问题，但是其它问题依旧存在。</p> <h3 data-v-0246861c>IIFE</h3> <p data-v-0246861c>使用立即执行函数表达式（IIFE，Immediately-Invoked Function Expression）为模块提供私有空间。具体做法是将每个模块成员都放在一个立即执行函数所形成的私有作用域中，对于需要暴露给外部的成员，通过挂到全局对象上的方式实现。</p> <div class="content__code-background8" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// module-a.js</span>
<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'module-a'</span>

  <span class="token keyword">function</span> <span class="token function">method1</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">'#method1'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  window<span class="token punctuation">.</span>moduleA <span class="token operator">=</span> <span class="token punctuation">{</span>
    method1<span class="token operator">:</span> method1
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

</code></pre></div></div> <div class="content__code-background9" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// module-b.js</span>
<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'module-b'</span>

  <span class="token keyword">function</span> <span class="token function">method1</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">'#method1'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  window<span class="token punctuation">.</span>moduleB <span class="token operator">=</span> <span class="token punctuation">{</span>
    method1<span class="token operator">:</span> method1
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div></div> <p data-v-0246861c>这种方式带来了私有成员的概念，私有成员只能在模块成员内通过闭包的形式访问，这就解决了前面所提到的全局作用域污染和命名冲突的问题。</p> <h3 data-v-0246861c>IIFE 依赖参数</h3> <p data-v-0246861c>在 IIFE 的基础之上，我们还可以利用 IIFE 参数作为依赖声明使用，这使得每一个模块之间的依赖关系变得更加明显。</p> <div class="content__code-background10" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// module-a.js</span>
<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">$</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 通过参数明显表明这个模块的依赖</span>
  <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'module-a'</span>

  <span class="token keyword">function</span> <span class="token function">method1</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">'#method1'</span><span class="token punctuation">)</span>
    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'body'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">animate</span><span class="token punctuation">(</span><span class="token punctuation">{</span> margin<span class="token operator">:</span> <span class="token string">'200px'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  window<span class="token punctuation">.</span>moduleA <span class="token operator">=</span> <span class="token punctuation">{</span>
    method1<span class="token operator">:</span> method1
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>jQuery<span class="token punctuation">)</span>

</code></pre></div></div> <h3 data-v-0246861c>模块加载的问题</h3> <p data-v-0246861c>以上 4 个阶段是早期的开发者在没有工具和规范的情况下对模块化的落地方式，这些方式确实解决了很多在前端领域实现模块化的问题，但是仍然存在一些没有解决的问题。</p> <div class="content__code-background11" data-v-0246861c><div class="language-html extra-class"><pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Evolution<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>https://unpkg.com/jquery<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module-a.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module-b.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
    moduleA<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    moduleB<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>

</code></pre></div></div> <p data-v-0246861c>最明显的问题就是：模块的加载。在这几种方式中虽然都解决了模块代码的组织问题，但模块加载的问题却被忽略了，我们都是通过 script 标签的方式直接在页面中引入的这些模块，这意味着模块的加载并不受代码的控制，时间久了维护起来会十分麻烦。试想一下，如果你的代码需要用到某个模块，如果 HTML 中忘记引入这个模块，又或是代码中移除了某个模块的使用，而 HTML 还忘记删除该模块的引用，都会引起很多问题和不必要的麻烦。</p> <p data-v-0246861c>更为理想的方式应该是在页面中引入一个 JS 入口文件，其余用到的模块可以通过代码控制，按需加载进来。</p> <h3 data-v-0246861c>模块化规范的出现</h3> <p data-v-0246861c>除了模块加载的问题以外，目前这几种通过约定实现模块化的方式，不同的开发者在实施的过程中会出现一些细微的差别，因此，为了统一不同开发者、不同项目之间的差异，我们就需要制定一个行业标准去规范模块化的实现方式。</p> <p data-v-0246861c>再接合我们刚刚提到的模块加载的问题，我们现在的需求就是两点：</p> <ul data-v-0246861c><li data-v-0246861c>一个统一的模块化标准规范</li> <li data-v-0246861c>一个可以自动加载模块的基础库</li></ul> <p data-v-0246861c>提到模块化规范，你可能会想到 CommonJS 规范，它是 Node.js 中所遵循的模块规范，该规范约定，一个文件就是一个模块，每个模块都有单独的作用域，通过 module.exports 导出成员，再通过 require 函数载入模块。现如今的前端开发者应该对其有所了解，但是如果我们想要在浏览器端直接使用这个规范，那就会出现一些新的问题。</p> <p data-v-0246861c>如果你对 Node.js 的模块加载机制有所了解，那么你应该知道，CommonJS 约定的是以同步的方式加载模块，因为 Node.js 执行机制是在启动时加载模块，执行过程中只是使用模块，所以这种方式不会有问题。但是如果要在浏览器端使用同步的加载模式，就会引起大量的同步模式请求，导致应用运行效率低下。</p> <p data-v-0246861c>所以在早期制定前端模块化标准时，并没有直接选择 CommonJS 规范，而是专门为浏览器端重新设计了一个规范，叫做 AMD （ Asynchronous Module Definition） 规范，即异步模块定义规范。同期还推出了一个非常出名的库，叫做 Require.js，它除了实现了 AMD 模块化规范，本身也是一个非常强大的模块加载器。</p> <p data-v-0246861c>在 AMD 规范中约定每个模块通过 define() 函数定义，这个函数默认可以接收两个参数，第一个参数是一个数组，用于声明此模块的依赖项；第二个参数是一个函数，参数与前面的依赖项一一对应，每一项分别对应依赖项模块的导出成员，这个函数的作用就是为当前模块提供一个私有空间。如果在当前模块中需要向外部导出成员，可以通过 return 的方式实现。</p> <img src="/blog/webpack/webpack1.png" data-v-0246861c> <p data-v-0246861c>除此之外，Require.js 还提供了一个 require() 函数用于自动加载模块，用法与 define() 函数类似，区别在于 require() 只能用来载入模块，而 define() 还可以定义模块。当 Require.js 需要加载一个模块时，内部就会自动创建 script 标签去请求并执行相应模块的代码。</p> <img src="/blog/webpack/webpack2.png" data-v-0246861c> <p data-v-0246861c>目前绝大多数第三方库都支持 AMD 规范，但是它使用起来相对复杂，而且当项目中模块划分过于细致时，就会出现同一个页面对 js 文件的请求次数过多的情况，从而导致效率降低。在当时的环境背景下，AMD 规范为前端模块化提供了一个标准，但这只是一种妥协的实现方式，并不能成为最终的解决方案。</p> <p data-v-0246861c>同期出现的规范还有淘宝的 Sea.js，只不过它实现的是另外一个标准，叫作 CMD，这个标准类似于 CommonJS，在使用上基本和 Require.js 相同，可以算上是重复的轮子。但随着前端技术的发展，Sea.js 后来也被 Require.js 兼容了。如果你感兴趣可以课后了解一下 Seajs官网。</p> <img src="/blog/webpack/webpack3.png" data-v-0246861c> <h3 data-v-0246861c>模块化的标准规范</h3> <p data-v-0246861c>尽管上面介绍的这些方式和标准都已经实现了模块化，但是都仍然存在一些让开发者难以接受的问题。</p> <p data-v-0246861c>随着技术的发展，JavaScript 的标准逐渐走向完善，可以说，如今的前端模块化已经发展得非常成熟了，而且对前端模块化规范的最佳实践方式也基本实现了统一。</p> <ul data-v-0246861c><li data-v-0246861c>在 Node.js 环境中，我们遵循 CommonJS 规范来组织模块</li> <li data-v-0246861c>在浏览器环境中，我们遵循 ES Modules 规范</li></ul> <img src="/blog/webpack/webpack4.png" data-v-0246861c> <p data-v-0246861c>而且在最新的 Node.js 提案中表示，Node 环境也会逐渐趋向于 ES Modules 规范，也就是说作为现阶段的前端开发者，应该重点掌握 ES Modules 规范。</p> <p data-v-0246861c>因为 CommonJS 属于内置模块系统，所以在 Node.js 环境中使用时不存在环境支持问题，只需要直接遵循标准使用 require 和 module 即可。</p> <p data-v-0246861c>但是对于 ES Modules 规范来说，情况会相对复杂一些。我们知道 ES Modules 是 ECMAScript 2015（ES6）中才定义的模块系统，也就是说它是近几年才制定的标准，所以肯定会存在环境兼容的问题。在这个标准刚推出的时候，几乎所有主流的浏览器都不支持。但是随着 Webpack 等一系列打包工具的流行，这一规范才开始逐渐被普及。</p> <p data-v-0246861c>经过 5 年的迭代， ES Modules 已发展成为现今最主流的前端模块化标准。相比于 AMD 这种社区提出的开发规范，ES Modules 是在语言层面实现的模块化，因此它的标准更为完善也更为合理。而且目前绝大多数浏览器都已经开始能够原生支持 ES Modules 这个特性了，所以说在未来几年，它还会有更好的发展，短期内应该不会有新的轮子出现了。</p> <p data-v-0246861c>综上所述，如何在不同的环境中去更好的使用 ES Modules 将是你重点考虑的问题。</p> <h3 data-v-0246861c>ES Modules 特性</h3> <p data-v-0246861c>那对于 ES Modules 的学习，可以从两个维度入手。首先，你需要了解它作为一个规范或者说标准，到底约定了哪些特性和语法；其次，你需要学习如何通过一些工具和方案去解决运行环境兼容带来的问题。</p> <img src="/blog/webpack/webpack5.png" data-v-0246861c> <h3 data-v-0246861c>模块打包工具的出现</h3> <p data-v-0246861c>模块化可以帮助我们更好地解决复杂应用开发过程中的代码组织问题，但是随着模块化思想的引入，我们的前端应用又会产生了一些新的问题，比如：</p> <ul data-v-0246861c><li data-v-0246861c>首先，我们所使用的 ES Modules 模块系统本身就存在环境兼容问题。尽管现如今主流浏览器的最新版本都支持这一特性，但是目前还无法保证用户的浏览器使用情况。所以我们还需要解决兼容问题。</li> <li data-v-0246861c>其次，模块化的方式划分出来的模块文件过多，而前端应用又运行在浏览器中，每一个文件都需要单独从服务器请求回来。零散的模块文件必然会导致浏览器的频繁发送网络请求，影响应用的工作效率。</li> <li data-v-0246861c>最后，谈一下在实现 JS 模块化的基础上的发散。随着应用日益复杂，在前端应用开发过程中不仅仅只有 JavaScript 代码需要模块化，HTML 和 CSS 这些资源文件也会面临需要被模块化的问题。而且从宏观角度来看，这些文件也都应该看作前端应用中的一个模块，只不过这些模块的种类和用途跟 JavaScript 不同</li></ul> <p data-v-0246861c>对于开发过程而言，模块化肯定是必要的，所以我们需要在前面所说的模块化实现的基础之上引入更好的方案或者工具，去解决上面提出的 3 个问题，让我们的应用在开发阶段继续享受模块化带来的优势，又不必担心模块化对生产环境所产生的影响。</p> <p data-v-0246861c>接下来我们先对这个更好的方案或者工具提出一些设想：</p> <ul data-v-0246861c><li data-v-0246861c>
      第一，它需要具备编译代码的能力，也就是将我们开发阶段编写的那些包含新特性的代码转换为能够兼容大多数环境的代码，解决我们所面临的环境兼容问题
      <img src="/blog/webpack/webpack6.png" data-v-0246861c></li> <li data-v-0246861c>
      第二，能够将散落的模块再打包到一起，这样就解决了浏览器频繁请求模块文件的问题。这里需要注意，只是在开发阶段才需要模块化的文件划分，因为它能够帮我们更好地组织代码，到了实际运行阶段，这种划分就没有必要了
      <img src="/blog/webpack/webpack7.png" data-v-0246861c></li> <li data-v-0246861c>
      第三，它需要支持不同种类的前端模块类型，也就是说可以将开发过程中涉及的样式、图片、字体等所有资源文件都作为模块使用，这样我们就拥有了一个统一的模块化方案，所有资源文件的加载都可以通过代码控制，与业务代码统一维护，更为合理。
      <img src="/blog/webpack/webpack8.png" data-v-0246861c></li></ul> <p data-v-0246861c>针对上面第一、第二个设想，我们可以借助 Gulp 之类的构建系统配合一些编译工具和插件去实现，但是对于第三个可以对不同种类资源进行模块化的设想，就很难通过这种方式去解决了，所以就有了我们接下来要介绍的主题：前端模块打包工具。</p> <div class="content__title-module" data-v-0246861c><h2 id="webpack实现模块化打包"><a href="#webpack实现模块化打包" class="header-anchor">#</a> webpack实现模块化打包</h2></div> <p data-v-0246861c>模块化打包方案或工具的设想或者说是诉求</p> <ul data-v-0246861c><li data-v-0246861c>能够将散落的模块打包到一起；</li> <li data-v-0246861c>能够编译代码中的新特性；</li> <li data-v-0246861c>能够支持不同种类的前端资源模块。</li></ul> <p data-v-0246861c>目前，前端领域有一些工具能够很好的满足以上这 3 个需求，其中最为主流的就是 Webpack、Parcel 和 Rollup，我们以 Webpack 为例：</p> <ul data-v-0246861c><li data-v-0246861c>Webpack 作为一个模块打包工具，本身就可以解决模块化代码打包的问题，将零散的 JavaScript 代码打包到一个 JS 文件中</li> <li data-v-0246861c>对于有环境兼容问题的代码，Webpack 可以在打包过程中通过 Loader 机制对其实现编译转换，然后再进行打包。</li> <li data-v-0246861c>对于不同类型的前端模块类型，Webpack 支持在 JavaScript 中以模块化的方式载入任意类型的资源文件，例如，我们可以通过 Webpack 实现在 JavaScript 中加载 CSS 文件，被加载的 CSS 文件将会通过 style 标签的方式工作</li></ul> <p data-v-0246861c>除此之外，Webpack 还具备代码拆分的能力，它能够将应用中所有的模块按照我们的需要分块打包。这样一来，就不用担心全部代码打包到一起，产生单个文件过大，导致加载慢的问题。我们可以把应用初次加载所必需的模块打包到一起，其他的模块再单独打包，等到应用工作过程中实际需要用到某个模块，再异步加载该模块，实现增量加载，或者叫作渐进式加载，非常适合现代化的大型 Web 应用。</p> <p data-v-0246861c>当然，除了 Webpack，其他的打包工具也都类似，总之，所有的打包工具都是以实现模块化为目标，让我们可以在开发阶段更好的享受模块化带来的优势，同时又不必担心模块化在生产环境中产生新的问题。</p> <h3 data-v-0246861c>Webpack 快速上手</h3> <p data-v-0246861c>Webpack 作为目前最主流的前端模块打包器，提供了一整套前端项目模块化方案，而不仅仅局限于对 JavaScript 的模块化。通过 Webpack，我们可以轻松的对前端项目开发过程中涉及的所有资源进行模块化。</p> <p data-v-0246861c>因为 Webpack 的设计思想比较先进，起初的使用过程比较烦琐，再加上文档也晦涩难懂，所以在最开始的时候，Webpack 对开发者并不友好，但是随着版本的迭代，官方文档的不断更新，目前 Webpack 对开发者已经非常友好了。此外，随着 React 和 Vue.js 这类框架的普及，Webpack 也随之受到了越来越多的关注，现阶段可以覆盖绝大多数现代 Web 应用的开发过程。</p> <p data-v-0246861c>接下来我将通过一个案例，带你快速了解 Webpack 的基本使用，具体操作如下所示：</p> <div class="content__code-module1" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code>└─ <span class="token number">02</span><span class="token operator">-</span>configuation
   ├── src
   │   ├── heading<span class="token punctuation">.</span>js
   │   └── index<span class="token punctuation">.</span>js
   └── index<span class="token punctuation">.</span>html

</code></pre></div></div> <div class="content__code-module2" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./src/heading.js</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> element <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'h2'</span><span class="token punctuation">)</span>
  element<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token string">'Hello webpack'</span>
  element<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Hello webpack'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> element
<span class="token punctuation">}</span>

</code></pre></div></div> <div class="content__code-module3" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./src/index.js</span>
<span class="token keyword">import</span> createHeading <span class="token keyword">from</span> <span class="token string">'./heading.js'</span>
<span class="token keyword">const</span> heading <span class="token operator">=</span> <span class="token function">createHeading</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>heading<span class="token punctuation">)</span>

</code></pre></div></div> <div class="content__code-module4" data-v-0246861c><div class="language-html extra-class"><pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>en<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>UTF-8<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Webpack - 快速上手<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module<span class="token punctuation">&quot;</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>src/index.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>


</code></pre></div></div> <p data-v-0246861c>P.S. type=&quot;module&quot; 这种用法是 ES Modules 中提出的标准，用来区分加载的是一个普通 JS 脚本还是一个模块。</p> <p data-v-0246861c>在上面这个案例中，我们创建了两个 JS 文件，其中 heading.js 中以 ES Modules 的方式导出了一个创建元素的函数，然后在 index.js 中导入 heading.js 并使用了这个模块，最后在 html 文件中通过 script 标签，以模块化的方式引入了 index.js，</p> <p data-v-0246861c>按照 ES Modules 的标准，这里的 index.html 可以直接在浏览器中正常工作，但是对于不支持 ES Modules 标准的浏览器，直接使用就会出现错误，所以我们需要使用 Webpack 这样的工具，将我们这里按照模块化方式拆分的 JS 代码再次打包到一起。</p> <p data-v-0246861c>接下来我们就尝试引入 Webpack 去处理上述案例中的 JS 模块打包。由于 Webpack 是一个 npm 工具模块，所以我们先初始化一个 package.json 文件，用来管理 npm 依赖版本，完成之后，再来安装 Webpack 的核心模块以及它的 CLI 模块，具体操作如下：</p> <div class="content__code-module8" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code>$ npm init <span class="token operator">--</span>yes
$ npm i webpack webpack<span class="token operator">-</span>cli <span class="token operator">--</span>save<span class="token operator">-</span>dev

</code></pre></div></div> <p data-v-0246861c>P.S. webpack 是 Webpack 的核心模块，webpack-cli 是 Webpack 的 CLI 程序，用来在命令行中调用 Webpack。</p> <p data-v-0246861c>安装完成之后，webpack-cli 所提供的 CLI 程序就会出现在 node_modules/.bin 目录当中，我们可以通过 npx 快速找到 CLI 并运行它，具体操作如下：</p> <div class="content__code-module9" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code>$ npx webpack <span class="token operator">--</span>version
v4<span class="token punctuation">.</span><span class="token number">42.1</span>

</code></pre></div></div> <p data-v-0246861c>P.S. npx 是 npm 5.2 以后新增的一个命令，可以用来更方便的执行远程模块或者项目 node_modules 中的 CLI 程序。</p> <p data-v-0246861c>这里我们使用的 Webpack 版本是 v4.42.1，有了 Webpack 后，就可以直接运行 webpack 命令来打包 JS 模块代码，具体操作如下：</p> <div class="content__code-module10" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code>$ npx webpack

</code></pre></div></div> <p data-v-0246861c>这个命令在执行的过程中，Webpack 会自动从 src/index.js 文件开始打包，然后根据代码中的模块导入操作，自动将所有用到的模块代码打包到一起。</p> <p data-v-0246861c>完成之后，控制台会提示：顺着 index.js 有两个 JS 文件被打包到了一起。与之对应的就是项目的根目录下多出了一个 dist 目录，我们的打包结果就存放在这个目录下的 main.js 文件中，具体操作如下图所示：</p> <img src="/blog/webpack/webpack9.png" data-v-0246861c> <p data-v-0246861c>这里我们回到 index.html 中修改引入文件的路径，由于打包后的代码就不会再有 import 和 export 了，所以我们可以删除 type=&quot;module&quot;。再次回到浏览器中，查看这个页面，这时我们的代码仍然可以正常工作，index.html 的代码如下所示：</p> <div class="content__code-module11" data-v-0246861c><div class="language-html extra-class"><pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>en<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>UTF-8<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Webpack - 快速上手<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>dist/main.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>

</code></pre></div></div> <p data-v-0246861c>我们也可以将 Webpack 命令定义到 npm scripts 中，这样每次使用起来会更加方便，具体如下：</p> <div class="content__code-module12" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  <span class="token string">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;01-getting-started&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;version&quot;</span><span class="token operator">:</span> <span class="token string">&quot;0.1.0&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;main&quot;</span><span class="token operator">:</span> <span class="token string">&quot;n/a&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;author&quot;</span><span class="token operator">:</span> <span class="token string">&quot;zce &lt;w@zce.me&gt; (https://zce.me)&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;license&quot;</span><span class="token operator">:</span> <span class="token string">&quot;MIT&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;scripts&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string">&quot;build&quot;</span><span class="token operator">:</span> <span class="token string">&quot;webpack&quot;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token string">&quot;devDependencies&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string">&quot;webpack&quot;</span><span class="token operator">:</span> <span class="token string">&quot;^4.42.1&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;webpack-cli&quot;</span><span class="token operator">:</span> <span class="token string">&quot;^3.3.11&quot;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>对于 Webpack 最基本的使用，总结下来就是：先安装 webpack 相关的 npm 包，然后使用 webpack-cli 所提供的命令行工具进行打包。</p> <h3 data-v-0246861c>配置 Webpack 的打包过程</h3> <p data-v-0246861c>Webpack 4 以后的版本支持零配置的方式直接启动打包，整个过程会按照约定将 src/index.js 作为打包入口，最终打包的结果会存放到 dist/main.js 中。</p> <p data-v-0246861c>但很多时候我们需要自定义这些路径约定，例如，在下面这个案例中，我需要它的打包入口是 src/main.js，那此时我们通过配置文件的方式修改 Webpack 的默认配置，在项目的根目录下添加一个 webpack.config.js，具体结构如下：</p> <div class="content__code-module5" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code> └─ <span class="token number">02</span><span class="token operator">-</span>configuation
    ├── src
    │ ├── heading<span class="token punctuation">.</span>js
    │ └── main<span class="token punctuation">.</span>js
    ├── index<span class="token punctuation">.</span>html
    ├── <span class="token keyword">package</span><span class="token punctuation">.</span>json
<span class="token operator">+</span>   └── webpack<span class="token punctuation">.</span>config<span class="token punctuation">.</span>js ···················· Webpack 配置文件

</code></pre></div></div> <p data-v-0246861c>webpack.config.js 是一个运行在 Node.js 环境中的 JS 文件，也就是说我们需要按照 CommonJS 的方式编写代码，这个文件可以导出一个对象，我们可以通过所导出对象的属性完成相应的配置选项。</p> <p data-v-0246861c>这里先尝试添加一个 entry 属性，这个属性的作用就是指定 Webpack 打包的入口文件路径。我们将其设置为 src/main.js，具体代码如下所示：</p> <div class="content__code-module6" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span> <span class="token string">'./src/main.js'</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>配置完成之后，回到命令行终端重新运行打包命令，此时 Webpack 就会从 src/main.js 文件开始打包。</p> <p data-v-0246861c>除了 entry 的配置以外，我们还可以通过 output 属性设置输出文件的位置。output 属性的值必须是一个对象，通过这个对象的 filename 指定输出文件的文件名称，path 指定输出的目录，具体代码如下所示：</p> <div class="content__code-module7" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
<span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span> <span class="token string">'./src/main.js'</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    filename<span class="token operator">:</span> <span class="token string">'bundle.js'</span><span class="token punctuation">,</span>
    path<span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'output'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>TIPS：webpack.config.js 是运行在 Node.js 环境中的代码，所以直接可以使用 path 之类的 Node.js 内置模块。</p> <p data-v-0246861c>由于 Webpack 支持的配置有很多，篇幅的关系，这里我们就不一一介绍了，详细的文档你可以在 Webpack 的官网中找到：https://webpack.js.org/configuration/#options</p> <h3 data-v-0246861c>Webpack 工作模式</h3> <p data-v-0246861c>Webpack 4 新增了一个工作模式的用法，这种用法大大简化了 Webpack 配置的复杂程度。你可以把它理解为针对不同环境的几组预设配置：</p> <ul data-v-0246861c><li data-v-0246861c>production 模式下，启动内置优化插件，自动优化打包结果，打包速度偏慢；</li> <li data-v-0246861c>development 模式下，自动优化打包速度，添加一些调试过程中的辅助插件；</li> <li data-v-0246861c>none 模式下，运行最原始的打包，不做任何额外处理。</li></ul> <p data-v-0246861c>针对工作模式的选项，如果你没有配置一个明确的值，打包过程中命令行终端会打印一个对应的配置警告。在这种情况下 Webpack 将默认使用 production 模式去工作。</p> <p data-v-0246861c>production 模式下 Webpack 内部会自动启动一些优化插件，例如，自动压缩打包后的代码。这对实际生产环境是非常友好的，但是打包的结果就无法阅读了。</p> <p data-v-0246861c>修改 Webpack 工作模式的方式有两种：</p> <ul data-v-0246861c><li data-v-0246861c>通过 CLI --mode 参数传入；</li> <li data-v-0246861c>通过配置文件设置 mode 属性。</li></ul> <p data-v-0246861c>上述三种 Webpack 工作模式的详细差异我们不再赘述了，你可以在官方文档中查看：https://webpack.js.org/configuration/mode/</p> <h3 data-v-0246861c>打包结果运行原理</h3> <p data-v-0246861c>最后，我们来一起学习 Webpack 打包后生成的 bundle.js 文件，深入了解 Webpack 是如何把这些模块合并到一起，而且还能正常工作的。</p> <p data-v-0246861c>为了更好的理解打包后的代码，我们先将 Webpack 工作模式设置为 none，这样 Webpack 就会按照最原始的状态进行打包，所得到的结果更容易理解和阅读。</p> <p data-v-0246861c>按照 none 模式打包完成后，我们打开最终生成的 bundle.js 文件，如下图所示：</p> <img src="/blog/webpack/webpack10.png" data-v-0246861c> <p data-v-0246861c>我们可以先把代码全部折叠起来，以便于了解整体的结构，如下图所示：</p> <img src="/blog/webpack/webpack11.png" data-v-0246861c> <p data-v-0246861c>整体生成的代码其实就是一个立即执行函数，这个函数是 Webpack 工作入口（webpackBootstrap），它接收一个 modules 参数，调用时传入了一个数组。</p> <p data-v-0246861c>展开这个数组，里面的元素均是参数列表相同的函数。这里的函数对应的就是我们源代码中的模块，也就是说每个模块最终被包裹到了这样一个函数中，从而实现模块私有作用域，如下图所示：</p> <img src="/blog/webpack/webpack12.png" data-v-0246861c> <p data-v-0246861c>我们再来展开 Webpack 工作入口函数，如下图所示：</p> <img src="/blog/webpack/webpack13.png" data-v-0246861c> <p data-v-0246861c>这个函数内部并不复杂，而且注释也很清晰，最开始定义了一个 installedModules 对象用于存放或者缓存加载过的模块。紧接着定义了一个 require 函数，顾名思义，这个函数是用来加载模块的。再往后就是在 require 函数上挂载了一些其他的数据和工具函数，这些暂时不用关心。</p> <p data-v-0246861c>这个函数执行到最后调用了 require 函数，传入的模块 id 为 0，开始加载模块。模块 id 实际上就是模块数组的元素下标，也就是说这里开始加载源代码中所谓的入口模块，如下图所示：</p> <img src="/blog/webpack/webpack14.png" data-v-0246861c> <p data-v-0246861c>为了更好的理解 bundle.js 的执行过程，你可以把它运行到浏览器中，然后通过 Chrome 的 Devtools 单步调试一下。</p> <div class="content__title-loader" data-v-0246861c><h2 id="webpack实现loader资源加载"><a href="#webpack实现loader资源加载" class="header-anchor">#</a> webpack实现loader资源加载</h2></div> <p data-v-0246861c>Webpack 想要实现的是整个前端项目的模块化，项目中的各种资源（包括 CSS 文件、图片等）都应该属于需要被管理的模块。换句话说， Webpack 不仅是 JavaScript 模块打包工具，还是整个前端项目（前端工程）的模块打包工具。也就是说，我们可以通过 Webpack 去管理前端项目中任意类型的资源文件。</p> <p data-v-0246861c>因为 Webpack 实现不同种类资源模块加载的核心就是 Loader，所以今天我来和你聊聊 Webpack 的 Loader 机制。</p> <h3 data-v-0246861c>如何加载资源模块</h3> <p data-v-0246861c>首先，我们尝试通过 Webpack 打包项目中的一个 CSS 文件，由此开始探索 Webpack 是如何加载资源模块的？</p> <p data-v-0246861c>在下面这个案例中，我们在项目的 src 目录下添加一个普通的样式文件 main.css，具体结构和样式代码如下所示：</p> <div class="content__code-loader1" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code> └─ <span class="token number">03</span><span class="token operator">-</span>webpack<span class="token operator">-</span>loader ························ sample root dir
    ├── src ·································· source dir
<span class="token operator">+</span>   │   └── main<span class="token punctuation">.</span>css ························· main styles
    ├── <span class="token keyword">package</span><span class="token punctuation">.</span>json ························· <span class="token keyword">package</span> file
    └── webpack<span class="token punctuation">.</span>config<span class="token punctuation">.</span>js ···················· webpack config file

</code></pre></div></div> <div class="content__code-loader2" data-v-0246861c><div class="language-css extra-class"><pre class="language-css"><code><span class="token comment">/* ./src/main.css */</span>
<span class="token selector">body</span> <span class="token punctuation">{</span>
  <span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span>
  <span class="token property">padding</span><span class="token punctuation">:</span> 0 20px<span class="token punctuation">;</span>
  <span class="token property">max-width</span><span class="token punctuation">:</span> 800px<span class="token punctuation">;</span>
  <span class="token property">background</span><span class="token punctuation">:</span> #f4f8fb<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>然后将 Webpack 配置中的入口文件路径指定为 main.css 的文件路径，让 Webpack 直接打包 CSS 资源文件，具体配置如下所示：</p> <div class="content__code-loader3" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// 样式文件路径</span>
  entry<span class="token operator">:</span> <span class="token string">'./src/main.css'</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    filename<span class="token operator">:</span> <span class="token string">'bundle.js'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>你可能会好奇：Webpack 的打包入口不是应该是一个 JS 文件吗？为什么这里配置成了一个 CSS 文件呢？</p> <p data-v-0246861c>其实 Webpack 并没有强制要求我们必须以 JS 文件作为打包入口，只是在绝大多数情况下，我们会用 JS 文件作为打包入口，因为 JS 文件才是程序的逻辑入口，以 JS 文件作为入口相对更合理。</p> <p data-v-0246861c>那么，我们这里为什么要使用 CSS 文件作为入口呢？其实就是单纯地为了尝试使用 Webpack 直接去打包 CSS 文件，关于同时打包 JS 和 CSS 的操作，待会儿会详细介绍。</p> <p data-v-0246861c>配置完成过后回到命令行终端再次运行 Webpack 打包命令，此时你会发现命令行报出了一个模块解析错误，如下所示：</p> <img src="/blog/webpack/webpack15.png" data-v-0246861c> <p data-v-0246861c>错误信息大体的意思是说，在解析模块过程中遇到了非法字符，而且错误出现的位置就是在我们的 CSS 文件中。</p> <p data-v-0246861c>出现这个错误的原因是因为 Webpack 内部默认只能够处理 JS 模块代码，也就是说在打包过程中，它默认把所有遇到的文件都当作 JavaScript 代码进行解析，但是此处我们让 Webpack 处理的是 CSS 代码，而 CSS 代码是不符合 JavaScript 语法的，所以自然会报出模块解析错误。</p> <p data-v-0246861c>为了佐证 Webpack 默认只能够按照 JavaScript 语法解析模块，你可以尝试将 main.css 文件中的代码修改为一段 JavaScript 代码，然后重新运行 Webpack 打包来看一下结果。具体操作如下：</p> <div class="content__code-loader4" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/* ./src/main.css */</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'This is a style sheet.'</span><span class="token punctuation">)</span> 
<span class="token comment">/* 只是为了证明 Webpack 默认按照 JS 语法解析模块 */</span>


</code></pre></div></div> <img src="/blog/webpack/webpack16.png" data-v-0246861c> <p data-v-0246861c>注意：这里在 CSS 中编写 JS 代码只是为了证实我们的观点，并不是真的要这样使用。</p> <p data-v-0246861c>我们再次回到前面提到的错误描述中，如下所示：</p> <img src="/blog/webpack/webpack17.png" data-v-0246861c> <p data-v-0246861c>这里有一个非常重要的提示：You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. （我们需要用适当的加载器来处理这种文件类型，而当前并没有配置一个可以用来处理此文件的加载器）。</p> <p data-v-0246861c>根据这个错误说明，我们发现 Webpack 是用 Loader（加载器）来处理每个模块的，而内部默认的 Loader 只能处理 JS 模块，如果需要加载其他类型的模块就需要配置不同的 Loader。这也就引出了我们今天的主角：Loader。</p> <img src="/blog/webpack/webpack18.png" data-v-0246861c> <h3 data-v-0246861c>加载器的使用方式</h3> <p data-v-0246861c>需要的是一个可以加载 CSS 模块的 Loader，最常用到的是 css-loader。我们需要通过 npm 先去安装这个 Loader，然后在配置文件中添加对应的配置，具体操作和配置如下所示：</p> <div class="content__code-loader5" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code>$ npm install css<span class="token operator">-</span>loader <span class="token operator">--</span>save<span class="token operator">-</span>dev 
# or yarn add css<span class="token operator">-</span>loader <span class="token operator">--</span>dev

</code></pre></div></div> <div class="content__code-loader6" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./src/webpack.config.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span> <span class="token string">'./src/main.css'</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    filename<span class="token operator">:</span> <span class="token string">'bundle.js'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  module<span class="token operator">:</span> <span class="token punctuation">{</span>
    rules<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.css$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span> <span class="token comment">// 根据打包过程中所遇到文件路径匹配是否使用这个 loader</span>
        use<span class="token operator">:</span> <span class="token string">'css-loader'</span> <span class="token comment">// 指定具体的 loader</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>在配置对象的 module 属性中添加一个 rules 数组。这个数组就是我们针对资源模块的加载规则配置，其中的每个规则对象都需要设置两个属性：</p> <ul data-v-0246861c><li data-v-0246861c>首先是 test 属性，它是一个正则表达式，用来匹配打包过程中所遇到文件路径，这里我们是以 .css 结尾；</li> <li data-v-0246861c>然后是 use 属性，它用来指定匹配到的文件需要使用的 loader，这里用到的是 css-loader。</li></ul> <p data-v-0246861c>配置完成过后，我们回到命令行终端重新运行打包命令，打包过程就不会再出现错误了，因为这时 CSS 文件会交给 css-loader 处理过后再由 Webpack 打包。</p> <img src="/blog/webpack/webpack19.png" data-v-0246861c> <h3 data-v-0246861c>样式模块加载的问题</h3> <p data-v-0246861c>此时，如果你尝试在页面中使用这里输出的 bundle.js 文件，你会发现刚刚的这个 main.css 模块并没有工作。</p> <p data-v-0246861c>如果你之前有些经验，可能知道这个问题的解法，其实很简单，只需要再额外添加一个 style-loader，样式就可以正常工作了。</p> <p data-v-0246861c>不过只有解法没有原因不是我们的风格。下面我们来分析产生这个问题的真正原因，首先，我们找到刚刚生成的 bundle.js 文件，因为这个文件是 Webpack 打包后的结果，所有的模块都应该在这个文件中出现。</p> <p data-v-0246861c>由于默认打包入口在 Webpack 输出的结果中就是第一个模块，所以我们只需要看第一个模块目前是什么样的，如下图所示：</p> <img src="/blog/webpack/webpack20.png" data-v-0246861c> <p data-v-0246861c>仔细阅读这个文件，你会发现 css-loader 的作用是将 CSS 模块转换为一个 JS 模块，具体的实现方法是将我们的 CSS 代码 push 到一个数组中，这个数组是由 css-loader 内部的一个模块提供的，但是整个过程并没有任何地方使用到了这个数组。</p> <p data-v-0246861c>因此这里样式没有生效的原因是： css-loader 只会把 CSS 模块加载到 JS 代码中，而并不会使用这个模块。</p> <p data-v-0246861c>所以这里我们还需要在 css-loader 的基础上再使用一个 style-loader，把 css-loader 转换后的结果通过 style 标签追加到页面上。</p> <p data-v-0246861c>安装完 style-loader 之后，我们将配置文件中的 use 属性修改为一个数组，将 style-loader 也放进去。这里需要注意的是，一旦配置多个 Loader，执行顺序是从后往前执行的，所以这里一定要将 css-loader 放在最后，因为必须要 css-loader 先把 CSS 代码转换为 JS 模块，才可以正常打包，具体配置如下：</p> <div class="content__code-loader7" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./src/webpack.config.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span> <span class="token string">'./src/main.css'</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    filename<span class="token operator">:</span> <span class="token string">'bundle.js'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  module<span class="token operator">:</span> <span class="token punctuation">{</span>
    rules<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.css$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>
        <span class="token comment">// 对同一个模块使用多个 loader，注意顺序</span>
        use<span class="token operator">:</span> <span class="token punctuation">[</span>
          <span class="token string">'style-loader'</span><span class="token punctuation">,</span>
          <span class="token string">'css-loader'</span>
        <span class="token punctuation">]</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>配置完成之后，再次回到命令行重新打包，此时 bundle.js 文件中会额外多出两个模块。篇幅的关系，我们这里不再仔细解读。style-loader 的作用总结一句话就是，将 css-loader 中所加载到的所有样式模块，通过创建 style 标签的方式添加到页面上。</p> <p data-v-0246861c>以上就是我们对 Loader 使用的一些探索，Loader 是 Webpack 实现整个前端模块化的核心。因为只有通过不同的 Loader，Webpack 才可以实现任何类型资源的加载。</p> <h3 data-v-0246861c>通过 JS 加载资源模块</h3> <p data-v-0246861c>正如刚刚所提到的，一般 Webpack 打包的入口还是 JavaScript。因为从某种程度上来说，打包入口就是应用的运行入口，而目前前端应用中的业务是由 JS 驱动的，所以更合理的做法还是把 JS 文件作为打包的入口，然后在 JS 代码中通过 import 语句去加载 CSS 文件。</p> <div class="content__code-loader8" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code> └─ <span class="token number">03</span><span class="token operator">-</span>webpack<span class="token operator">-</span>loader ······················· sample root dir
    ├── src ································· source dir
    │   ├── style<span class="token punctuation">.</span>css ······················· style module
<span class="token operator">+</span>   │   └── main<span class="token punctuation">.</span>js ························· entry module
    ├── <span class="token keyword">package</span><span class="token punctuation">.</span>json ························ <span class="token keyword">package</span> file
    └── webpack<span class="token punctuation">.</span>config<span class="token punctuation">.</span>js ··················· webpack config file

</code></pre></div></div> <div class="content__code-loader9" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./src/main.js</span>
<span class="token keyword">import</span> <span class="token string">'./style.css'</span>

<span class="token comment">// app logic...</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'App starts running~'</span><span class="token punctuation">)</span>

</code></pre></div></div> <img src="/blog/webpack/webpack21.png" data-v-0246861c> <p data-v-0246861c>即便是通过 JS 代码去加载的 CSS 模块，css-loader 和 style-loader 仍然可以正常工作。因为 Webpack 在打包过程中会循环遍历每个模块，然后根据配置将每个遇到的模块交给对应的 Loader 去处理，最后再将处理完的结果打包到一起。</p> <h3 data-v-0246861c>为什么要在 JS 中加载其他资源</h3> <p data-v-0246861c>说到这里，你可能会产生疑惑：Webpack 为什么要在 JS 中载入 CSS 呢？不是应该将样式和行为分离么？</p> <p data-v-0246861c>其实 Webpack 不仅是建议我们在 JavaScript 中引入 CSS，还会建议我们在代码中引入当前业务所需要的任意资源文件。因为真正需要这个资源的并不是整个应用，而是你此时正在编写的代码。这就是 Webpack 的设计哲学。</p> <p data-v-0246861c>可能你乍一想好像不太容易理解，那你可以做一个假设：假设我们在开发页面上的某个局部功能时，需要用到一个样式模块和一个图片文件。如果你还是将这些资源文件单独引入到 HTML 中，然后再到 JS 中添加对应的逻辑代码。试想一下，如果后期这个局部功能不用了，你就需要同时删除 JS 中的代码和 HTML 中的资源文件引入，也就是同时需要维护这两条线。而如果你遵照 Webpack 的这种设计，所有资源的加载都是由 JS 代码控制，后期也就只需要维护 JS 代码这一条线了。</p> <p data-v-0246861c>所以说，通过 JavaScript 代码去引入资源文件，或者说是建立 JavaScript 和资源文件的依赖关系，具有明显的优势。因为 JavaScript 代码本身负责完成整个应用的业务功能，放大来说就是驱动了整个前端应用，而 JavaScript 代码在实现业务功能的过程中需要用到样式、图片等资源文件。如果建立这种依赖关系：</p> <ul data-v-0246861c><li data-v-0246861c>一来逻辑上比较合理，因为 JS 确实需要这些资源文件配合才能实现整体功能；</li> <li data-v-0246861c>二来配合 Webpack 这类工具的打包，能确保在上线时，资源不会缺失，而且都是必要的。</li></ul> <p data-v-0246861c>最后说一句题外话，学习新事物不是说学会它的所有用法你就能提高，因为这些照着文档操作基本上谁都可以做到，很多时候它的思想才是突破点。能搞明白新事物为什么这样设计，基本上你就算出道了。</p> <p data-v-0246861c>至于其他常用的加载器，我们在理解了 Loader 的机制过后，你可以通过官方的文档自行尝试。</p> <p data-v-0246861c>我每接触到一个新的加载器，核心就是搞明白这个 Loader 内部到底做了什么事情，它的目标是什么，其次才是这个 Loader 的配置用法。</p> <h3 data-v-0246861c>开发一个 Loader</h3> <p data-v-0246861c>Loader 作为 Webpack 的核心机制，内部的工作原理却非常简单。接下来我们一起来开发一个自己的 Loader，通过这个开发过程再来深入了解 Loader 的工作原理。</p> <p data-v-0246861c>这里我的需求是开发一个可以加载 markdown 文件的加载器，以便可以在代码中直接导入 md 文件。我们都应该知道 markdown 一般是需要转换为 html 之后再呈现到页面上的，所以我希望导入 md 文件后，直接得到 markdown 转换后的 html 字符串，如下图所示：</p> <img src="/blog/webpack/webpack22.png" data-v-0246861c> <p data-v-0246861c>由于这里需要直观地演示，我就不再单独创建一个 npm 模块，而是就直接在项目根目录下创建一个 markdown-loader.js 文件，完成后你可以把这个模块发布到 npm 上作为一个独立的模块使用。</p> <p data-v-0246861c>项目结构与核心代码如下所示：</p> <div class="content__code-loader10" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code> └─ <span class="token number">03</span><span class="token operator">-</span>webpack<span class="token operator">-</span>loader ······················· sample root dir
    ├── src ································· source dir
    │   ├── about<span class="token punctuation">.</span>md ························ markdown module
    │   └── main<span class="token punctuation">.</span>js ························· entry module
    ├── <span class="token keyword">package</span><span class="token punctuation">.</span>json ························ <span class="token keyword">package</span> file
<span class="token operator">+</span>   ├── markdown<span class="token operator">-</span>loader<span class="token punctuation">.</span>js ·················· markdown loader
    └── webpack<span class="token punctuation">.</span>config<span class="token punctuation">.</span>js ··················· webpack config file

</code></pre></div></div> <div class="content__code-loader11" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> <span class="token punctuation">.</span><span class="token operator">/</span>src<span class="token operator">/</span>about<span class="token punctuation">.</span>md <span class="token operator">--</span><span class="token operator">&gt;</span>
# About

<span class="token keyword">this</span> is a markdown file<span class="token punctuation">.</span>

</code></pre></div></div> <div class="content__code-loader12" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./src/main.js</span>
<span class="token keyword">import</span> about <span class="token keyword">from</span> <span class="token string">'./about.md'</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>about<span class="token punctuation">)</span>
<span class="token comment">// 希望 about =&gt; '&lt;h1&gt;About&lt;/h1&gt;&lt;p&gt;this is a markdown file.&lt;/p&gt;'</span>

</code></pre></div></div> <p data-v-0246861c>每个 Webpack 的 Loader 都需要导出一个函数，这个函数就是我们这个 Loader 对资源的处理过程，它的输入就是加载到的资源文件内容，输出就是我们加工后的结果。我们通过 source 参数接收输入，通过返回值输出。这里我们先尝试打印一下 source，然后在函数的内部直接返回一个字符串 hello loader ~，具体代码如下所示：</p> <div class="content__code-loader13" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./markdown-loader.js</span>
module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token parameter">source</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 加载到的模块内容 =&gt; '# About\n\nthis is a markdown file.'</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span>
  <span class="token comment">// 返回值就是最终被打包的内容</span>
  <span class="token keyword">return</span> <span class="token string">'hello loader ~'</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>完成以后，我们回到 Webpack 配置文件中添加一个加载器规则，这里匹配到的扩展名是 .md，使用的加载器就是我们刚刚编写的这个 markdown-loader.js 模块，具体代码如下所示：</p> <div class="content__code-loader14" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./markdown-loader.js</span>
module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token parameter">source</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 加载到的模块内容 =&gt; '# About\n\nthis is a markdown file.'</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span>
  <span class="token comment">// 返回值就是最终被打包的内容</span>
  <span class="token keyword">return</span> <span class="token string">'hello loader ~'</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>TIPS：这里的 use 中不仅可以使用模块名称，还可以使用模块文件路径，这点与 Node 中的 require 函数是一样的。</p> <p data-v-0246861c>配置完成后，我们再次打开命令行终端运行打包命令，如下图所示：</p> <img src="/blog/webpack/webpack23.png" data-v-0246861c> <p data-v-0246861c>打包过程中命令行确实打印出来了我们所导入的 Markdown 文件内容，这就意味着 Loader 函数的参数确实是文件的内容。</p> <p data-v-0246861c>但同时也报出了一个解析错误，说的是： You may need an additional loader to handle the result of these loaders.（我们可能还需要一个额外的加载器来处理当前加载器的结果）。</p> <p data-v-0246861c>那这究竟是为什么呢？其实 Webpack 加载资源文件的过程类似于一个工作管道，你可以在这个过程中依次使用多个 Loader，但是最终这个管道结束过后的结果必须是一段标准的 JS 代码字符串。</p> <img src="/blog/webpack/webpack24.png" data-v-0246861c> <p data-v-0246861c>所以我们这里才会出现上面提到的错误提示，那解决的办法也就很明显了：</p> <ul data-v-0246861c><li data-v-0246861c>直接在这个 Loader 的最后返回一段 JS 代码字符串；</li> <li data-v-0246861c>再找一个合适的加载器，在后面接着处理我们这里得到的结果。</li></ul> <p data-v-0246861c>先来尝试第一种办法。回到 markdown-loader 中，我们将返回的字符串内容修改为 console.log('hello loader~')，然后再次运行打包，此时 Webpack 就不再会报错了，代码如下所示：</p> <div class="content__code-loader15" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./markdown-loader.js</span>
module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token parameter">source</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 加载到的模块内容 =&gt; '# About\n\nthis is a markdown file.'</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span>
  <span class="token comment">// 返回值就是最终被打包的内容</span>
  <span class="token comment">// return 'hello loader ~'</span>
  <span class="token keyword">return</span> <span class="token string">'console.log(&quot;hello loader ~&quot;)'</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>那此时打包的结果是怎样的呢？我们打开输出的 bundle.js，找到最后一个模块（因为这个 md 文件是后引入的），如下图所示：</p> <img src="/blog/webpack/webpack25.png" data-v-0246861c> <p data-v-0246861c>这个模块里面非常简单，就是把我们刚刚返回的字符串直接拼接到了该模块中。这也解释了刚刚 Loader 管道最后必须返回 JS 代码的原因，因为如果随便返回一个内容，放到这里语法就不通过了。</p> <h3 data-v-0246861c>实现 Loader 的逻辑</h3> <p data-v-0246861c>了解了 Loader 大致的工作机制过后，我们再回到 markdown-loader.js 中，接着完成我的需求。这里需要安装一个能够将 Markdown 解析为 HTML 的模块，叫作 marked。</p> <p data-v-0246861c>安装完成后，我们在 markdown-loader.js 中导入这个模块，然后使用这个模块去解析我们的 source。这里解析完的结果就是一段 HTML 字符串，如果我们直接返回的话同样会面临 Webpack 无法解析模块的问题，正确的做法是把这段 HTML 字符串拼接为一段 JS 代码。</p> <p data-v-0246861c>此时我们希望返回的代码是通过 module.exports 导出这段 HTML 字符串，这样外界导入模块时就可以接收到这个 HTML 字符串了。如果只是简单地拼接，那 HTML 中的换行和引号就都可能会造成语法错误，所以我这里使用了一个小技巧，具体操作如下所示：</p> <div class="content__code-loader16" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./markdown-loader.js</span>
<span class="token keyword">const</span> marked <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'marked'</span><span class="token punctuation">)</span>

module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token parameter">source</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 1. 将 markdown 转换为 html 字符串</span>
  <span class="token keyword">const</span> html <span class="token operator">=</span> <span class="token function">marked</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span>
  <span class="token comment">// html =&gt; '&lt;h1&gt;About&lt;/h1&gt;&lt;p&gt;this is a markdown file.&lt;/p&gt;'</span>
  <span class="token comment">// 2. 将 html 字符串拼接为一段导出字符串的 JS 代码</span>
  <span class="token keyword">const</span> code <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">module.exports = </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
  <span class="token keyword">return</span> code 
  <span class="token comment">// code =&gt; 'export default &quot;&lt;h1&gt;About&lt;/h1&gt;&lt;p&gt;this is a markdown file.&lt;/p&gt;&quot;'</span>
<span class="token punctuation">}</span>
</code></pre></div></div> <p data-v-0246861c>先通过 JSON.stringify() 将字段字符串转换为标准的 JSON 字符串，然后再参与拼接，这样就不会有问题了。</p> <p data-v-0246861c>我们回到命令行再次运行打包，打包后的结果就是我们所需要的了。</p> <p data-v-0246861c>除了 module.exports 这种方式，Webpack 还允许我们在返回的代码中使用 ES Modules 的方式导出，例如，我们这里将 module.exports 修改为 export default，然后运行打包，结果同样是可以的，Webpack 内部会自动转换 ES Modules 代码。</p> <div class="content__code-loader17" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./markdown-loader.js</span>
<span class="token keyword">const</span> marked <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'marked'</span><span class="token punctuation">)</span>

module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token parameter">source</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> html <span class="token operator">=</span> <span class="token function">marked</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span>
  <span class="token comment">// const code = `module.exports = ${JSON.stringify(html)}`</span>
  <span class="token keyword">const</span> code <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">export default </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
  <span class="token keyword">return</span> code 
<span class="token punctuation">}</span>

</code></pre></div></div> <h3 data-v-0246861c>多个 Loader 的配合</h3> <p data-v-0246861c>我们还可以尝试一下刚刚说的第二种思路，就是在我们这个 markdown-loader 中直接返回 HTML 字符串，然后交给下一个 Loader 处理。这就涉及多个 Loader 相互配合工作的情况了。</p> <p data-v-0246861c>我们回到代码中，这里我们直接返回 marked 解析后的 HTML，代码如下所示：</p> <div class="content__code-loader18" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./markdown-loader.js</span>
<span class="token keyword">const</span> marked <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'marked'</span><span class="token punctuation">)</span>

module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token parameter">source</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 1. 将 markdown 转换为 html 字符串</span>
  <span class="token keyword">const</span> html <span class="token operator">=</span> <span class="token function">marked</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span>
  <span class="token keyword">return</span> html
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>然后我们再安装一个处理 HTML 的 Loader，叫作 html-loader，代码如下所示：</p> <div class="content__code-loader19" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span> <span class="token string">'./src/main.js'</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    filename<span class="token operator">:</span> <span class="token string">'bundle.js'</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  module<span class="token operator">:</span> <span class="token punctuation">{</span>
    rules<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.md$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>
        use<span class="token operator">:</span> <span class="token punctuation">[</span>
          <span class="token string">'html-loader'</span><span class="token punctuation">,</span>
          <span class="token string">'./markdown-loader'</span>
        <span class="token punctuation">]</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>安装完成过后回到配置文件，这里同样把 use 属性修改为一个数组，以便依次使用多个 Loader。不过同样需要注意，这里的执行顺序是从后往前，也就是说我们应该把先执行的 markdown-loader 放在后面，html-loader 放在前面。</p> <p data-v-0246861c>完成以后我们回到命令行终端再次打包，这里的打包结果仍然是可以的。</p> <p data-v-0246861c>至此，我们就完成了这个 markdown-loader 模块，其实整个过程重点在于 Loader 的工作原理和实现方式。</p> <div class="content__title-plugin" data-v-0246861c><h2 id="webpack插件机制"><a href="#webpack插件机制" class="header-anchor">#</a> webpack插件机制</h2></div> <p data-v-0246861c>Webpack 插件机制的目的是为了增强 Webpack 在项目自动化构建方面的能力。Loader 就是负责完成项目中各种各样资源模块的加载，从而实现整体项目的模块化，而 Plugin 则是用来解决项目中除了资源模块打包以外的其他自动化工作，所以说 Plugin 的能力范围更广，用途自然也就更多</p> <p data-v-0246861c>我在这里先介绍几个插件最常见的应用场景：</p> <ul data-v-0246861c><li data-v-0246861c>实现自动在打包之前清除 dist 目录（上次的打包结果）；</li> <li data-v-0246861c>自动生成应用所需要的 HTML 文件；</li> <li data-v-0246861c>根据不同环境为代码注入类似 API 地址这种可能变化的部分；</li> <li data-v-0246861c>拷贝不需要参与打包的资源文件到输出目录；</li> <li data-v-0246861c>压缩 Webpack 打包完成后输出的文件；</li> <li data-v-0246861c>自动发布打包结果到服务器实现自动部署。</li></ul> <h3 data-v-0246861c>体验插件机制</h3> <p data-v-0246861c>这里我们先来体验几个最常见的插件，首先第一个就是用来自动清除输出目录的插件。</p> <p data-v-0246861c>通过之前的尝试，你可能已经发现，Webpack 每次打包的结果都是直接覆盖到 dist 目录。而在打包之前，dist 目录中就可能已经存入了一些在上一次打包操作时遗留的文件，当我们再次打包时，只能覆盖掉同名文件，而那些已经移除的资源文件就会一直累积在里面，最终导致部署上线时出现多余文件，这显然非常不合理。</p> <p data-v-0246861c>更为合理的做法就是在每次完整打包之前，自动清理 dist 目录，这样每次打包过后，dist 目录中就只会存在那些必要的文件。</p> <p data-v-0246861c>clean-webpack-plugin 这个插件就很好的实现了这一需求。它是一个第三方的 npm 包，我们需要先通过 npm 安装一下，具体操作如下：</p> <p data-v-0246861c>$ npm install clean-webpack-plugin --save-dev</p> <p data-v-0246861c>安装过后，我们回到 Webpack 的配置文件中，然后导入 clean-webpack-plugin 插件，这个插件模块导出了一个叫作 CleanWebpackPlugin 的成员，我们先把它解构出来，具体代码如下。</p> <div class="content__code-plugin1" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> CleanWebpackPlugin <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'clean-webpack-plugin'</span><span class="token punctuation">)</span>

</code></pre></div></div> <p data-v-0246861c>回到配置对象中，添加一个 plugins 属性，这个属性就是专门用来配置插件的地方，它是一个数组，添加一个插件就是在这个数组中添加一个元素。</p> <p data-v-0246861c>绝大多数插件模块导出的都是一个类型，我们这里的 CleanWebpackPlugin 也不例外，使用它，就是通过这个类型创建一个实例，放入 plugins 数组中，具体代码如下：</p> <div class="content__code-plugin2" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>

<span class="token keyword">const</span> <span class="token punctuation">{</span> CleanWebpackPlugin <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'clean-webpack-plugin'</span><span class="token punctuation">)</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span> <span class="token string">'./src/main.js'</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    filename<span class="token operator">:</span> <span class="token string">'bundle.js'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">CleanWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>完成以后我们来测试一下 clean-webpack-plugin 插件的效果。回到命令行终端，再次运行 Webpack 打包，此时之前的打包结果就不会存在了，dist 目录中存放的就都是我们本次打包的结果。</p> <p data-v-0246861c>在这里，我只是希望通过这个非常简单的插件带你体验一下 Webpack 插件的使用。一般来说，当我们有了某个自动化的需求过后，可以先去找到一个合适的插件，然后安装这个插件，最后将它配置到 Webpack 配置对象的 plugins 数组中，这个过程唯一有可能不一样的地方就是，有的插件可能需要有一些配置参数。</p> <h3 data-v-0246861c>用于生成 HTML 的插件</h3> <p data-v-0246861c>除了自动清理 dist 目录，我们还有一个非常常见的需求，就是自动生成使用打包结果的 HTML，所谓使用打包结果指的是在 HTML 中自动注入 Webpack 打包生成的 bundle。</p> <p data-v-0246861c>在使用接下来这个插件之前，我们的 HTML 文件一般都是通过硬编码的方式，单独存放在项目根目录下的，这种方式有两个问题：</p> <p data-v-0246861c>项目发布时，我们需要同时发布根目录下的 HTML 文件和 dist 目录中所有的打包结果，非常麻烦，而且上线过后还要确保 HTML 代码中的资源文件路径是正确的。</p> <p data-v-0246861c>如果打包结果输出的目录或者文件名称发生变化，那 HTML 代码中所对应的 script 标签也需要我们手动修改路径。</p> <p data-v-0246861c>解决这两个问题最好的办法就是让 Webpack 在打包的同时，自动生成对应的 HTML 文件，让 HTML 文件也参与到整个项目的构建过程。这样的话，在构建过程中，Webpack 就可以自动将打包的 bundle 文件引入到页面中。</p> <p data-v-0246861c>相比于之前写死 HTML 文件的方式，自动生成 HTML 的优势在于：</p> <ul data-v-0246861c><li data-v-0246861c>HTML 也输出到 dist 目录中了，上线时我们只需要把 dist 目录发布出去就可以了；</li> <li data-v-0246861c>HTML 中的 script 标签是自动引入的，所以可以确保资源文件的路径是正常的。</li></ul> <p data-v-0246861c>具体的实现方式就需要借助于 html-webpack-plugin 插件来实现，这个插件也是一个第三方的 npm 模块，我们这里同样需要单独安装这个模块，具体操作如下：</p> <p data-v-0246861c>$ npm install html-webpack-plugin --save-dev</p> <p data-v-0246861c>安装完成过后，回到配置文件，载入这个模块，不同于 clean-webpack-plugin，html-webpack-plugin 插件默认导出的就是插件类型，不需要再解构内部成员，具体如下：</p> <div class="content__code-plugin3" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'html-webpack-plugin'</span><span class="token punctuation">)</span>

</code></pre></div></div> <p data-v-0246861c>有了这个类型过后，回到配置对象的 plugins 属性中，同样需要添加一下这个类型的实例对象，完成这个插件的使用，具体配置代码如下：</p> <div class="content__code-plugin4" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
<span class="token keyword">const</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'html-webpack-plugin'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> CleanWebpackPlugin <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'clean-webpack-plugin'</span><span class="token punctuation">)</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span> <span class="token string">'./src/main.js'</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    filename<span class="token operator">:</span> <span class="token string">'bundle.js'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">CleanWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>最后我们回到命令行终端，再次运行打包命令，此时打包过程中就会自动生成一个 index.html 文件到 dist 目录。我们找到这个文件，可以看到文件中的内容就是一段使用了 bundle.js 的空白 HTML，具体结果如下：</p> <img src="/blog/webpack/webpack26.png" data-v-0246861c> <p data-v-0246861c>至此，Webpack 就可以动态生成应用所需的 HTML 文件了，但是这里仍然存在一些需要改进的地方：</p> <ul data-v-0246861c><li data-v-0246861c>对于生成的 HTML 文件，页面 title 必须要修改；</li> <li data-v-0246861c>很多时候还需要我们自定义页面的一些 meta 标签和一些基础的 DOM 结构。</li></ul> <p data-v-0246861c>也就是说，还需要我们能够充分自定义这个插件最终输出的 HTML 文件。</p> <p data-v-0246861c>如果只是简单的自定义，我们可以通过修改 HtmlWebpackPlugin 的参数来实现。</p> <p data-v-0246861c>我们回到 Webpack 的配置文件中，这里我们给 HtmlWebpackPlugin 构造函数传入一个对象参数，用于指定配置选项。其中，title 属性设置的是 HTML 的标题，我们把它设置为 Webpack Plugin Simple。meta 属性需要以对象的形式设置页面中的元数据标签，这里我们尝试为页面添加一个 viewport 设置，具体代码如下：</p> <div class="content__code-plugin5" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
<span class="token keyword">const</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'html-webpack-plugin'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> CleanWebpackPlugin <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'clean-webpack-plugin'</span><span class="token punctuation">)</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span> <span class="token string">'./src/main.js'</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    filename<span class="token operator">:</span> <span class="token string">'bundle.js'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">CleanWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      title<span class="token operator">:</span> <span class="token string">'Webpack Plugin Sample'</span><span class="token punctuation">,</span>
      meta<span class="token operator">:</span> <span class="token punctuation">{</span>
        viewport<span class="token operator">:</span> <span class="token string">'width=device-width'</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>完成以后回到命令行终端，再次打包，然后我们再来看一下生成的 HTML 文件，此时这里的 title 和 meta 标签就会根据配置生成，具体结果如下：</p> <img src="/blog/webpack/webpack27.png" data-v-0246861c> <p data-v-0246861c>如果需要对 HTML 进行大量的自定义，更好的做法是在源代码中添加一个用于生成 HTML 的模板，然后让 html-webpack-plugin 插件根据这个模板去生成页面文件。</p> <p data-v-0246861c>我们这里在 src 目录下新建一个 index.html 文件作为 HTML 文件的模板，然后根据我们的需要在这个文件中添加相应的元素。对于模板中动态的内容，可以使用 Lodash 模板语法输出，模板中可以通过 htmlWebpackPlugin.options 访问这个插件的配置数据，例如我们这里输出配置中的 title 属性，具体代码如下：</p> <div class="content__code-plugin6" data-v-0246861c><div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- ./src/index.html --&gt;</span>
<span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>en<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>UTF-8<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>viewport<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>width=device-width, initial-scale=1.0<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>X-UA-Compatible<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>ie=edge<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>&lt;%= htmlWebpackPlugin.options.title %&gt;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>container<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>页面上的基础结构<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>root<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>

</code></pre></div></div> <p data-v-0246861c>有了模板文件过后，回到配置文件中，我们通过 HtmlWebpackPlugin 的 template 属性指定所使用的模板，具体配置如下：</p> <div class="content__code-plugin7" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
<span class="token keyword">const</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'html-webpack-plugin'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> CleanWebpackPlugin <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'clean-webpack-plugin'</span><span class="token punctuation">)</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span> <span class="token string">'./src/main.js'</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    filename<span class="token operator">:</span> <span class="token string">'bundle.js'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">CleanWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      title<span class="token operator">:</span> <span class="token string">'Webpack Plugin Sample'</span><span class="token punctuation">,</span>
      template<span class="token operator">:</span> <span class="token string">'./src/index.html'</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>完成以后我们回到命令行终端，运行打包命令，然后再来看一下生成的 HTML 文件，此时 HTML 中就都是根据模板生成的内容了，具体结果如下：</p> <img src="/blog/webpack/webpack28.png" data-v-0246861c> <p data-v-0246861c>至此，你应该了解了如何通过 html-webpack-plugin 自定义输出 HTML 文件内容。</p> <p data-v-0246861c>关于 html-webpack-plugin 插件，除了自定义输出文件的内容，同时输出多个 HTML 文件也是一个非常常见的需求，除非我们的应用是一个单页应用程序，否则一定需要输出多个 HTML 文件。</p> <p data-v-0246861c>如果需要同时输出多个 HTML 文件，其实也非常简单，我们回到配置文件中，这里通过 HtmlWebpackPlugin 创建的对象就是用于生成 index.html 的，那我们完全可以再创建一个新的实例对象，用于创建额外的 HTML 文件。</p> <p data-v-0246861c>例如，这里我们再来添加一个 HtmlWebpackPlugin 实例用于创建一个 about.html 的页面文件，我们需要通过 filename 指定输出文件名，这个属性的默认值是 index.html，我们把它设置为 about.html，具体配置如下：</p> <div class="content__code-plugin8" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
<span class="token keyword">const</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'html-webpack-plugin'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> CleanWebpackPlugin <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'clean-webpack-plugin'</span><span class="token punctuation">)</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span> <span class="token string">'./src/main.js'</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    filename<span class="token operator">:</span> <span class="token string">'bundle.js'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">CleanWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token comment">// 用于生成 index.html</span>
    <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      title<span class="token operator">:</span> <span class="token string">'Webpack Plugin Sample'</span><span class="token punctuation">,</span>
      template<span class="token operator">:</span> <span class="token string">'./src/index.html'</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token comment">// 用于生成 about.html</span>
    <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      filename<span class="token operator">:</span> <span class="token string">'about.html'</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>完成以后我们再次回到命令行终端，运行打包命令，然后我们展开 dist 目录，此时 dist 目录中就同时生成了 index.html 和 about.html 两个页面文件。</p> <p data-v-0246861c>根据这个尝试我们就应该知道，如果需要创建多个页面，就需要在插件列表中加入多个 HtmlWebpackPlugin 的实例对象，让每个对象负责一个页面文件的生成。</p> <p data-v-0246861c>当然了，对于同时输出多个 HTML，一般我们还会配合 Webpack 多入口打包的用法，这样就可以让不同的 HTML 使用不同的打包结果。不过关于多入口打包的用法不在本课时的讨论范畴内，我们后面再进行介绍。</p> <h3 data-v-0246861c>用于复制文件的插件</h3> <p data-v-0246861c>在我们的项目中一般还有一些不需要参与构建的静态文件，那它们最终也需要发布到线上，例如网站的 favicon、robots.txt 等。</p> <p data-v-0246861c>一般我们建议，把这类文件统一放在项目根目录下的 public 或者 static 目录中，我们希望 Webpack 在打包时一并将这个目录下所有的文件复制到输出目录。</p> <p data-v-0246861c>对于这种需求，我们可以使用 copy-webpack-plugin 插件来帮我们实现。</p> <p data-v-0246861c>同理，我们需要先安装一下 copy-webpack-plugin 插件，安装完成过后，回到配置文件中，导入这个插件类型。然后同样在 plugins 属性中添加一个这个类型的实例，具体代码如下：</p> <div class="content__code-plugin9" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
<span class="token keyword">const</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'html-webpack-plugin'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> CopyWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'copy-webpack-plugin'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> CleanWebpackPlugin <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'clean-webpack-plugin'</span><span class="token punctuation">)</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span> <span class="token string">'./src/main.js'</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    filename<span class="token operator">:</span> <span class="token string">'bundle.js'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">CleanWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      title<span class="token operator">:</span> <span class="token string">'Webpack Plugin Sample'</span><span class="token punctuation">,</span>
      template<span class="token operator">:</span> <span class="token string">'./src/index.html'</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">CopyWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
      <span class="token string">'public'</span> <span class="token comment">// 需要拷贝的目录或者路径通配符</span>
    <span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>这个插件类型的构造函数需要我们传入一个字符串数组，用于指定需要拷贝的文件路径。它可以是一个通配符，也可以是一个目录或者文件的相对路径。我们这里传入的是 public 目录，表示将这个目录下所有文件全部拷贝到输出目录中。当然了，你还可以在这个数组中继续添加其它路径，这样它在工作时可以同时拷贝。</p> <p data-v-0246861c>配置完成以后回到命令行终端，再次运行 Webpack，此时 public 目录下的文件就会同时拷贝到输出目录中。</p> <p data-v-0246861c>至此，我们简单了解了几个非常常用的插件，这里的重点是，你不仅要学会使用这几个插件的使用，还要能够总结出大多数插件在使用上的共性。</p> <h3 data-v-0246861c>开发一个插件</h3> <p data-v-0246861c>通过前面的介绍，我们知道相比于 Loader，插件的能力范围更宽，因为 Loader 只是在模块的加载环节工作，而插件的作用范围几乎可以触及 Webpack 工作的每一个环节。</p> <p data-v-0246861c>那么，这种插件机制是如何实现的呢？</p> <p data-v-0246861c>其实说起来也非常简单，Webpack 的插件机制就是我们在软件开发中最常见的钩子机制。</p> <p data-v-0246861c>钩子机制也特别容易理解，它有点类似于 Web 中的事件。在 Webpack 整个工作过程会有很多环节，为了便于插件的扩展，Webpack 几乎在每一个环节都埋下了一个钩子。这样我们在开发插件的时候，通过往这些不同节点上挂载不同的任务，就可以轻松扩展 Webpack 的能力。</p> <img src="/blog/webpack/webpack1.gif" data-v-0246861c> <p data-v-0246861c>具体有哪些预先定义好的钩子，我们可以参考官方文档的 API：</p> <ul data-v-0246861c><li data-v-0246861c>Compiler Hooks；</li> <li data-v-0246861c>Compilation Hooks；</li> <li data-v-0246861c>Compilation Hooks；</li></ul> <p data-v-0246861c>接下来，我们来开发一个自己的插件，看看具体如何往这些钩子上挂载任务。</p> <p data-v-0246861c>这里我的需求是，希望我们开发的这个插件能够自动清除 Webpack 打包结果中的注释，这样一来，我们的 bundle.js 将更容易阅读，如下图所示：</p> <img src="/blog/webpack/webpack29.png" data-v-0246861c> <p data-v-0246861c>那这里我们同样在项目根目录下添加一个单独的 JS 文件。</p> <div class="content__code-plugin10" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code>└─ <span class="token number">04</span><span class="token operator">-</span>webpack<span class="token operator">-</span>plugins ······················· sample root dir
    ├── <span class="token keyword">public</span> ······························· <span class="token keyword">static</span> dir
    │   └── favicon<span class="token punctuation">.</span>ico ······················ <span class="token keyword">static</span> file
    ├── src ·································· source dir
    │   └── main<span class="token punctuation">.</span>js ·························· entry module
    ├── <span class="token keyword">package</span><span class="token punctuation">.</span>json ························· <span class="token keyword">package</span> file
<span class="token operator">+</span>   ├── remove<span class="token operator">-</span>comments<span class="token operator">-</span>plugin<span class="token punctuation">.</span>js ············ my plugin
    └── webpack<span class="token punctuation">.</span>config<span class="token punctuation">.</span>js ···················· webpack config file

</code></pre></div></div> <p data-v-0246861c>Webpack 要求我们的插件必须是一个函数或者是一个包含 apply 方法的对象，一般我们都会定义一个类型，在这个类型中定义 apply 方法。然后在使用时，再通过这个类型来创建一个实例对象去使用这个插件。</p> <p data-v-0246861c>所以我们这里定义一个 RemoveCommentsPlugin 类型，然后在这个类型中定义一个 apply 方法，这个方法会在 Webpack 启动时被调用，它接收一个 compiler 对象参数，这个对象是 Webpack 工作过程中最核心的对象，里面包含了我们此次构建的所有配置信息，我们就是通过这个对象去注册钩子函数，具体代码如下：</p> <div class="content__code-plugin11" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./remove-comments-plugin.js</span>
<span class="token keyword">class</span> <span class="token class-name">RemoveCommentsPlugin</span> <span class="token punctuation">{</span>
  <span class="token function">apply</span> <span class="token punctuation">(</span><span class="token parameter">compiler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'RemoveCommentsPlugin 启动'</span><span class="token punctuation">)</span>
    <span class="token comment">// compiler =&gt; 包含了我们此次构建的所有配置信息</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>知道这些过后，还需要明确我们这个任务的执行时机，也就是到底应该把这个任务挂载到哪个钩子上。</p> <p data-v-0246861c>我们的需求是删除 bundle.js 中的注释，也就是说只有当 Webpack 需要生成的 bundle.js 文件内容明确过后才可能实施。</p> <img src="/blog/webpack/webpack30.png" data-v-0246861c> <p data-v-0246861c>那根据 API 文档中的介绍，我们找到一个叫作 emit 的钩子，这个钩子会在 Webpack 即将向输出目录输出文件时执行，非常符合我们的需求。</p> <p data-v-0246861c>我们回到代码中，通过 compiler 对象的 hooks 属性访问到 emit 钩子，再通过 tap 方法注册一个钩子函数，这个方法接收两个参数：</p> <ul data-v-0246861c><li data-v-0246861c>第一个是插件的名称，我们这里的插件名称是 RemoveCommentsPlugin；</li> <li data-v-0246861c>第二个是要挂载到这个钩子上的函数；</li></ul> <p data-v-0246861c>根据 API 文档中的提示，这里我们在这个函数中接收一个 compilation 对象参数，这个对象可以理解为此次运行打包的上下文，所有打包过程中产生的结果，都会放到这个对象中。</p> <p data-v-0246861c>我们可以使用这个对象中的 assets 属性获取即将写入输出目录的资源文件信息，它是一个对象，我们这里通过 for in 去遍历这个对象，其中键就是每个文件的名称，我们尝试把它打印出来，具体代码如下：</p> <div class="content__code-plugin12" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./remove-comments-plugin.js</span>
<span class="token keyword">class</span> <span class="token class-name">RemoveCommentsPlugin</span> <span class="token punctuation">{</span>
  <span class="token function">apply</span> <span class="token punctuation">(</span><span class="token parameter">compiler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    compiler<span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>emit<span class="token punctuation">.</span><span class="token function">tap</span><span class="token punctuation">(</span><span class="token string">'RemoveCommentsPlugin'</span><span class="token punctuation">,</span> <span class="token parameter">compilation</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// compilation =&gt; 可以理解为此次打包的上下文</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> name <span class="token keyword">in</span> compilation<span class="token punctuation">.</span>assets<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token comment">// 输出文件名称</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>完成以后，我们将这个插件应用到 Webpack 的配置中，然后回到命令行重新打包，此时打包过程就会打印我们输出的文件名称，代码如下：</p> <img src="/blog/webpack/webpack31.png" data-v-0246861c> <p data-v-0246861c>我们再回到代码中，来打印一下每个资源文件的内容，文件内容需要通过遍历的值对象中的 source 方法获取，具体代码如下：</p> <div class="content__code-plugin13" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./remove-comments-plugin.js</span>
<span class="token keyword">class</span> <span class="token class-name">RemoveCommentsPlugin</span> <span class="token punctuation">{</span>
  <span class="token function">apply</span> <span class="token punctuation">(</span><span class="token parameter">compiler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    compiler<span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>emit<span class="token punctuation">.</span><span class="token function">tap</span><span class="token punctuation">(</span><span class="token string">'RemoveCommentsPlugin'</span><span class="token punctuation">,</span> <span class="token parameter">compilation</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// compilation =&gt; 可以理解为此次打包的上下文</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> name <span class="token keyword">in</span> compilation<span class="token punctuation">.</span>assets<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// console.log(name)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>compilation<span class="token punctuation">.</span>assets<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 输出文件内容</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>回到命令行，再次打包，此时输出的文件内容也可以正常被打印。</p> <p data-v-0246861c>能够拿到文件名和文件内容后，我们回到代码中。这里需要先判断文件名是不是以 .js 结尾，因为 Webpack 打包还有可能输出别的文件，而我们的需求只需要处理 JS 文件。</p> <p data-v-0246861c>那如果是 JS 文件，我们将文件内容得到，再通过正则替换的方式移除掉代码中的注释，最后覆盖掉 compilation.assets 中对应的对象，在覆盖的对象中，我们同样暴露一个 source 方法用来返回新的内容。另外还需要再暴露一个 size 方法，用来返回内容大小，这是 Webpack 内部要求的格式，具体代码如下：</p> <div class="content__code-plugin14" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./remove-comments-plugin.js</span>
<span class="token keyword">class</span> <span class="token class-name">RemoveCommentsPlugin</span> <span class="token punctuation">{</span>
  <span class="token function">apply</span> <span class="token punctuation">(</span><span class="token parameter">compiler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    compiler<span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>emit<span class="token punctuation">.</span><span class="token function">tap</span><span class="token punctuation">(</span><span class="token string">'RemoveCommentsPlugin'</span><span class="token punctuation">,</span> <span class="token parameter">compilation</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// compilation =&gt; 可以理解为此次打包的上下文</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> name <span class="token keyword">in</span> compilation<span class="token punctuation">.</span>assets<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">'.js'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">const</span> contents <span class="token operator">=</span> compilation<span class="token punctuation">.</span>assets<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          <span class="token keyword">const</span> noComments <span class="token operator">=</span> contents<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\/\*{2,}\/\s?</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>
          compilation<span class="token punctuation">.</span>assets<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
            <span class="token function-variable function">source</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> noComments<span class="token punctuation">,</span>
            <span class="token function-variable function">size</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> noComments<span class="token punctuation">.</span>length
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>完成以后回到命令行终端，再次打包，打包完成过后，我们再来看一下 bundle.js，此时 bundle.js 中每行开头的注释就都被移除了。</p> <img src="/blog/webpack/webpack32.png" data-v-0246861c> <p data-v-0246861c>以上就是我们实现一个移除注释插件的过程，通过这个过程我们了解了：插件都是通过往 Webpack 生命周期的钩子中挂载任务函数实现的。</p> <div class="content__title-running" data-v-0246861c><h2 id="webpack运行机制与工作原理"><a href="#webpack运行机制与工作原理" class="header-anchor">#</a> webpack运行机制与工作原理</h2></div> <h3 data-v-0246861c>工作过程简介</h3> <p data-v-0246861c>其实 Webpack 官网首屏的英雄区就已经很清楚地描述了它的工作原理，如下图所示：</p> <img src="/blog/webpack/webpack33.png" data-v-0246861c> <p data-v-0246861c>那这里我们先来快速理解一下 Webpack 打包的核心工作过程。我们以一个普通的前端项目为例，项目中一般都会散落着各种各样的代码及资源文件，如下图所示：</p> <img src="/blog/webpack/webpack34.png" data-v-0246861c> <p data-v-0246861c>比如 JS、CSS、图片、字体等，这些文件在 Webpack 的思想中都属于当前项目中的一个模块。Webpack 可以通过打包，将它们最终聚集到一起。Webpack 在整个打包的过程中：</p> <ul data-v-0246861c><li data-v-0246861c>通过 Loader 处理特殊类型资源的加载，例如加载样式、图片；</li> <li data-v-0246861c>通过 Plugin 实现各种自动化的构建任务，例如自动压缩、自动发布。</li></ul> <p data-v-0246861c>具体来看打包的过程，Webpack 启动后，会根据我们的配置，找到项目中的某个指定文件（一般这个文件都会是一个 JS 文件）作为入口。然后顺着入口文件中的代码，根据代码中出现的 import（ES Modules）或者是 require（CommonJS）之类的语句，解析推断出来这个文件所依赖的资源模块，然后再分别去解析每个资源模块的依赖，周而复始，最后形成整个项目中所有用到的文件之间的依赖关系树，下面这个动画生动的演示了这个过程：</p> <img src="/blog/webpack/webpack2.gif" data-v-0246861c> <p data-v-0246861c>有了这个依赖关系树过后， Webpack 会遍历（递归）这个依赖树，找到每个节点对应的资源文件，然后根据配置选项中的 Loader 配置，交给对应的 Loader 去加载这个模块，最后将加载的结果放入 bundle.js（打包结果）中，从而实现整个项目的打包，具体操作可以参考下面的动画：</p> <img src="/blog/webpack/webpack3.gif" data-v-0246861c> <p data-v-0246861c>对于依赖模块中无法通过 JavaScript 代码表示的资源模块，例如图片或字体文件，一般的 Loader 会将它们单独作为资源文件拷贝到输出目录中，然后将这个资源文件所对应的访问路径作为这个模块的导出成员暴露给外部。</p> <p data-v-0246861c>整个打包过程中，Loader 机制起了很重要的作用，因为如果没有 Loader 的话，Webpack 就无法实现各种各样类型的资源文件加载，那 Webpack 也就只能算是一个用来合并 JS 模块代码的工具了。</p> <p data-v-0246861c>至于自定义插件机制，在上文我们也详细介绍过了，它并不会影响 Webpack 的核心工作过程，只是 Webpack 为了提供一个强大的扩展能力，它为整个工作过程的每个环节都预制了一个钩子，也就是说我们可以通过插件往 Webpack 工作过程的任意环节植入一些自定义的任务，从而扩展 Webpack 打包功能以外的能力。</p> <p data-v-0246861c>至此，你就已经了解到了 Webpack 的核心工作过程。</p> <h3 data-v-0246861c>工作原理剖析</h3> <p data-v-0246861c>对于一般的应用开发过程来说，了解以上这些内容基本上就足以应对了，但如果你想了解 Webpack 整个工作过程的细节，那么你就需要更深入地了解刚刚说到的每一个环节，它们落实到代码层面到底做了些什么，或者说是如何实现的。</p> <p data-v-0246861c>在这种情况下，我们就必须有针对性的去“查阅”Webpack 的源代码了。注意这里我们强调的是“查阅”，而不是“阅读”。</p> <p data-v-0246861c>至于为什么要扣这个字眼，我们先卖个关子，今天的最后再来解释。</p> <p data-v-0246861c>既然是“查阅”，我们就必须要有个线索，否则挨个去看每个源代码，就是无意义的阅读。这里我们的思路就是顺着前面刚刚介绍的 Webpack 打包的核心工作过程，提炼出关键环节，然后再有针对性地去找每个环节的实现方式就可以了。</p> <p data-v-0246861c>这里我们先提炼出 Webpack 核心工作过程中的关键环节，明确“查阅”源码的思路：</p> <ul data-v-0246861c><li data-v-0246861c>Webpack CLI 启动打包流程；</li> <li data-v-0246861c>载入 Webpack 核心模块，创建 Compiler 对象；</li> <li data-v-0246861c>使用 Compiler 对象开始编译整个项目；</li> <li data-v-0246861c>从入口文件开始，解析模块依赖，形成依赖关系树；</li> <li data-v-0246861c>递归依赖树，将每个模块交给对应的 Loader 处理；</li> <li data-v-0246861c>合并 Loader 处理完的结果，将打包结果输出到 dist 目录。</li></ul> <p data-v-0246861c>接下来我们将对上述关键环节中的部分内容进行详细介绍。</p> <h3 data-v-0246861c>Webpack CLI</h3> <p data-v-0246861c>从 Webpack 4 开始 Webpack 的 CLI 部分就被单独抽到了 webpack-cli 模块中，目的是为了增强 Webpack 本身的灵活性。所以这一部分的内容我们需要找到 webpack-cli 所对应的源码。</p> <p data-v-0246861c>我们这里分析的是 v3.3.11 版本的 webpack-cli，你可以参考该版本的源码固定链接。</p> <p data-v-0246861c>P.S. 目前 webpack-cli 官方仓库默认分支下的代码不是 3.x 版本的。</p> <p data-v-0246861c>Webpack CLI 的作用就是将 CLI 参数和 Webpack 配置文件中的配置整合，得到一个完整的配置对象。</p> <p data-v-0246861c>这部分操作在 webpack-cli 的入口文件 bin/cli.js 中，这个文件中内容比较多，我们这里只截取部分核心代码，你可以对照截图中的行号找到源代码中对应的位置。</p> <p data-v-0246861c>首先，Webpack CLI 会通过 yargs 模块解析 CLI 参数，所谓 CLI 参数指的就是我们在运行 webpack 命令时通过命令行传入的参数，例如 --mode=production，具体位置如下：</p> <img src="/blog/webpack/webpack35.png" data-v-0246861c> <p data-v-0246861c>紧接着后面，调用了 bin/utils/convert-argv.js 模块，将得到的命令行参数转换为 Webpack 的配置选项对象，具体操作如下：</p> <img src="/blog/webpack/webpack36.png" data-v-0246861c> <p data-v-0246861c>在 convert-argv.js 工作过程中，首先为传递过来的命令行参数设置了默认值，然后判断了命令行参数中是否指定了一个具体的配置文件路径，如果指定了就加载指定配置文件，反之则需要根据默认配置文件加载规则找到配置文件，具体代码如下：</p> <img src="/blog/webpack/webpack37.png" data-v-0246861c> <p data-v-0246861c>找到配置文件过后，将配置文件中的配置和 CLI 参数中的配置合并，如果出现重复的情况，会优先使用 CLI 参数，最终得到一个完整的配置选项。</p> <p data-v-0246861c>有了配置选项过后，开始载入 Webpack 核心模块，传入配置选项，创建 Compiler 对象，这个 Compiler 对象就是整个 Webpack 工作过程中最核心的对象了，负责完成整个项目的构建工作。</p> <img src="/blog/webpack/webpack38.png" data-v-0246861c> <h3 data-v-0246861c>创建 Compiler 对象</h3> <p data-v-0246861c>随着 Webpack CLI 载入 Webpack 核心模块，整个执行过程就到了 Webpack 模块中，所以这一部分的代码需要回到 Webpack 模块中，我这里分析的是 v4.43.0 版本的 Webpack，可参考这个版本的源代码的固定链接。</p> <p data-v-0246861c>同样，这里我们需要找到这个模块的入口文件，也就是 lib/webpack.js 文件。这个文件导出的是一个用于创建 Compiler 的函数，具体如下：</p> <img src="/blog/webpack/webpack39.png" data-v-0246861c> <p data-v-0246861c>在这个函数中，首先校验了外部传递过来的 options 参数是否符合要求，紧接着判断了 options 的类型。</p> <p data-v-0246861c>根据这个函数中的代码，我们发现 options 不仅仅可以是一个对象，还可以是一个数组。如果我们传入的是一个数组，那么 Webpack 内部创建的就是一个 MultiCompiler，也就是说 Webpack 应该支持同时开启多路打包，配置数组中的每一个成员就是一个独立的配置选项。而如果我们传入的是普通的对象，就会按照我们最熟悉的方式创建一个 Compiler 对象，进行单线打包。</p> <img src="/blog/webpack/webpack40.png" data-v-0246861c> <p data-v-0246861c>我们顺着主线接着往下看，如下图所示：在创建了 Compiler 对象过后，Webpack 就开始注册我们配置中的每一个插件了，因为再往后 Webpack 工作过程的生命周期就要开始了，所以必须先注册，这样才能确保插件中的每一个钩子都能被命中。</p> <img src="/blog/webpack/webpack41.png" data-v-0246861c> <h3 data-v-0246861c>开始构建</h3> <p data-v-0246861c>完成 Compiler 对象的创建过后，紧接着这里的代码开始判断配置选项中是否启用了监视模式，具体操作如下：</p> <img src="/blog/webpack/webpack42.png" data-v-0246861c> <ul data-v-0246861c><li data-v-0246861c>如果是监视模式就调用 Compiler 对象的 watch 方法，以监视模式启动构建，但这不是我们主要关心的主线。</li> <li data-v-0246861c>如果不是监视模式就调用 Compiler 对象的 run 方法，开始构建整个应用。</li></ul> <p data-v-0246861c>这个 run 方法定义在 Compiler 类型中，具体文件在 webpack 模块下的 lib/Compiler.js 中，代码位置如下：</p> <img src="/blog/webpack/webpack43.png" data-v-0246861c> <p data-v-0246861c>这个方法内部就是先触发了beforeRun 和 run 两个钩子，然后最关键的是调用了当前对象的 compile 方法，真正开始编译整个项目，具体代码位置如下：</p> <img src="/blog/webpack/webpack44.png" data-v-0246861c> <p data-v-0246861c>compile 方法内部主要就是创建了一个 Compilation 对象，这个对象我们在 04 课时中有提到，Compilation 字面意思是“合集”，实际上，你就可以理解为一次构建过程中的上下文对象，里面包含了这次构建中全部的资源和信息。</p> <img src="/blog/webpack/webpack45.png" data-v-0246861c> <p data-v-0246861c>创建完 Compilation 对象过后，紧接着触发了一个叫作 make 的钩子，进入整个构建过程最核心的 make 阶段。</p> <h3 data-v-0246861c>make 阶段</h3> <p data-v-0246861c>make 阶段主体的目标就是：根据 entry 配置找到入口模块，开始依次递归出所有依赖，形成依赖关系树，然后将递归到的每个模块交给不同的 Loader 处理。</p> <img src="/blog/webpack/webpack46.png" data-v-0246861c> <p data-v-0246861c>由于这个阶段的调用过程并不像之前一样，直接调用某个对象的某个方法，而是采用事件触发机制，让外部监听这个 make 事件的地方开始执行，所以从这里往后的代码可能找起来会费点劲儿。</p> <p data-v-0246861c>这里我简单提示一下：想要知道这个事件触发后，哪些地方会开始执行，前提是得知道哪里注册了这个叫作 make 的事件。</p> <p data-v-0246861c>Webpack 的插件系统是基于官方自己的 Tapable 库实现的，我们想要知道在哪里注册了某个事件，必须要知道如何注册的事件。Tapable 的注册方式具体如下：</p> <img src="/blog/webpack/webpack47.png" data-v-0246861c> <p data-v-0246861c>所以，我们只需要通过开发工具搜索源代码中的 make.tap，就应该能够找到事件注册的位置，具体操作如下：</p> <img src="/blog/webpack/webpack48.png" data-v-0246861c> <p data-v-0246861c>这里搜索到了六个插件中都注册了 make 事件，这些插件实际上是前面创建 Compiler 对象的时候创建的，刚刚因为没有影响，所以我们就忽略了：</p> <img src="/blog/webpack/webpack49.png" data-v-0246861c> <p data-v-0246861c>因为我们默认使用的就是单一入口打包的方式，所以这里最终会执行其中的 SingleEntryPlugin。</p> <img src="/blog/webpack/webpack50.png" data-v-0246861c> <p data-v-0246861c>这个插件中调用了 Compilation 对象的 addEntry 方法，开始解析我们源代码中的入口文件，以此开始“顺藤摸瓜”式的寻找。</p> <p data-v-0246861c>因为时间的关系，我在这里就不再带你继续一步一步的往后探索每一个阶段了，你可以顺着我们刚刚的思路，私下继续去尝试。</p> <p data-v-0246861c>对于 make 阶段后续的流程，这里我们概括一下：</p> <ul data-v-0246861c><li data-v-0246861c>SingleEntryPlugin 中调用了 Compilation 对象的 addEntry 方法，开始解析入口；</li> <li data-v-0246861c>addEntry 方法中又调用了 _addModuleChain 方法，将入口模块添加到模块依赖列表中；</li> <li data-v-0246861c>紧接着通过 Compilation 对象的 buildModule 方法进行模块构建；</li> <li data-v-0246861c>buildModule 方法中执行具体的 Loader，处理特殊资源加载；</li> <li data-v-0246861c>build 完成过后，通过 acorn 库生成模块代码的 AST 语法树；</li> <li data-v-0246861c>根据语法树分析这个模块是否还有依赖的模块，如果有则继续循环 build 每个依赖；</li> <li data-v-0246861c>所有依赖解析完成，build 阶段结束；</li> <li data-v-0246861c>最后合并生成需要输出的 bundle.js 写入 dist 目录。</li></ul> <div class="content__title-Dev" data-v-0246861c><h2 id="dev-server使用"><a href="#dev-server使用" class="header-anchor">#</a> Dev Server使用</h2></div> <p data-v-0246861c>因为“编写源代码 → Webpack 打包 → 运行应用 → 浏览器查看”这种周而复始的开发方式过于原始，在实际开发过程中，如果你还是按照这种方式来工作，开发效率必然会十分低下。</p> <p data-v-0246861c>那究竟该如何提高我们的开发效率呢？</p> <p data-v-0246861c>这里我先对一个较为理想的开发环境做出设想：</p> <ul data-v-0246861c><li data-v-0246861c>首先，它必须能够使用 HTTP 服务运行而不是文件形式预览。这样的话，一来更接近生产环境状态，二来我们的项目可能需要使用 AJAX 之类的 API，以文件形式访问会产生诸多问题。</li> <li data-v-0246861c>其次，在我们修改完代码过后，Webpack 能够自动完成构建，然后浏览器可以即时显示最新的运行结果，这样就大大减少了开发过程中额外的重复操作，同时也会让我们更加专注，效率自然得到提升。</li> <li data-v-0246861c>最后，它还需要能提供 Source Map 支持。这样一来，运行过程中出现的错误就可以快速定位到源代码中的位置，而不是打包后结果中的位置，更便于我们快速定位错误、调试应用。</li></ul> <p data-v-0246861c>对于以上的这些需求 Webpack 都已经提供了相对应的功能，其中部分功能需要用到一些周边的工具，具体效果如下：</p> <img src="/blog/webpack/webpack4.gif" data-v-0246861c> <h3 data-v-0246861c>Webpack 自动编译</h3> <p data-v-0246861c>正如前面所讲，如果我们每次修改完代码，都是通过命令行手动重复运行 Webpack 命令，从而得到最新的打包结果，那么这样的操作过程根本没有任何开发体验可言。</p> <p data-v-0246861c>针对上述这个问题，我们可以使用 Webpack CLI 提供的另外一种 watch 工作模式来解决。</p> <p data-v-0246861c>如果你之前了解过其它的一些构建工具，你应该对 watch 模式并不陌生。在这种模式下，Webpack 完成初次构建过后，项目中的源文件会被监视，一旦发生任何改动，Webpack 都会自动重新运行打包任务。</p> <p data-v-0246861c>具体的用法也非常简单，就是在启动 Webpack 时，添加一个 --watch 的 CLI 参数，这样的话，Webpack 就会以监视模式启动运行。在打包完成过后，CLI 不会立即退出，它会等待文件变化再次工作，直到我们手动结束它或是出现不可控的异常。</p> <p data-v-0246861c>在 watch 模式下我们就只需专注编码，不必再去手动完成编译工作了，相比于原始手动操作的方式，有了很明显的进步。</p> <p data-v-0246861c>我们还可以再开启另外一个命令行终端，同时以 HTTP 形式运行我们的应用，然后打开浏览器去预览应用。</p> <p data-v-0246861c>我们可以将浏览器移至屏幕的左侧，然后将编辑器移至右侧，此时我们尝试修改源代码，保存过后，以 watch 模式工作的 Webpack 就会自动重新打包，然后我们就可以在浏览器中刷新页面查看最新的结果，具体效果如下图所示：</p> <img src="/blog/webpack/webpack51.png" data-v-0246861c> <p data-v-0246861c>那此时我们的开发体验就是：修改代码 → Webpack 自动打包 → 手动刷新浏览器 → 预览运行结果。</p> <p data-v-0246861c>P.S. 这里我使用的静态文件服务器是一个 npm 模块，叫作 serve。</p> <p data-v-0246861c>此时距离我们的目标状态还差一点，如果浏览器能够在 Webpack 打包过后自动刷新，那我们的开发体验将会更好一些。</p> <p data-v-0246861c>如果你已经了解过一个叫作 BrowserSync 的工具，你应该知道 BrowserSync 就可以帮我们实现文件变化过后浏览器自动刷新的功能。</p> <p data-v-0246861c>所以，我们就可以使用 BrowserSync 工具替换 serve 工具，启动 HTTP 服务，这里还需要同时监听 dist 目录下文件的变化，具体命令如下：</p> <div class="content__code-Dev1" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code># 可以先通过 npm 全局安装 browser<span class="token operator">-</span>sync 模块，然后再使用这个模块
$ npm install browser<span class="token operator">-</span>sync <span class="token operator">--</span>global
$ browser<span class="token operator">-</span>sync dist <span class="token operator">--</span>watch

# 或者也可以使用 npx 直接使用远端模块
$ npx browser<span class="token operator">-</span>sync dist <span class="token operator">--</span>watch

</code></pre></div></div> <p data-v-0246861c>启动过后，我们回到编辑器，然后尝试修改源文件，保存完成以后浏览器就会自动刷新，显示最新结果。</p> <p data-v-0246861c>它的原理就是 Webpack 监视源代码变化，自动打包源代码到 dist 中，而 dist 中文件的变化又被 BrowserSync 监听了，从而实现自动编译并且自动刷新浏览器的功能，整个过程由两个工具分别监视不同的内容。</p> <p data-v-0246861c>这种 watch 模式 + BrowserSync 虽然也实现了我们的需求，但是这种方法有很多弊端：</p> <ul data-v-0246861c><li data-v-0246861c>操作烦琐，我们需要同时使用两个工具，那么需要了解的内容就会更多，学习成本大大提高；</li> <li data-v-0246861c>效率低下，因为整个过程中， Webpack 会将文件写入磁盘，BrowserSync 再进行读取。过程中涉及大量磁盘读写操作，必然会导致效率低下。</li></ul> <p data-v-0246861c>所以这只能算是“曲线救国”，并不完美，我们仍然需要继续改善。</p> <h3 data-v-0246861c>Webpack Dev Server</h3> <p data-v-0246861c>webpack-dev-server 是 Webpack 官方推出的一款开发工具，根据它的名字我们就应该知道，它提供了一个开发服务器，并且将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起。</p> <p data-v-0246861c>Webpack 官方推出 webpack-dev-server 这款工具的初衷，就是为了提高开发者日常的开发效率，使用这个工具就可以解决我在开头所提出的问题。而且它是一个高度集成的工具，使用起来十分的方便。</p> <p data-v-0246861c>webpack-dev-server 同样也是一个独立的 npm 模块，所以我们需要通过 npm 将 webpack-dev-server 作为项目的开发依赖安装。安装完成过后，这个模块为我们提供了一个叫作 webpack-dev-server 的 CLI 程序，我们同样可以直接通过 npx 直接去运行这个 CLI，或者把它定义到 npm scripts 中，具体操作如下：</p> <div class="content__code-Dev2" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code># 安装 webpack<span class="token operator">-</span>dev<span class="token operator">-</span>server
$ npm install webpack<span class="token operator">-</span>dev<span class="token operator">-</span>server <span class="token operator">--</span>save<span class="token operator">-</span>dev
# 运行 webpack<span class="token operator">-</span>dev<span class="token operator">-</span>server
$ npx webpack<span class="token operator">-</span>dev<span class="token operator">-</span>server

</code></pre></div></div> <p data-v-0246861c>运行 webpack-dev-server 这个命令时，它内部会启动一个 HTTP Server，为打包的结果提供静态文件服务，并且自动使用 Webpack 打包我们的应用，然后监听源代码的变化，一旦文件发生变化，它会立即重新打包，大致流程如下：</p> <img src="/blog/webpack/webpack52.png" data-v-0246861c> <p data-v-0246861c>不过这里需要注意的是，webpack-dev-server 为了提高工作速率，它并没有将打包结果写入到磁盘中，而是暂时存放在内存中，内部的 HTTP Server 也是从内存中读取这些文件的。这样一来，就会减少很多不必要的磁盘读写操作，大大提高了整体的构建效率。</p> <img src="/blog/webpack/webpack53.png" data-v-0246861c> <p data-v-0246861c>我们还可以为 webpack-dev-server 命令传入一个 --open 的参数，用于自动唤起浏览器打开我们的应用。打开浏览器过后，此时如果你有两块屏幕，就可以把浏览器放到另外一块屏幕上，然后体验一边编码，一边即时预览的开发环境了。</p> <h4 data-v-0246861c>配置选项</h4> <p data-v-0246861c>Webpack 配置对象中可以有一个叫作 devServer 的属性，专门用来为 webpack-dev-server 提供配置，具体如下：</p> <div class="content__code-Dev3" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
<span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  devServer<span class="token operator">:</span> <span class="token punctuation">{</span>
    contentBase<span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    compress<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    port<span class="token operator">:</span> <span class="token number">9000</span>
    <span class="token comment">// ...</span>
    <span class="token comment">// 详细配置文档：https://webpack.js.org/configuration/dev-server/</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>具体有哪些配置我们就不在这里一一介绍了，你可以在它的官网中找到相对应的说明文档。</p> <p data-v-0246861c>接下来我们来看几个 webpack-dev-server 的常用功能。</p> <h4 data-v-0246861c>静态资源访问</h4> <p data-v-0246861c>webpack-dev-server 默认会将构建结果和输出文件全部作为开发服务器的资源文件，也就是说，只要通过 Webpack 打包能够输出的文件都可以直接被访问到。但是如果你还有一些没有参与打包的静态文件也需要作为开发服务器的资源被访问，那你就需要额外通过配置“告诉” webpack-dev-server。</p> <p data-v-0246861c>具体的方法就是在 webpack-dev-server 的配置对象中添加一个对应的配置。我们回到配置文件中，找到 devServer 属性，它的类型是一个对象，我们可以通过这个 devServer 对象的 contentBase 属性指定额外的静态资源路径。这个 contentBase 属性可以是一个字符串或者数组，也就是说你可以配置一个或者多个路径。具体配置如下：</p> <div class="content__code-Dev4" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  devServer<span class="token operator">:</span> <span class="token punctuation">{</span>
    contentBase<span class="token operator">:</span> <span class="token string">'public'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>我们这里将这个路径设置为项目中的 public 目录。可能有人会有疑问，之前我们在使用插件的时候已经将这个目录通过 copy-webpack-plugin 输出到了输出目录，按照刚刚的说法，所有输出的文件都可以直接被 serve，也就是能直接访问到，按道理应该不需要再作为开发服务器的静态资源路径了。</p> <p data-v-0246861c>确实是这样的，而且如果你能想到这一点，也就证明你真正理解了webpack-dev-server 的文件加载规则。</p> <p data-v-0246861c>但是在实际使用 Webpack 时，我们一般都会把 copy-webpack-plugin 这种插件留在上线前的那一次打包中使用，而开发过程中一般不会用它。因为在开发过程中，我们会频繁重复执行打包任务，假设这个目录下需要拷贝的文件比较多，如果每次都需要执行这个插件，那打包过程开销就会比较大，每次构建的速度也就自然会降低。</p> <p data-v-0246861c>至于如何实现某些插件只在生产模式打包时使用，是额外的话题，所以具体的操作方式会在 10 课时中详细介绍。这里我们先移除 CopyWebpackPlugin，确保这里的打包不会输出 public 目录中的静态资源文件，然后回到命令行再次执行 webpack-dev-server。</p> <p data-v-0246861c>启动过后，我们打开浏览器，这里我们访问的页面文件和 bundle.js 文件均来自于打包结果。我们再尝试访问 favicon.ico，因为这个文件已经没有参与打包了，所以这个文件必然来源于 contentBase 中配置的目录了。</p> <img src="/blog/webpack/webpack54.png" data-v-0246861c> <h3 data-v-0246861c>Proxy 代理</h3> <p data-v-0246861c>由于 webpack-dev-server 是一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上。但是最终上线过后，我们的应用一般又会和后端服务部署到同源地址下。</p> <p data-v-0246861c>那这样就会出现一个非常常见的问题：在实际生产环境中能够直接访问的 API，回到我们的开发环境后，再次访问这些 API 就会产生跨域请求问题。</p> <p data-v-0246861c>可能有人会说，我们可以用跨域资源共享（CORS）解决这个问题。确实如此，如果我们请求的后端 API 支持 CORS，那这个问题就不成立了。但是并不是每种情况下服务端的 API 都支持 CORS。如果前后端应用是同源部署，也就是协议 / 域名 / 端口一致，那这种情况下，根本没必要开启 CORS，所以跨域请求的问题仍然是不可避免的。</p> <p data-v-0246861c>那解决这种开发阶段跨域请求问题最好的办法，就是在开发服务器中配置一个后端 API 的代理服务，也就是把后端接口服务代理到本地的开发服务地址。</p> <p data-v-0246861c>webpack-dev-server 就支持直接通过配置的方式，添加代理服务。接下来，我们来看一下它的具体用法。</p> <p data-v-0246861c>这里我们假定 GitHub 的 API 就是我们应用的后端服务，那我们的目标就是将 GitHub API 代理到本地开发服务器中。</p> <p data-v-0246861c>我们可以先在浏览器中尝试访问其中的一个接口，具体结果如下图：</p> <img src="/blog/webpack/webpack55.png" data-v-0246861c> <p data-v-0246861c>GitHub API 的 Endpoint 都是在根目录下，也就是说不同的 Endpoint 只是 URL 中的路径部分不同，例如 https://api.github.com/users 和 https://api.github.com/events。</p> <p data-v-0246861c>知道 API 地址的规则过后，我们回到配置文件中，在 devServer 配置属性中添加一个 proxy 属性，这个属性值需要是一个对象，对象中的每个属性就是一个代理规则配置。</p> <p data-v-0246861c>属性的名称是需要被代理的请求路径前缀，一般为了辨别，我都会设置为 /api。值是所对应的代理规则配置，我们将代理目标地址设置为 https://api.github.com，具体代码如下：</p> <div class="content__code-Dev5" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  devServer<span class="token operator">:</span> <span class="token punctuation">{</span>
    proxy<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token string">'/api'</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        target<span class="token operator">:</span> <span class="token string">'https://api.github.com'</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>那此时我们请求 http://localhost:8080/api/users ，就相当于请求了 https://api.github.com/api/users。</p> <img src="/blog/webpack/webpack56.png" data-v-0246861c> <p data-v-0246861c>而我们真正希望请求的地址是 https://api.github.com/users，所以对于代理路径开头的 /api 我们要重写掉。我们可以添加一个 pathRewrite 属性来实现代理路径重写，重写规则就是把路径中开头的 /api 替换为空，pathRewrite 最终会以正则的方式来替换请求路径。</p> <div class="content__code-Dev6" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  devServer<span class="token operator">:</span> <span class="token punctuation">{</span>
    proxy<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token string">'/api'</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        target<span class="token operator">:</span> <span class="token string">'https://api.github.com'</span><span class="token punctuation">,</span>
        pathRewrite<span class="token operator">:</span> <span class="token punctuation">{</span>
          <span class="token string">'^/api'</span><span class="token operator">:</span> <span class="token string">''</span> <span class="token comment">// 替换掉代理地址中的 /api</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>这样我们代理的地址就正常了。</p> <img src="/blog/webpack/webpack57.png" data-v-0246861c> <p data-v-0246861c>除此之外，我们还需设置一个 changeOrigin 属性为 true。这是因为默认代理服务器会以我们实际在浏览器中请求的主机名，也就是 localhost:8080 作为代理请求中的主机名。而一般服务器需要根据请求的主机名判断是哪个网站的请求，那 localhost:8080 这个主机名，对于 GitHub 的服务器来说，肯定无法正常请求，所以需要修改。</p> <p data-v-0246861c>将代理规则配置的 changeOrigin 属性设置为 true，就会以实际代理请求地址中的主机名去请求，也就是我们正常请求这个地址的主机名是什么，实际请求 GitHub 时就会设置成什么。</p> <div class="content__code-Dev7" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  devServer<span class="token operator">:</span> <span class="token punctuation">{</span>
    proxy<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token string">'/api'</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        target<span class="token operator">:</span> <span class="token string">'https://api.github.com'</span><span class="token punctuation">,</span>
        pathRewrite<span class="token operator">:</span> <span class="token punctuation">{</span>
          <span class="token string">'^/api'</span><span class="token operator">:</span> <span class="token string">''</span> <span class="token comment">// 替换掉代理地址中的 /api</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        changeOrigin<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token comment">// 确保请求 GitHub 的主机名就是：api.github.com</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>完成以后，打开命令行终端，运行 webpack-dev-server。然后打开浏览器，这里我们直接尝试请求 http://localhost:8080/api/users，得到的就是 GitHub 的用户数据。 因为这个地址已经被代理到了 GitHub 的用户数据接口。</p> <img src="/blog/webpack/webpack58.png" data-v-0246861c> <p data-v-0246861c>此时，我们就可以回到代码中使用代理后的本地同源地址去请求后端接口，而不必担心出现跨域问题了。</p> <div class="content__title-SourceMap" data-v-0246861c><h2 id="webpack-sourcemap"><a href="#webpack-sourcemap" class="header-anchor">#</a> Webpack SourceMap</h2></div> <p data-v-0246861c>通过构建或者编译之类的操作，我们将开发阶段编写的源代码转换为能够在生产环境中运行的代码，这种进步同时也意味着我们实际运行的代码和我们真正编写的代码之间存在很大的差异。</p> <p data-v-0246861c>在这种情况下，如果需要调试我们的应用，或是应用运行的过程中出现意料之外的错误，那我们将无从下手。因为无论是调试还是报错，都是基于构建后的代码进行的，我们只能看到错误信息在构建后代码中具体的位置，却很难直接定位到源代码中对应的位置。</p> <p data-v-0246861c>所以我们今天来聊聊如何借助工具解决现代化前端应用的调试问题。</p> <h3 data-v-0246861c>Source Map 简介</h3> <p data-v-0246861c>Source Map（源代码地图）就是解决此类问题最好的办法，从它的名字就能够看出它的作用：映射转换后的代码与源代码之间的关系。一段转换后的代码，通过转换过程中生成的 Source Map 文件就可以逆向解析得到对应的源代码。</p> <img src="/blog/webpack/webpack59.png" data-v-0246861c> <p data-v-0246861c>目前很多第三方库在发布的文件中都会同时提供一个 .map 后缀的 Source Map 文件。例如 jQuery。我们可以打开它的 Source Map 文件看一下，如下图所示：</p> <img src="/blog/webpack/webpack60.png" data-v-0246861c> <p data-v-0246861c>这是一个 JSON 格式的文件，为了更容易阅读，我提前对该文件进行了格式化。这个 JSON 里面记录的就是转换后和转换前代码之间的映射关系，主要存在以下几个属性：</p> <ul data-v-0246861c><li data-v-0246861c>version 是指定所使用的 Source Map 标准版本；</li> <li data-v-0246861c>sources 中记录的是转换前的源文件名称，因为有可能出现多个文件打包转换为一个文件的情况，所以这里是一个数组；</li> <li data-v-0246861c>names 是源代码中使用的一些成员名称，我们都知道一般压缩代码时会将我们开发阶段编写的有意义的变量名替换为一些简短的字符，这个属性中记录的就是原始的名称；</li> <li data-v-0246861c>mappings 属性，这个属性最为关键，它是一个叫作 base64-VLQ 编码的字符串，里面记录的信息就是转换后代码中的字符与转换前代码中的字符之间的映射关系，具体如下图所示：</li></ul> <img src="/blog/webpack/webpack61.png" data-v-0246861c> <p data-v-0246861c>一般我们会在转换后的代码中通过添加一行注释的方式来去引入 Source Map 文件。不过这个特性只是用于开发调试的，所以最新版本的 jQuery 已经去除了引入 Source Map 的注释，我们需要手动添加回来，这里我们在最后一行添加 //# sourceMappingURL=jquery-3.4.1.min.map，具体效果如下：</p> <img src="/blog/webpack/webpack62.png" data-v-0246861c> <p data-v-0246861c>这样我们在 Chrome 浏览器中如果打开了开发人员工具，它就会自动请求这个文件，然后根据这个文件的内容逆向解析出来源代码，以便于调试。同时因为有了映射关系，所以代码中如果出现了错误，也就能自动定位找到源代码中的位置了。</p> <p data-v-0246861c>我们回到浏览器中，打开开发人员工具，找到 Source 面板，这里我们就能看到转换前的 jQuery 源代码了，具体效果如下图所示：</p> <img src="/blog/webpack/webpack63.png" data-v-0246861c> <p data-v-0246861c>我们还可以添加一个断点，然后刷新页面，进行单步调试，此时调试过程中使用的就是源代码而不是压缩过后的代码，具体效果如下图所示：</p> <img src="/blog/webpack/webpack64.png" data-v-0246861c> <h3 data-v-0246861c>Webpack 中配置 Source Map</h3> <p data-v-0246861c>我们使用 Webpack 打包的过程，同样支持为打包结果生成对应的 Source Map。用法上也很简单，不过它提供了很多不同模式，导致大部分初学者操作起来可能会比较懵。那接下来我们就一起研究一下在 Webpack 中如何开启 Source Map，然后再来了解一下几种不同的 Source Map 模式之间存在哪些差异。</p> <p data-v-0246861c>我们回到配置文件中，这里我们要使用的配置属性叫作 devtool。这个属性就是用来配置开发过程中的辅助工具，也就是与 Source Map 相关的一些功能。我们可以先将这个属性设置为 source-map，具体代码如下：</p> <div class="content__code-SourceMap1" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  devtool<span class="token operator">:</span> <span class="token string">'source-map'</span> <span class="token comment">// source map 设置</span>
<span class="token punctuation">}</span>
</code></pre></div></div> <p data-v-0246861c>然后打开命令行终端，运行 Webpack 打包。打包完成过后，我们打开 dist 目录，此时这个目录中就会生成我们 bundle.js 的 Source Map 文件，与此同时 bundle.js 中也会通过注释引入这个 Source Map 文件，具体如下图所示：</p> <img src="/blog/webpack/webpack65.png" data-v-0246861c> <p data-v-0246861c>我们再回到命令行，通过 serve 工具把打包结果运行起来，然后打开浏览器，再打开开发人员工具，此时我们就可以直接定位到错误所在的位置了。当然如果需要调试，这里也可以直接调试源代码。</p> <img src="/blog/webpack/webpack5.gif" data-v-0246861c> <p data-v-0246861c>如果你只是需要使用 Source Map 的话，操作到这里就已经实现了。但是只会使用这种最普通的 Source Map 模式还远远不够。</p> <p data-v-0246861c>为什么这么说呢？</p> <p data-v-0246861c>因为现阶段 Webpack 支持的 Source Map 模式有很多种。每种模式下所生成的 Source Map 效果和生成速度都不一样。显然，效果好的一般生成速度会比较慢，而生成速度快的一般就没有什么效果。</p> <p data-v-0246861c>那具体哪种 Source Map 模式才是最好呢？这里我们还需要继续去探索。</p> <p data-v-0246861c>Webpack 中的 devtool 配置，除了可以使用 source-map 这个值，它还支持很多其他的选项，具体的我们可以参考文档中的不同模式的对比表。</p> <img src="/blog/webpack/webpack66.png" data-v-0246861c> <p data-v-0246861c>上表分别从初次构建速度、监视模式重新构建速度、是否适合生成环境使用，以及 Source Map 的质量，这四个维度去横向对比了不同的 Source Map 模式之间的差异。</p> <p data-v-0246861c>通过表格中四个维度的对比你可能觉得不够清晰，也不太好理解，所以接下来我们会根据表格中的介绍，通过实际操作来体会这些模式之间的差异，从而带你找到适合自己的最佳实践。</p> <h3 data-v-0246861c>Eval 模式</h3> <p data-v-0246861c>首先来看 eval 模式。在去具体了解 Webpack eval 模式的 Source Map 之前，我们需要先了解一下 JavaScript 中 eval 的一些特点。</p> <p data-v-0246861c>eval 其实指的是 JavaScript 中的一个函数，可以用来运行字符串中的 JavaScript 代码。例如下面这段代码，字符串中的 console.log(&quot;foo~&quot;) 就会作为一段 JavaScript 代码被执行：</p> <div class="content__code-SourceMap2" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> code <span class="token operator">=</span> <span class="token string">'console.log(&quot;foo~&quot;)'</span>
<span class="token function">eval</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span> <span class="token comment">// 将 code 中的字符串作为 JS 代码执行</span>

</code></pre></div></div> <p data-v-0246861c>在默认情况下，这段代码运行在一个临时的虚拟机环境中，我们在控制台中就能够看到：</p> <img src="/blog/webpack/webpack67.png" data-v-0246861c> <p data-v-0246861c>其实我们可以通过 sourceURL 来声明这段代码所属文件路径，接下来我们再来尝试在执行的 JavaScript 字符串中添加一个 sourceURL 的声明，具体操作如下：</p> <img src="/blog/webpack/webpack68.png" data-v-0246861c> <p data-v-0246861c>具体就是在 eval 函数执行的字符串代码中添加一个注释，注释的格式：# sourceURL=./path/to/file.js，这样的话这段代码就会执行在指定路径下。</p> <p data-v-0246861c>在了解了 eval 函数可以通过 sourceURL 指定代码所属文件路径这个特点过后，我们再来尝试使用这个叫作 eval 模式的 Source Map。</p> <p data-v-0246861c>我们回到 Webpack 的配置文件中，将 devtool 属性设置为 eval，具体如下：</p> <div class="content__code-SourceMap3" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  devtool<span class="token operator">:</span> <span class="token string">'eval'</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>然后我们回到命令行终端再次运行打包，打包过后，找到生成的 bundle.js 文件，你会发现每个模块中的代码都被包裹到了一个 eval 函数中，而且每段模块代码的最后都会通过 sourceURL 的方式声明这个模块对应的源文件路径，具体如下：</p> <img src="/blog/webpack/webpack69.png" data-v-0246861c> <p data-v-0246861c>那此时如果我们回到浏览器运行这里的 bundle.js，一旦出现错误，浏览器的控制台就可以定位到具体是哪个模块中的代码，具体效果如下：</p> <img src="/blog/webpack/webpack70.png" data-v-0246861c> <p data-v-0246861c>但是当你点击控制台中的文件名打开这个文件后，看到的却是打包后的模块代码，而并非我们真正的源代码，具体如下：</p> <img src="/blog/webpack/webpack71.png" data-v-0246861c> <p data-v-0246861c>综上所述，在 eval 模式下，Webpack 会将每个模块转换后的代码都放到 eval 函数中执行，并且通过 sourceURL 声明对应的文件路径，这样浏览器就能知道某一行代码到底是在源代码的哪个文件中。</p> <p data-v-0246861c>因为在 eval 模式下并不会生成 Source Map 文件，所以它的构建速度最快，但是缺点同样明显：它只能定位源代码的文件路径，无法知道具体的行列信息。</p> <h3 data-v-0246861c>案例准备工作</h3> <p data-v-0246861c>为了可以更好地对比不同模式的 Source Map 之间的差异，这里我们使用一个新项目，同时创建出不同模式下的打包结果，通过具体实验来横向对比它们之间的差异。</p> <p data-v-0246861c>在这个案例中，项目中只有两个 JS 模块，在 main.js 中，我故意加入了一个运行时错误，具体项目结构和部分代码如下：</p> <div class="content__code-SourceMap4" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code>└─ <span class="token number">07</span><span class="token operator">-</span>devtool<span class="token operator">-</span>diff
   ├── src
   │   ├── heading<span class="token punctuation">.</span>js
   │   └── main<span class="token punctuation">.</span>js
   ├── <span class="token keyword">package</span><span class="token punctuation">.</span>json
   └── webpack<span class="token punctuation">.</span>config<span class="token punctuation">.</span>js

</code></pre></div></div> <div class="content__code-SourceMap5" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./src/main.js</span>
<span class="token keyword">import</span> createHeading <span class="token keyword">from</span> <span class="token string">'./heading.js'</span>
<span class="token keyword">const</span> heading <span class="token operator">=</span> <span class="token function">createHeading</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>heading<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'main.js running'</span><span class="token punctuation">)</span>
<span class="token comment">// 运行时错误</span>
console<span class="token punctuation">.</span><span class="token function">log111</span><span class="token punctuation">(</span><span class="token string">'main.js running'</span><span class="token punctuation">)</span>

</code></pre></div></div> <p data-v-0246861c>然后我们打开 Webpack 的配置文件，在这个文件中定义一个数组，数组中每一个成员都是 devtool 配置取值的一种，具体代码如下：</p> <div class="content__code-SourceMap6" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> allDevtoolModes <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token string">'eval'</span><span class="token punctuation">,</span>
  <span class="token string">'cheap-eval-source-map'</span><span class="token punctuation">,</span>
  <span class="token string">'cheap-module-eval-source-map'</span><span class="token punctuation">,</span>
  <span class="token string">'eval-source-map'</span><span class="token punctuation">,</span>
  <span class="token string">'cheap-source-map'</span><span class="token punctuation">,</span>
  <span class="token string">'cheap-module-source-map'</span><span class="token punctuation">,</span>
  <span class="token string">'inline-cheap-source-map'</span><span class="token punctuation">,</span>
  <span class="token string">'inline-cheap-module-source-map'</span><span class="token punctuation">,</span>
  <span class="token string">'source-map'</span><span class="token punctuation">,</span>
  <span class="token string">'inline-source-map'</span><span class="token punctuation">,</span>
  <span class="token string">'hidden-source-map'</span><span class="token punctuation">,</span>
  <span class="token string">'nosources-source-map'</span>
<span class="token punctuation">]</span>

</code></pre></div></div> <p data-v-0246861c>在上一课时中我们也提到过，Webpack 的配置文件除了可以导出一个配置对象，还可以导出一个数组，数组中每一个元素就是一个单独的打包配置，那这样就可以在一次打包过程中同时执行多个打包任务。</p> <p data-v-0246861c>例如，我们这里导出一个数组，然后在这个数组中添加两个打包配置，它们的 entry 都是 src 中的 main.js，不过它们输出的文件名不同，具体代码如下：</p> <div class="content__code-SourceMap7" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
    entry<span class="token operator">:</span> <span class="token string">'./src/main.js'</span><span class="token punctuation">,</span>
    output<span class="token operator">:</span> <span class="token punctuation">{</span>
      filename<span class="token operator">:</span> <span class="token string">'output1.js'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    entry<span class="token operator">:</span> <span class="token string">'./src/main.js'</span><span class="token punctuation">,</span>
    output<span class="token operator">:</span> <span class="token punctuation">{</span>
      filename<span class="token operator">:</span> <span class="token string">'output2.js'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">]</span>

</code></pre></div></div> <p data-v-0246861c>这么配置的话，再次打包就会有两个打包子任务工作，我们的 dist 中生成的结果也就是两个文件，具体结果如下：</p> <img src="/blog/webpack/webpack72.png" data-v-0246861c> <p data-v-0246861c>了解了 Webpack 这种配置用法过后，我们再次回到配置文件中，遍历刚刚定义的数组，为每一个模式单独创建一个打包配置，这样就可以一次性生成所有模式下的不同结果，这比我们一个一个去试验的效率更高，而且对比起来也更明显。</p> <p data-v-0246861c>具体配置代码如下：</p> <div class="content__code-SourceMap8" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
<span class="token keyword">const</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'html-webpack-plugin'</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> allModes <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token string">'eval'</span><span class="token punctuation">,</span>
  <span class="token string">'cheap-eval-source-map'</span><span class="token punctuation">,</span>
  <span class="token string">'cheap-module-eval-source-map'</span><span class="token punctuation">,</span>
  <span class="token string">'eval-source-map'</span><span class="token punctuation">,</span>
  <span class="token string">'cheap-source-map'</span><span class="token punctuation">,</span>
  <span class="token string">'cheap-module-source-map'</span><span class="token punctuation">,</span>
  <span class="token string">'inline-cheap-source-map'</span><span class="token punctuation">,</span>
  <span class="token string">'inline-cheap-module-source-map'</span><span class="token punctuation">,</span>
  <span class="token string">'source-map'</span><span class="token punctuation">,</span>
  <span class="token string">'inline-source-map'</span><span class="token punctuation">,</span>
  <span class="token string">'hidden-source-map'</span><span class="token punctuation">,</span>
  <span class="token string">'nosources-source-map'</span>
<span class="token punctuation">]</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> allModes<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
  devtool<span class="token operator">:</span> item<span class="token punctuation">,</span>
  mode<span class="token operator">:</span> <span class="token string">'none'</span><span class="token punctuation">,</span>
  entry<span class="token operator">:</span> <span class="token string">'./src/main.js'</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    filename<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">js/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>item<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.js</span><span class="token template-punctuation string">`</span></span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  module<span class="token operator">:</span> <span class="token punctuation">{</span>
    rules<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.js$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>
        use<span class="token operator">:</span> <span class="token punctuation">{</span>
          loader<span class="token operator">:</span> <span class="token string">'babel-loader'</span><span class="token punctuation">,</span>
          options<span class="token operator">:</span> <span class="token punctuation">{</span>
            presets<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'@babel/preset-env'</span><span class="token punctuation">]</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      filename<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>item<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.html</span><span class="token template-punctuation string">`</span></span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

</code></pre></div></div> <p data-v-0246861c>这里简单解释一下这个配置中的部分配置用意：</p> <ul data-v-0246861c><li data-v-0246861c>定义 devtool 属性，它就是当前所遍历的模式名称；</li> <li data-v-0246861c>将 mode 设置为 none，确保 Webpack 内部不做额外处理；</li> <li data-v-0246861c>设置打包入口和输出文件名称，打包入口都是 src/main.js，输出文件名称我们就放在 js 目录中，以模式名称命名，至于为什么放在单独目录中，你可以在接下来的内容中找到答案；</li> <li data-v-0246861c>为 js 文件配置一个 babel-loader，配置 babel-loader 的目的是稍后能够辨别其中一类模式的差异。</li> <li data-v-0246861c>配置一个 html-webpack-plugin，也就是为每个打包任务生成一个 HTML 文件，通过前面的内容，我们知道 html-webpack-plugin 可以生成使用打包结果的 HTML，接下来我们就是通过这些 HTML 在浏览器中进行尝试。</li></ul> <p data-v-0246861c>配置完成以后，我们再次回到命令行终端运行打包，那此时这个打包过程就自动生成了不同模式下的打包结果，具体结果如下图所示：</p> <img src="/blog/webpack/webpack73.png" data-v-0246861c> <p data-v-0246861c>然后我们通过 serve 把结果运行起来，打开浏览器，此时我们能够在页面中看到每一个使用不同模式 Source Map 的 HTML 文件，具体如下图：</p> <img src="/blog/webpack/webpack74.png" data-v-0246861c> <p data-v-0246861c>那如果刚刚没有把 JS 文件输出到单独目录中，这里的文件就会非常多，导致 HTML 文件寻找起来特别麻烦。</p> <h3 data-v-0246861c>不同模式的对比</h3> <p data-v-0246861c>有了不同模式下生成的结果过后，我们就可以仔细去对比不同 Source Map 模式之间的具体差异了。其实也没必要真的一个一个去看，这里我先带你看几个比较典型的模式，然后找出它们的规律，这样你就再也不用头大了。</p> <p data-v-0246861c>首先 eval 模式，这个模式刚刚已经单独看过了，它就是将模块代码放到 eval 函数中执行，并且通过 sourceURL 标注所属文件路径，在这种模式下没有 Source Map 文件，所以只能定位是哪个文件出错，具体效果如下图：</p> <img src="/blog/webpack/webpack75.png" data-v-0246861c> <p data-v-0246861c>然后我们再来看一个叫作 eval-source-map 的模式，这个模式也是使用 eval 函数执行模块代码，不过这里有所不同的是，eval-source-map 模式除了定位文件，还可以定位具体的行列信息。相比于 eval 模式，它能够生成 Source Map 文件，可以反推出源代码，具体效果如下：</p> <img src="/blog/webpack/webpack6.gif" data-v-0246861c> <p data-v-0246861c>紧接着我们再来看一个叫作 cheap-eval-source-map 的模式。根据这个模式的名字就能推断出一些信息，它就是在 eval-source-map 基础上添加了一个 cheap，也就是便宜的，或者叫廉价的。用计算机行业的常用说法，就是阉割版的 eval-source-map，因为它虽然也生成了 Source Map 文件，但是这种模式下的 Source Map 只能定位到行，而定位不到列，所以在效果上差了一点点，但是构建速度会提升很多，具体效果如下图：</p> <img src="/blog/webpack/webpack7.gif" data-v-0246861c> <p data-v-0246861c>接下来再看一个叫作 cheap-module-eval-source-map 的模式。慢慢地我们就发现 Webpack 中这些模式的名字不是随意的，好像都有某种规律。这里就是在 cheap-eval-source-map 的基础上多了一个 module，具体效果如下图：</p> <img src="/blog/webpack/webpack8.gif" data-v-0246861c> <p data-v-0246861c>这种模式同样也只能定位到行，它的特点相比于 cheap-eval-source-map 并不明显 ，如果你没有发现差异，可以再去看看上一种模式，仔细做一个对比，相信对比之后你会发现，cheap-module-eval-source-map 中定位的源代码与我们编写的源代码是一模一样的，而 cheap-eval-source-map 模式中定位的源代码是经过 ES6 转换后的结果，具体对比如下（左图是 cheap-eval-source-map）：</p> <img src="/blog/webpack/webpack76.png" data-v-0246861c> <p data-v-0246861c>这也是为什么之前我要给 JS 文件配置 Loader 的原因：因为这种名字中带有 module 的模式，解析出来的源代码是没有经过 Loader 加工的，而名字中不带 module 的模式，解析出来的源代码是经过 Loader 加工后的结果。也就是说如果我们想要还原一模一样的源代码，就需要选择 cheap-module-eval-source-map 模式。</p> <p data-v-0246861c>了解了这些过后，你基本上就算通盘了解了 Webpack 中所有 Source Map 模式之间的差异，因为其它的模式无外乎就是这几个特点的排列组合罢了。</p> <p data-v-0246861c>例如，我们再来看一个 cheap-source-map 模式，这个模式的名字中没有 eval，意味着它没用 eval 执行代码，而名字中没有 module，意味着 Source Map 反推出来的是 Loader 处理后的代码，有 cheap 表示只能定位源代码的行号。</p> <p data-v-0246861c>那以上就是我们在日常开发过程中经常用到的几种 Source Map 模式，你在尝试的时候一定要注意：找规律很重要。</p> <p data-v-0246861c>除此之外，还有几个特殊一点的模式，我们单独介绍一下：</p> <ul data-v-0246861c><li data-v-0246861c>inline-source-map 模式</li></ul> <p data-v-0246861c>它跟普通的 source-map 效果相同，只不过这种模式下 Source Map 文件不是以物理文件存在，而是以 data URLs 的方式出现在代码中。我们前面遇到的 eval-source-map 也是这种 inline 的方式。</p> <ul data-v-0246861c><li data-v-0246861c>hidden-source-map 模式</li></ul> <p data-v-0246861c>在这个模式下，我们在开发工具中看不到 Source Map 的效果，但是它也确实生成了 Source Map 文件，这就跟 jQuery 一样，虽然生成了 Source Map 文件，但是代码中并没有引用对应的 Source Map 文件，开发者可以自己选择使用。</p> <ul data-v-0246861c><li data-v-0246861c>nosources-source-map 模式</li></ul> <p data-v-0246861c>在这个模式下，我们能看到错误出现的位置（包含行列位置），但是点进去却看不到源代码。这是为了保护源代码在生产环境中不暴露。</p> <h4 data-v-0246861c>总结</h4> <p data-v-0246861c>虽然 Webpack 中支持各种各样的 Source Map 模式，但一般应用开发时我们只会用到其中的几种。其实在我们掌握了它们的特点过后，选择上就没有什么需要纠结的地方了。</p> <p data-v-0246861c>这里再分享一下我个人开发时的选择，供你参考。</p> <p data-v-0246861c>首先开发过程中（开发环境），我会选择 cheap-module-eval-source-map，原因有以下三点：</p> <ul data-v-0246861c><li data-v-0246861c>我使用框架的情况会比较多，以 React 和 Vue.js 为例，无论是 JSX 还是 vue 单文件组件，Loader 转换后差别都很大，我需要调试 Loader 转换前的源代码。</li> <li data-v-0246861c>一般情况下，我编写的代码每行不会超过 80 个字符，对我而言能够定位到行到位置就够了，而且省略列信息还可以提升构建速度。</li> <li data-v-0246861c>虽然在这种模式下启动打包会比较慢，但大多数时间内我使用的 webpack-dev-server 都是在监视模式下重新打包，它重新打包的速度非常快。</li></ul> <p data-v-0246861c>综上所述，开发环境下我会选择 cheap-module-eval-source-map。</p> <p data-v-0246861c>至于发布前的打包，也就是生产环境的打包，我选择 none，它不会生成 Source Map。原因很简单：</p> <ul data-v-0246861c><li data-v-0246861c>首先，Source Map 会暴露我的源代码到生产环境。如果没有控制 Source Map 文件访问权限的话，但凡是有点技术的人都可以很容易的复原项目中涉及的绝大多数源代码，这非常不合理也不安全，我想很多人可能都忽略了这个问题。</li> <li data-v-0246861c>其次，调试应该是开发阶段的事情，你应该在开发阶段就尽可能找到所有问题和隐患，而不是到了生产环境中再去全民公测。如果你对自己的代码实在没有信心，我建议你选择 nosources-source-map 模式，这样出现错误可以定位到源码位置，也不至于暴露源码。</li></ul> <p data-v-0246861c>当然这些选择不是绝对的，我们理解这些模式之间的差异的目的，就是为了可以在不同环境中快速选择一个合适的模式，而不是寻求一个通用法则，开发行业也根本不会有绝对的通用法则！</p> <p data-v-0246861c>除此之外，我还要强调一点，Source Map 并不是 Webpack 特有的功能，它们两者的关系只是：Webpack 支持 Source Map。大多数的构建或者编译工具也都支持 Source Map。希望你不要把它们二者捆绑到一起，混为一谈。</p> <div class="content__title-HMR" data-v-0246861c><h2 id="webpack热替换-hmr-机制"><a href="#webpack热替换-hmr-机制" class="header-anchor">#</a> Webpack热替换（HMR）机制</h2></div> <p data-v-0246861c>使用 Webpack Dev Server 就可以让我们在开发过程中专注编码，因为它可以自动监视我们代码的变化然后自动进行打包，最后通过自动刷新的方式同步到浏览器以便于我们即时预览，效果如下：</p> <img src="/blog/webpack/webpack9.gif" data-v-0246861c> <h3 data-v-0246861c>自动刷新的问题</h3> <p data-v-0246861c>但是当你实际去使用 Webpack Dev Server 自动刷新的特性去完成具体的开发任务时，你会发现还是有一些不舒服的地方。</p> <p data-v-0246861c>例如，这里是一个编辑器应用，我想要即时调试这个编辑器中内容文本的样式。那正常的操作肯定是我先尝试在编辑器里面去添加一些文本，作为展示样例，再回到开发工具中，找到控制编辑器样式的 CSS 文件，然后进行编辑，具体操作如下：</p> <img src="/blog/webpack/webpack10.gif" data-v-0246861c> <p data-v-0246861c>那这时候我们就能够发现问题了：当我们修改完编辑器文本对应的样式过后，原本想着可以即时看到最新的界面效果，但是这时编辑器中的内容却没有了。</p> <p data-v-0246861c>这时就不得不再次回到应用中再来添加一些测试文本，查看样式效果。那如果修改后还是对样式不满意的话，你还需要继续调整样式，调整之后又会面临文本内容丢失的问题。那久而久之你就会发现，自动刷新这个功能还是有点鸡肋，并没有想象的那么好用。</p> <p data-v-0246861c>出现这个问题的原因，是因为我们每次修改完代码，Webpack 都可以监视到变化，然后自动打包，再通知浏览器自动刷新，一旦页面整体刷新，那页面中的任何操作状态都将会丢失，所以才会出现我们上面所看到的情况。</p> <p data-v-0246861c>但是聪明的你总会想到一些应对方法，例如：</p> <ul data-v-0246861c><li data-v-0246861c>回到代码中先写死一个文本内容到编辑器中，这样即便页面刷新，也不会丢失。</li> <li data-v-0246861c>通过代码将编辑器中的内容及时保存到 LocalStorage 之类的地方，刷新过后再取回来。</li></ul> <p data-v-0246861c>总之就是：你有问题，我有办法。</p> <p data-v-0246861c>确实这些都是好办法，但是也存在一些不足，因为它们都是典型的“有漏补漏”的操作，并不能根治自动刷新导致页面状态丢失问题，而且这些方法都需要去编写一些与业务本身无关的辅助代码，不利于维护。</p> <p data-v-0246861c>更好的办法自然是能够实现在页面不刷新的情况下，代码也可以及时的更新到浏览器的页面中，重新执行，避免页面状态丢失。针对这个需求，Webpack 同样可以满足。</p> <h3 data-v-0246861c>模块热替换（HMR）</h3> <p data-v-0246861c>HMR 全称 Hot Module Replacement，翻译过来叫作“模块热替换”或“模块热更新”。</p> <p data-v-0246861c>计算机行业经常听到一个叫作热拔插的名词，指的就是我们可以在一个正在运行的机器上随时插拔设备，机器的运行状态不会受插拔的影响，而且插上去的设备可以立即工作，例如我们电脑上的 USB 端口就可以热拔插。</p> <p data-v-0246861c>模块热替换中的“热”和这里提到的“热拔插”是相同的意思，都是指在运行过程中的即时变化。</p> <p data-v-0246861c>Webpack 中的模块热替换，指的是我们可以在应用运行过程中，实时的去替换掉应用中的某个模块，而应用的运行状态不会因此而改变。例如，我们在应用运行过程中修改了某个模块，通过自动刷新会导致整个应用的整体刷新，那页面中的状态信息都会丢失；而如果使用的是 HMR，就可以实现只将修改的模块实时替换至应用中，不必完全刷新整个应用。</p> <p data-v-0246861c>这里我们可以先来对比一下使用热更新和使用自动刷新两种方式之间的体验差异，我们尝试在项目中开启 HMR 特性，具体效果如下图所示：</p> <img src="/blog/webpack/webpack11.gif" data-v-0246861c> <p data-v-0246861c>有了 HMR 支持后，我们同样先在页面中随意添加一些内容，也就是为页面制造一些运行状态，然后我们回到开发工具中，再来尝试修改文本的样式，保存过后页面并没有整体刷新，而且我们能立即看到最新的样式。这种体验相对于自动刷新会友好很多。</p> <p data-v-0246861c>HMR 对于项目中其他代码文件的修改，也可以有相同的热更新体验。你可以再去尝试修改一下 JS 文件，保存过后，浏览器中同样不会刷新页面，而是直接执行了你刚刚修改的这个模块，具体效果如下：</p> <img src="/blog/webpack/webpack12.gif" data-v-0246861c> <p data-v-0246861c>不仅如此，对于非文本文件同样也可以使用热更新。例如这个案例中显示的 Logo 图片，如果你在外部修改了它，同样也可以及时更新到浏览器中。</p> <p data-v-0246861c>那这就是 HMR 的作用和体验，HMR 可以算是 Webpack 中最为强大的特性之一，而且也是最受欢迎的特性，因为它确实极大程度地提高了开发者的工作效率。</p> <h3 data-v-0246861c>开启 HMR</h3> <p data-v-0246861c>对于 HMR 这种强大的功能而言，使用起来并不算特别复杂。接下来我们就一起了解一下如何去实现项目中的 HMR。</p> <p data-v-0246861c>HMR 已经集成在了 webpack 模块中了，所以不需要再单独安装什么模块。</p> <p data-v-0246861c>使用这个特性最简单的方式就是，在运行 webpack-dev-server 命令时，通过 --hot 参数去开启这个特性。</p> <p data-v-0246861c>或者也可以在配置文件中通过添加对应的配置来开启这个功能。那我们这里打开配置文件，这里需要配置两个地方：</p> <ul data-v-0246861c><li data-v-0246861c>首先需要将 devServer 对象中的 hot 属性设置为 true；</li> <li data-v-0246861c>然后需要载入一个插件，这个插件是 webpack 内置的一个插件，所以我们先导入 webpack 模块，有了这个模块过后，这里使用的是一个叫作 HotModuleReplacementPlugin 的插件。</li></ul> <p data-v-0246861c>具体配置代码如下：</p> <div class="content__code-HMR1" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
<span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  devServer<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 开启 HMR 特性，如果资源不支持 HMR 会 fallback 到 live reloading</span>
    hot<span class="token operator">:</span> <span class="token boolean">true</span>
    <span class="token comment">// 只使用 HMR，不会 fallback 到 live reloading</span>
    <span class="token comment">// hotOnly: true</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token comment">// ...</span>
    <span class="token comment">// HMR 特性所需要的插件</span>
    <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>HotModuleReplacementPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>配置完成以后，我们打开命令行终端，运行 webpack-dev-server，启动开发服务器。那接下来你就可以来体验 HMR 了。</p> <p data-v-0246861c>我们回到开发工具中，这里我们先来尝试修改一下 CSS 文件。样式文件修改保存过后，确实能够以不刷新的形式更新到页面中。</p> <p data-v-0246861c>然后我们再来尝试一下修改 JS 文件。保存过后你会发现，这里的页面依然自动刷新了，好像并没有之前所说 HMR 的体验。</p> <p data-v-0246861c>为了再次确认，你可以尝试先在页面中的编辑器里随意添加一些文字，然后修改代码，保存过后你就会看到页面自动刷新，页面中的状态也就丢失了，具体效果如下图：</p> <img src="/blog/webpack/webpack13.gif" data-v-0246861c> <p data-v-0246861c>那这是为什么呢？为什么 CSS 文件热替换没出现问题，而到了 JS 这块就不行了呢？我们又该如何去实现其他类型模块的热替换呢？</p> <h3 data-v-0246861c>HMR 的疑问</h3> <p data-v-0246861c>通过之前的体验我们发现模块热替换确实提供了非常友好的体验，但是当我们自己去尝试开启 HMR 过后，效果却不尽如人意。</p> <p data-v-0246861c>很明显：HMR 并不像 Webpack 的其他特性一样可以开箱即用，需要有一些额外的操作。</p> <p data-v-0246861c>具体来说，Webpack 中的 HMR 需要我们手动通过代码去处理，当模块更新过后该，如何把更新后的模块替换到页面中。</p> <p data-v-0246861c>Q1：可能你会问，为什么我们开启 HMR 过后，样式文件的修改就可以直接热更新呢？我们好像也没有手动处理样式模块的更新啊？</p> <p data-v-0246861c>A1：这是因为样式文件是经过 Loader 处理的，在 style-loader 中就已经自动处理了样式文件的热更新，所以就不需要我们额外手动去处理了。</p> <p data-v-0246861c>Q2：那你可能会想，凭什么样式就可以自动处理，而我们的脚本就需要自己手动处理呢？</p> <p data-v-0246861c>A2：这个原因也很简单，因为样式模块更新过后，只需要把更新后的 CSS 及时替换到页面中，它就可以覆盖掉之前的样式，从而实现更新。</p> <p data-v-0246861c>而我们所编写的 JavaScript 模块是没有任何规律的，你可能导出的是一个对象，也可能导出的是一个字符串，还可能导出的是一个函数，使用时也各不相同。所以 Webpack 面对这些毫无规律的 JS 模块，根本不知道该怎么处理更新后的模块，也就无法直接实现一个可以通用所有情况的模块替换方案。</p> <p data-v-0246861c>那这就是为什么样式文件可以直接热更新，而 JS 文件更新后页面还是回退到自动刷新的原因。</p> <p data-v-0246861c>Q3：那可能还有一些平时使用 vue-cli 或者 create-react-app 这种框架脚手架工具的人会说，“我的项目就没有手动处理，JavaScript 代码照样可以热替换，也没你说的那么麻烦”。</p> <p data-v-0246861c>A3：这是因为你使用的是框架，使用框架开发时，我们项目中的每个文件就有了规律，例如 React 中要求每个模块导出的必须是一个函数或者类，那这样就可以有通用的替换办法，所以这些工具内部都已经帮你实现了通用的替换操作，自然就不需要手动处理了。</p> <p data-v-0246861c>当然如果你之前没有接触过这样的工具，那你可以忽略这一条，这也并不影响后面的理解。</p> <p data-v-0246861c>综上所述，我们还是需要自己手动通过代码来处理，当 JavaScript 模块更新过后，该如何将更新后的模块替换到页面中。</p> <h3 data-v-0246861c>HMR APIs</h3> <p data-v-0246861c>HotModuleReplacementPlugin 为我们的 JavaScript 提供了一套用于处理 HMR 的 API，我们需要在我们自己的代码中，使用这套 API 将更新后的模块替换到正在运行的页面中。</p> <p data-v-0246861c>接下来我们回到代码中，尝试通过 HMR 的 API 手动处理模块更新后的热替换。</p> <p data-v-0246861c>这里我们打开 main.js，具体代码如下：</p> <div class="content__code-HMR2" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./src/main.js</span>
<span class="token keyword">import</span> createEditor <span class="token keyword">from</span> <span class="token string">'./editor'</span>
<span class="token keyword">import</span> logo <span class="token keyword">from</span> <span class="token string">'./icon.png'</span>
<span class="token keyword">import</span> <span class="token string">'./global.css'</span>

<span class="token keyword">const</span> img <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
img<span class="token punctuation">.</span>src <span class="token operator">=</span> logo
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span>

<span class="token keyword">const</span> editor <span class="token operator">=</span> <span class="token function">createEditor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>editor<span class="token punctuation">)</span>

</code></pre></div></div> <p data-v-0246861c>这是 Webpack 打包的入口文件，正常情况下，在这个文件中会加载一些其他模块。正是因为在 main.js 中使用了这些模块，所以一旦这些模块更新了过后，我们在 main.js 中就必须重新使用更新后的模块。</p> <p data-v-0246861c>所以说，我们需要在这个文件中添加一些额外的代码，去处理它所依赖的这些模块更新后的热替换逻辑。</p> <p data-v-0246861c>对于开启 HMR 特性的环境中，我们可以访问到全局的 module 对象中的 hot 成员，这个成员是一个对象，这个对象就是 HMR API 的核心对象，它提供了一个 accept 方法，用于注册当某个模块更新后的处理函数。accept 方法第一个参数接收的就是所监视的依赖模块路径，第二个参数就是依赖模块更新后的处理函数。</p> <p data-v-0246861c>那我们这里先尝试注册 ./editor 模块更新过后的处理函数，第一个参数就是 editor 模块的路径，第二个参数则需要我们传入一个函数，然后在这个函数中打印一个消息，具体代码如下：</p> <div class="content__code-HMR3" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./main.js</span>

<span class="token comment">// ... 原本的业务代码</span>

module<span class="token punctuation">.</span>hot<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token string">'./editor'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 当 ./editor.js 更新，自动执行此函数</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'editor 更新了～～'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div></div> <p data-v-0246861c>完成过后，我们打开命令行终端再次启动 webpack-dev-server 命令，然后回到浏览器，打开开发人员工具。</p> <p data-v-0246861c>此时，如果我们修改了 editor 模块，保存过后，浏览器的控制台中就会自动打印我们上面在代码中添加的消息，而且浏览器也不会自动刷新了。</p> <p data-v-0246861c>那也就是说一旦这个模块的更新被我们手动处理了，就不会触发自动刷新；反之，如果没有手动处理，热替换会自动 fallback（回退）到自动刷新。</p> <h3 data-v-0246861c>JS 模块热替换</h3> <p data-v-0246861c>了解了这个 HMR API 的作用过后，接下来需要考虑的就是：具体如何实现 editor 模块的热替换。</p> <p data-v-0246861c>这个模块导出的是一个 createEditor 函数，我们先正常把它打印到控制台，然后在模块更新后的处理函数中再打印一次，具体代码如下：</p> <div class="content__code-HMR4" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./main.js</span>
<span class="token keyword">import</span> createEditor <span class="token keyword">from</span> <span class="token string">'./editor'</span>

<span class="token comment">// ... 原本的业务代码</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>createEditor<span class="token punctuation">)</span>
module<span class="token punctuation">.</span>hot<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token string">'./editor'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>createEditor<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div></div> <p data-v-0246861c>这个时候如果你再次修改 editor 模块，保存过后，你就会发现当模块更新后，我们这里拿到的 createEditor 函数也就更新为了最新的结果，具体结果如下图所示：</p> <img src="/blog/webpack/webpack77.png" data-v-0246861c> <p data-v-0246861c>既然模块文件更新后 createEditor 函数可以自动更新，那剩下的就好办了。我们这里使用 createEditor 函数是用来创建一个界面元素的，那模块一旦更新了，这个元素也就需要重新创建，所以我们这里先移除原来的元素，然后再调用更新后的 createEditor 函数，创建一个新的元素追加到页面中，具体代码如下：</p> <div class="content__code-HMR5" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./main.js</span>
<span class="token keyword">import</span> createEditor <span class="token keyword">from</span> <span class="token string">'./editor'</span>

<span class="token keyword">const</span> editor <span class="token operator">=</span> <span class="token function">createEditor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>editor<span class="token punctuation">)</span>

<span class="token comment">// ... 原本的业务代码</span>

<span class="token comment">// HMR -----------------------------------</span>
module<span class="token punctuation">.</span>hot<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token string">'./editor'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>editor<span class="token punctuation">)</span> <span class="token comment">// 移除之前创建的元素</span>
  <span class="token keyword">const</span> newEditor <span class="token operator">=</span> <span class="token function">createEditor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 用新模块创建新元素</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>newEditor<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div></div> <p data-v-0246861c>但如果只是这样实现的话，一次热替换结束后，第二次就没法再实现热替换了。因为第二次执行这个函数的时候，editor 变量指向的元素已经在上一次执行时被移除了，所以我们这里还应该记录下来每次热替换创建的新元素，以便于下一次热替换时的操作，具体代码如下：</p> <div class="content__code-HMR6" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./main.js</span>
<span class="token keyword">import</span> createEditor <span class="token keyword">from</span> <span class="token string">'./editor'</span>

<span class="token keyword">const</span> editor <span class="token operator">=</span> <span class="token function">createEditor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>editor<span class="token punctuation">)</span>

<span class="token comment">// ... 原本的业务代码</span>

<span class="token comment">// HMR -----------------------------------</span>
<span class="token keyword">let</span> lastEditor <span class="token operator">=</span> editor
module<span class="token punctuation">.</span>hot<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token string">'./editor'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>lastEditor<span class="token punctuation">)</span> <span class="token comment">// 移除之前创建的元素</span>
  lastEditor <span class="token operator">=</span> <span class="token function">createEditor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 用新模块创建新元素</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>lastEditor<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div></div> <p data-v-0246861c>完成以后，我们再来尝试修改 editor 模块，此时就应该是正常的热替换效果了，具体效果如下图：</p> <img src="/blog/webpack/webpack14.gif" data-v-0246861c> <h3 data-v-0246861c>热替换的状态保持</h3> <p data-v-0246861c>此时，如果我们尝试在界面上输入一些内容（形成页面操作状态），然后回到代码中再次修改 editor 模块。那此时你仍然会发现问题，由于热替换时，把界面上之前的编辑器元素移除了，替换成了一个新的元素，所以页面上之前的状态同样会丢失。</p> <p data-v-0246861c>这也就证明我们的热替换操作还需要改进，我们必须在替换时把状态保留下来。</p> <p data-v-0246861c>我们回到 main.js 中，要想保留这个状态也很简单，就是在替换前先拿到编辑器中的内容，然后替换后在放回去就行了。那因为我这里使用的是可编辑元素，而不是文本框，所以我们需要通过 innerHTML 拿到之前编辑的内容，然后设置到更新后创建的新元素中，具体代码如下：</p> <div class="content__code-HMR7" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./main.js</span>
<span class="token keyword">import</span> createEditor <span class="token keyword">from</span> <span class="token string">'./editor'</span>

<span class="token keyword">const</span> editor <span class="token operator">=</span> <span class="token function">createEditor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>editor<span class="token punctuation">)</span>

<span class="token comment">// ... 原本的业务代码</span>

<span class="token comment">// HMR --------------------------------</span>
<span class="token keyword">let</span> lastEditor <span class="token operator">=</span> editor
module<span class="token punctuation">.</span>hot<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token string">'./editor'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 当 editor.js 更新，自动执行此函数</span>
  <span class="token comment">// 临时记录更新前编辑器内容</span>
  <span class="token keyword">const</span> value <span class="token operator">=</span> lastEditor<span class="token punctuation">.</span>innerHTML
  <span class="token comment">// 移除更新前的元素</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>lastEditor<span class="token punctuation">)</span>
  <span class="token comment">// 创建新的编辑器</span>
  <span class="token comment">// 此时 createEditor 已经是更新过后的函数了</span>
  lastEditor <span class="token operator">=</span> <span class="token function">createEditor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// 还原编辑器内容</span>
  lastEditor<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> value
  <span class="token comment">// 追加到页面</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>lastEditor<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div></div> <p data-v-0246861c>这样就可以解决界面状态保存的问题了。</p> <p data-v-0246861c>至此，对于 editor 模块的热替换逻辑就算是全部实现了。通过这个过程你应该能够发现，为什么 Webpack 需要我们自己处理 JS 模块的热更新了：因为不同的模块有不同的情况，不同的情况，在这里处理时肯定也是不同的。就好像，我们这里是一个文本编辑器应用，所以需要保留状态，如果不是这种类型那就不需要这样做。所以说 Webpack 没法提供一个通用的 JS 模块替换方案。</p> <h3 data-v-0246861c>图片模块热替换</h3> <p data-v-0246861c>相比于 JavaScript 模块热替换，图片的热替换逻辑就简单多了，这里我们快速来看一下。</p> <p data-v-0246861c>我们同样通过 module.hot.accept 注册这个图片模块的热替换处理函数，在这个函数中，我们只需要重新给图片元素的 src 设置更新后的图片路径就可以了。因为图片修改过后图片的文件名会发生变化，而这里我们就可以直接得到更新后的路径，所以重新设置图片的 src 就能实现图片热替换，具体代码如下：</p> <div class="content__code-HMR8" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./src/main.js</span>
<span class="token keyword">import</span> logo <span class="token keyword">from</span> <span class="token string">'./icon.png'</span>
<span class="token comment">// ... 其他代码</span>
module<span class="token punctuation">.</span>hot<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token string">'./icon.png'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 当 icon.png 更新后执行</span>
  <span class="token comment">// 重写设置 src 会触发图片元素重新加载，从而局部更新图片</span>
  img<span class="token punctuation">.</span>src <span class="token operator">=</span> logo
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div></div> <h3 data-v-0246861c>常见问题</h3> <p data-v-0246861c>如果你刚开始使用 Webpack 的 HMR 特性，肯定会遇到一些问题，接下来我分享几个最容易发生的问题。</p> <p data-v-0246861c>第一个问题，如果处理热替换的代码（处理函数）中有错误，结果也会导致自动刷新。例如我们这里在处理函数中故意加入一个运行时错误，代码如下：</p> <div class="content__code-HMR9" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./src/main.js</span>
<span class="token comment">// ... 其他代码</span>
module<span class="token punctuation">.</span>hot<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token string">'./editor'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 刻意造成运行异常</span>
  <span class="token keyword">undefined</span><span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div></div> <p data-v-0246861c>直接测试你会发现 HMR 不会正常工作，而且根本看不到异常，效果如下图：</p> <img src="/blog/webpack/webpack15.gif" data-v-0246861c> <p data-v-0246861c>这是因为 HMR 过程报错导致 HMR 失败，HMR 失败过后，会自动回退到自动刷新，页面一旦自动刷新，控制台中的错误信息就会被清除，这样的话，如果不是很明显的错误，就很难被发现。</p> <p data-v-0246861c>在这种情况下，我们可以使用 hotOnly 的方式来解决，因为现在使用的 hot 方式，如果热替换失败就会自动回退使用自动刷新，而 hotOnly 的情况下并不会使用自动刷新。</p> <p data-v-0246861c>我们回到配置文件中，这里我们将 devServer 中的 hot 等于 true 修改为 hotOnly 等于 true，具体代码如下：</p> <div class="content__code-HMR10" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
<span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  devServer<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 只使用 HMR，不会 fallback 到 live reloading</span>
    hotOnly<span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token comment">// ...</span>
    <span class="token comment">// HMR 特性所需要的插件</span>
    <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>HotModuleReplacementPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>配置完成以后，重新启动 webpack-dev-server。此时我们再去修改代码，无论是否处理了这个代码模块的热替换逻辑，浏览器都不会自动刷新了，这样的话，热替换逻辑中的错误信息就可以直接看到了，具体效果如下图：</p> <img src="/blog/webpack/webpack78.png" data-v-0246861c> <p data-v-0246861c>第二个问题，对于使用了 HMR API 的代码，如果我们在没有开启 HMR 功能的情况下运行 Webpack 打包，此时运行环境中就会报出 Cannot read property 'accept' of undefined 的错误，具体错误信息如下：</p> <img src="/blog/webpack/webpack79.png" data-v-0246861c> <p data-v-0246861c>原因是 module.hot 是 HMR 插件提供的成员，没有开启这个插件，自然也就没有这个对象。</p> <p data-v-0246861c>解决办法也很简单，与我们在业务代码中判断 API 兼容一样，我们先判断是否存在这个对象，然后再去使用就可以了，具体代码如下：</p> <div class="content__code-HMR11" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// HMR -----------------------------------</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>module<span class="token punctuation">.</span>hot<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 确保有 HMR API 对象</span>
  module<span class="token punctuation">.</span>hot<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token string">'./editor'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>除此之外，可能你还有一个问题：我们在代码中写了很多与业务功能本身无关的代码，会不会对生产环境有影响？</p> <p data-v-0246861c>那这个问题的答案很简单，我通过一个简单的操作来帮你解答，我们回到配置文件中，确保已经将热替换特性关闭，并且移除掉了 HotModuleReplacementPlugin 插件，然后打开命令行终端，正常运行一下 Webpack 打包，打包过后，我们找到打包生成的 bundle.js 文件，然后找到里面 main.js 对应的模块，具体结果如下图：</p> <img src="/blog/webpack/webpack80.png" data-v-0246861c> <p data-v-0246861c>你会发现之前我们编写的处理热替换的代码都被移除掉了，只剩下一个 if (false) 的空判断，这种没有意义的判断，在压缩过后也会自动去掉，所以根本不会对生产环境有任何影响。</p> <div class="content__title-optimize" data-v-0246861c><h2 id="webpack特性"><a href="#webpack特性" class="header-anchor">#</a> Webpack特性</h2></div> <h3 data-v-0246861c>Tree Shaking</h3> <p data-v-0246861c>Tree Shaking 翻译过来的意思就是“摇树”。伴随着摇树的动作，树上的枯树枝和树叶就会掉落下来。</p> <p data-v-0246861c>我们这里要介绍的 Tree-shaking 也是同样的道理，不过通过 Tree-shaking “摇掉”的是代码中那些没有用到的部分，这部分没有用的代码更专业的说法应该叫作未引用代码（dead-code）。</p> <p data-v-0246861c>Tree-shaking 最早是 Rollup 中推出的一个特性，Webpack 从 2.0 过后开始支持这个特性。</p> <p data-v-0246861c>我们使用 Webpack 生产模式打包的优化过程中，就使用自动开启这个功能，以此来检测我们代码中的未引用代码，然后自动移除它们。</p> <p data-v-0246861c>我们可以先来体验一下这个功能的效果，这里我的源代码非常简单，只有两个文件。</p> <div class="content__code-optimize1" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code>└─ <span class="token number">09</span><span class="token operator">-</span>tree<span class="token operator">-</span>shaking
   ├── src
   │   ├── components<span class="token punctuation">.</span>js
   │   └── main<span class="token punctuation">.</span>js
   ├── <span class="token keyword">package</span><span class="token punctuation">.</span>json
   └── webpack<span class="token punctuation">.</span>config<span class="token punctuation">.</span>js

</code></pre></div></div> <p data-v-0246861c>其中 components.js 中导出了一些函数，这些函数各自模拟了一个组件，具体代码如下：</p> <div class="content__code-optimize2" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./src/components.js</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">Button</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'dead-code'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">Link</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">Heading</span> <span class="token operator">=</span> <span class="token parameter">level</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'h'</span> <span class="token operator">+</span> level<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>其中 Button 组件函数中，在 return 过后还有一个 console.log() 语句，很明显这句代码永远都不会被执行，所以这个 console.log() 就属于未引用代码。</p> <p data-v-0246861c>在 main.js 文件中只是导入了 compnents.js，具体代码如下：</p> <div class="content__code-optimize3" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./src/main.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Button <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./components'</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token function">Button</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

</code></pre></div></div> <p data-v-0246861c>但是注意这里导入 components 模块时，我们只提取了模块中的 Button 成员，那这就导致components 模块中很多地方都不会被用到，那这些地方就是冗余的，具体冗余部分如下：</p> <div class="content__code-optimize4" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./src/components.js</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">Button</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span>
  <span class="token comment">// 未引用代码</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'dead-code'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 未引用代码</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">Link</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 未引用代码</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">Heading</span> <span class="token operator">=</span> <span class="token parameter">level</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'h'</span> <span class="token operator">+</span> level<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>去除冗余代码是生产环境优化中一个很重要的工作，Webpack 的 Tree-shaking 功能就很好地实现了这一点。</p> <p data-v-0246861c>我们打开命令行终端，这里我们尝试以 production 模式运行打包，具体命令如下：</p> <p data-v-0246861c>$ npx webpack --mode=production</p> <p data-v-0246861c>Webpack 的 Tree-shaking 特性在生产模式下会自动开启。打包完成以后我们打开输出的 bundle.js，具体结果如下：</p> <img src="/blog/webpack/webpack81.png" data-v-0246861c> <p data-v-0246861c>通过搜索你会发现，components 模块中冗余的代码根本没有输出。这就是经过 Tree-shaking 处理过后的效果。</p> <p data-v-0246861c>试想一下，如果我们在项目中引入 Lodash 这种工具库，大部分情况下我们只会使用其中的某几个工具函数，而其他没有用到的部分就是冗余代码。通过 Tree-shaking 就可以极大地减少最终打包后 bundle 的体积。</p> <p data-v-0246861c>需要注意的是，Tree-shaking 并不是指 Webpack 中的某一个配置选项，而是一组功能搭配使用过后实现的效果，这组功能在生产模式下都会自动启用，所以使用生产模式打包就会有 Tree-shaking 的效果。</p> <h3 data-v-0246861c>开启 Tree Shaking</h3> <p data-v-0246861c>由于目前官方文档中对于 Tree-shaking 的介绍有点混乱，所以我们这里再来介绍一下在其他模式下，如何一步一步手动开启 Tree-shaking。通过这个过程，还可以顺便了解 Tree-shaking 的工作过程和 Webpack 其他的一些优化功能。</p> <p data-v-0246861c>这里还是上述的案例结构，我们再次运行 Webpack 打包，不过这一次我们不再使用 production 模式，而是使用 none，也就是不开启任何内置功能和插件，具体命令如下：</p> <p data-v-0246861c>$ npx webpack --mode=none</p> <p data-v-0246861c>打包完成过后，我们再次找到输出的 bundle.js 文件，具体结果如下：</p> <img src="/blog/webpack/webpack82.png" data-v-0246861c> <p data-v-0246861c>这里的打包结果跟我们在第二讲中分析的是一样的，源代码中的一个模块对应这里的一个函数。</p> <p data-v-0246861c>我们这里注意一下 components 对应的这个模块，虽然外部没有使用这里的 Link 函数和 Heading 函数，但是仍然导出了它们，具体如下图所示：</p> <img src="/blog/webpack/webpack83.png" data-v-0246861c> <p data-v-0246861c>显然这种导出是没有任何意义的。</p> <p data-v-0246861c>明确目前打包结果的状态过后，我们打开 Webpack 的配置文件，在配置对象中添加一个 optimization 属性，这个属性用来集中配置 Webpack 内置优化功能，它的值也是一个对象。</p> <p data-v-0246861c>在 optimization 对象中我们可以先开启一个 usedExports 选项，表示在输出结果中只导出外部使用了的成员，具体配置代码如下：</p> <div class="content__code-optimize5" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// ... 其他配置项</span>
  optimization<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 模块只导出被使用的成员</span>
    usedExports<span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>配置完成后，重新打包，然后我们再来看一下输出的 bundle.js，具体结果如下图：</p> <img src="/blog/webpack/webpack84.png" data-v-0246861c> <p data-v-0246861c>此时你会发现 components 模块所对应的函数，就不再导出 Link 和 Heading 这两个函数了，那它们对应的代码就变成了未引用代码。而且如果你使用的是 VS Code，会发现 VS Code 将这两个函数名的颜色变淡了，这是为了表示它们未被引用。</p> <p data-v-0246861c>对于这种未引用代码，如果我们开启压缩代码功能，就可以自动压缩掉这些没有用到的代码。</p> <p data-v-0246861c>我们可以回到配置文件中，尝试在 optimization 配置中开启 minimize，具体配置如下：</p> <div class="content__code-optimize6" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// ... 其他配置项</span>
  optimization<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 模块只导出被使用的成员</span>
    usedExports<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token comment">// 压缩输出结果</span>
    minimize<span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>然后再次回到命令行重新运行打包，具体结果如下图所示：</p> <img src="/blog/webpack/webpack85.png" data-v-0246861c> <p data-v-0246861c>仔细查看打包结果，你会发现，Link 和 Heading 这些未引用代码都被自动移除了。</p> <p data-v-0246861c>这就是 Tree-shaking 的实现，整个过程用到了 Webpack 的两个优化功能：</p> <ul data-v-0246861c><li data-v-0246861c>usedExports - 打包结果中只导出外部用到的成员；</li> <li data-v-0246861c>minimize - 压缩打包结果。</li></ul> <p data-v-0246861c>如果把我们的代码看成一棵大树，那你可以这样理解：</p> <ul data-v-0246861c><li data-v-0246861c>usedExports 的作用就是标记树上哪些是枯树枝、枯树叶；</li> <li data-v-0246861c>minimize 的作用就是负责把枯树枝、枯树叶摇下来。</li></ul> <h3 data-v-0246861c>合并模块（扩展）</h3> <p data-v-0246861c>除了 usedExports 选项之外，我们还可以使用一个 concatenateModules 选项继续优化输出。</p> <p data-v-0246861c>普通打包只是将一个模块最终放入一个单独的函数中，如果我们的模块很多，就意味着在输出结果中会有很多的模块函数。</p> <p data-v-0246861c>concatenateModules 配置的作用就是尽可能将所有模块合并到一起输出到一个函数中，这样既提升了运行效率，又减少了代码的体积。</p> <p data-v-0246861c>我们回到配置文件中，这里我们在 optimization 属性中开启 concatenateModules。同时，为了更好地看到效果，我们先关闭 minimize，具体配置如下：</p> <div class="content__code-optimize7" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// ... 其他配置项</span>
  optimization<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 模块只导出被使用的成员</span>
    usedExports<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token comment">// 尽可能合并每一个模块到一个函数中</span>
    concatenateModules<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token comment">// 压缩输出结果</span>
    minimize<span class="token operator">:</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>然后回到命令行终端再次运行打包。那此时 bundle.js 中就不再是一个模块对应一个函数了，而是把所有的模块都放到了一个函数中，具体结果如下：</p> <img src="/blog/webpack/webpack86.png" data-v-0246861c> <p data-v-0246861c>这个特性又被称为 Scope Hoisting，也就是作用域提升，它是 Webpack 3.0 中添加的一个特性。</p> <p data-v-0246861c>如果再配合 minimize 选项，打包结果的体积又会减小很多。</p> <h3 data-v-0246861c>结合 babel-loader 的问题</h3> <p data-v-0246861c>因为早期的 Webpack 发展非常快，那变化也就比较多，所以当我们去找资料时，得到的结果不一定适用于当前我们所使用的版本。而 Tree-shaking 的资料更是如此，很多资料中都表示“为 JS 模块配置 babel-loader，会导致 Tree-shaking 失效”。</p> <p data-v-0246861c>针对这个问题，这里我统一说明一下：</p> <p data-v-0246861c>首先你需要明确一点：Tree-shaking 实现的前提是 ES Modules，也就是说：最终交给 Webpack 打包的代码，必须是使用 ES Modules 的方式来组织的模块化。</p> <p data-v-0246861c>为什么这么说呢？</p> <p data-v-0246861c>我们都知道 Webpack 在打包所有的模块代码之前，先是将模块根据配置交给不同的 Loader 处理，最后再将 Loader 处理的结果打包到一起。</p> <p data-v-0246861c>很多时候，我们为了更好的兼容性，会选择使用 babel-loader 去转换我们源代码中的一些 ECMAScript 的新特性。而 Babel 在转换 JS 代码时，很有可能处理掉我们代码中的 ES Modules 部分，把它们转换成 CommonJS 的方式，如下图所示：</p> <img src="/blog/webpack/webpack87.png" data-v-0246861c> <p data-v-0246861c>当然了，Babel 具体会不会处理 ES Modules 代码，取决于我们有没有为它配置使用转换 ES Modules 的插件。</p> <p data-v-0246861c>很多时候，我们为 Babel 配置的都是一个 preset（预设插件集合），而不是某些具体的插件。例如，目前市面上使用最多的 @babel/preset-env，这个预设里面就有转换 ES Modules 的插件。所以当我们使用这个预设时，代码中的 ES Modules 部分就会被转换成 CommonJS 方式。那 Webpack 再去打包时，拿到的就是以 CommonJS 方式组织的代码了，所以 Tree-shaking 不能生效。</p> <p data-v-0246861c>那我们这里具体来尝试一下。为了可以更容易分辨结果，我们只开启 usedExports，完整配置如下：</p> <div class="content__code-optimize8" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  mode<span class="token operator">:</span> <span class="token string">'none'</span><span class="token punctuation">,</span>
  entry<span class="token operator">:</span> <span class="token string">'./src/main.js'</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    filename<span class="token operator">:</span> <span class="token string">'bundle.js'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  module<span class="token operator">:</span> <span class="token punctuation">{</span>
    rules<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.js$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>
        use<span class="token operator">:</span> <span class="token punctuation">{</span>
          loader<span class="token operator">:</span> <span class="token string">'babel-loader'</span><span class="token punctuation">,</span>
          options<span class="token operator">:</span> <span class="token punctuation">{</span>
            presets<span class="token operator">:</span> <span class="token punctuation">[</span>
              <span class="token punctuation">[</span><span class="token string">'@babel/preset-env'</span><span class="token punctuation">]</span>
            <span class="token punctuation">]</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  optimization<span class="token operator">:</span> <span class="token punctuation">{</span>
    usedExports<span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>配置完成过后，我们打开命令行终端，运行 Webpack 打包命令，然后再找到 bundle.js，具体结果如下：</p> <img src="/blog/webpack/webpack88.png" data-v-0246861c> <p data-v-0246861c>仔细查看你会发现，结果并不是像刚刚说的那样，这里 usedExports 功能仍然正常工作了，此时，如果我们压缩代码，这些未引用的代码依然会被移除。这也就说明 Tree-shaking 并没有失效。</p> <p data-v-0246861c>那到底是怎么回事呢？为什么很多资料都说 babel-loader 会导致 Tree-shaking 失效，但当我们实际尝试后又发现并没有失效？</p> <p data-v-0246861c>其实，这是因为在最新版本（8.x）的 babel-loader 中，已经自动帮我们关闭了对 ES Modules 转换的插件，你可以参考对应版本 babel-loader 的源码，核心代码如下：</p> <img src="/blog/webpack/webpack89.png" data-v-0246861c> <p data-v-0246861c>通过查阅 babel-loader 模块的源码，我们发现它已经在 injectCaller 函数中标识了当前环境支持 ES Modules。</p> <p data-v-0246861c>然后再找到我们所使用的 @babal/preset-env 模块源码，部分核心代码如下：</p> <img src="/blog/webpack/webpack90.png" data-v-0246861c> <p data-v-0246861c>在这个模块中，根据环境标识自动禁用了对 ES Modules 的转换插件，所以经过 babel-loader 处理后的代码默认仍然是 ES Modules，那 Webpack 最终打包得到的还是 ES Modules 代码，Tree-shaking 自然也就可以正常工作了。</p> <p data-v-0246861c>我们也可以在 babel-loader 的配置中强制开启 ES Modules 转换插件来试一下，具体配置如下：</p> <div class="content__code-optimize9" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  mode<span class="token operator">:</span> <span class="token string">'none'</span><span class="token punctuation">,</span>
  entry<span class="token operator">:</span> <span class="token string">'./src/main.js'</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    filename<span class="token operator">:</span> <span class="token string">'bundle.js'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  module<span class="token operator">:</span> <span class="token punctuation">{</span>
    rules<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.js$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>
        use<span class="token operator">:</span> <span class="token punctuation">{</span>
          loader<span class="token operator">:</span> <span class="token string">'babel-loader'</span><span class="token punctuation">,</span>
          options<span class="token operator">:</span> <span class="token punctuation">{</span>
            presets<span class="token operator">:</span> <span class="token punctuation">[</span>
              <span class="token punctuation">[</span><span class="token string">'@babel/preset-env'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> modules<span class="token operator">:</span> <span class="token string">'commonjs'</span> <span class="token punctuation">}</span><span class="token punctuation">]</span>
            <span class="token punctuation">]</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  optimization<span class="token operator">:</span> <span class="token punctuation">{</span>
    usedExports<span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>给 Babel preset 添加配置的方式比较特别，这里很多人都会配错，一定要注意。它需要把预设数组中的成员定义成一个数组，然后这个数组中的第一个成员就是所使用的 preset 的名称，第二个成员就是给这个 preset 定义的配置对象。</p> <p data-v-0246861c>我们在这个对象中将 modules 属性设置为 &quot;commonjs&quot;，默认这个属性是 auto，也就是根据环境判断是否开启 ES Modules 插件，我们设置为 commonjs 就表示我们强制使用 Babel 的 ES Modules 插件把代码中的 ES Modules 转换为 CommonJS。</p> <p data-v-0246861c>完成以后，我们再次打开命令行终端，运行 Webpack 打包。然后找到 bundle.js，结果如下：</p> <img src="/blog/webpack/webpack91.png" data-v-0246861c> <p data-v-0246861c>此时，你就会发现 usedExports 没法生效了。即便我们开启压缩代码，Tree-shaking 也会失效。</p> <p data-v-0246861c>总结一下，这里通过实验发现，最新版本的 babel-loader 并不会导致 Tree-shaking 失效。如果你不确定现在使用的 babel-loader 会不会导致这个问题，最简单的办法就是在配置中将 @babel/preset-env 的 modules 属性设置为 false，确保不会转换 ES Modules，也就确保了 Tree-shaking 的前提。</p> <p data-v-0246861c>另外，我们刚刚探索的过程也值得你仔细再去琢磨一下，通过这样的探索能够帮助你了解很多背后的原因，做到“知其然，知其所以然”。</p> <h3 data-v-0246861c>sideEffects</h3> <p data-v-0246861c>Webpack 4 中新增了一个 sideEffects 特性，它允许我们通过配置标识我们的代码是否有副作用，从而提供更大的压缩空间。</p> <p data-v-0246861c>TIPS：模块的副作用指的就是模块执行的时候除了导出成员，是否还做了其他的事情。</p> <p data-v-0246861c>这个特性一般只有我们去开发一个 npm 模块时才会用到。因为官网把对 sideEffects 特性的介绍跟 Tree-shaking 混到了一起，所以很多人误认为它们之间是因果关系，其实它们没有什么太大的关系。</p> <p data-v-0246861c>我们先把 sideEffects 特性本身的作用弄明白，你就更容易理解为什么说它跟 Tree-shaking 没什么关系了。</p> <p data-v-0246861c>这里我先设计一个 sideEffects 能够发挥效果的场景，案例具体结构如下：</p> <div class="content__code-optimize10" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">.</span>
├── src
│   ├── components
│   │   ├── button<span class="token punctuation">.</span>js
│   │   ├── heading<span class="token punctuation">.</span>js
│   │   ├── index<span class="token punctuation">.</span>js
│   │   └── link<span class="token punctuation">.</span>js
│   └── main<span class="token punctuation">.</span>js
├── <span class="token keyword">package</span><span class="token punctuation">.</span>json
└── webpack<span class="token punctuation">.</span>config<span class="token punctuation">.</span>js
</code></pre></div></div> <p data-v-0246861c>基于上一个案例的基础上，我们把 components 模块拆分出多个组件文件，然后在 components/index.js 中集中导出，以便于外界集中导入，具体 index.js 代码如下：</p> <div class="content__code-optimize11" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./src/components/index.js</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token keyword">default</span> <span class="token keyword">as</span> Button <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./button'</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token keyword">default</span> <span class="token keyword">as</span> Link <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./link'</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token keyword">default</span> <span class="token keyword">as</span> Heading <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./heading'</span>

</code></pre></div></div> <p data-v-0246861c>这也是我们经常见到一种同类文件的组织方式。另外，在每个组件中，我们都添加了一个 console 操作（副作用代码），具体代码如下：</p> <div class="content__code-optimize12" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./src/components/button.js</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Button component~'</span><span class="token punctuation">)</span> <span class="token comment">// 副作用代码</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">//我们再到打包入口文件（main.js）中去载入 components 中的 Button 成员，具体代码如下：</span>

<span class="token comment">// ./src/main.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Button <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./components'</span>

document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token function">Button</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

</code></pre></div></div> <p data-v-0246861c>那这样就会出现一个问题，虽然我们在这里只是希望载入 Button 模块，但实际上载入的是 components/index.js，而 index.js 中又载入了这个目录中全部的组件模块，这就会导致所有组件模块都会被加载执行。</p> <p data-v-0246861c>我们打开命令行终端，尝试运行打包，打包完成过后找到打包结果，具体结果如下：</p> <img src="/blog/webpack/webpack92.png" data-v-0246861c> <p data-v-0246861c>根据打包结果发现，所有的组件模块都被打包进了 bundle.js。</p> <p data-v-0246861c>此时如果我们开启 Tree-shaking 特性（只设置 useExports），这里没有用到的导出成员其实最终也可以被移除，打包效果如下：</p> <img src="/blog/webpack/webpack93.png" data-v-0246861c> <p data-v-0246861c>但是由于这些成员所属的模块中有副作用代码，所以就导致最终 Tree-shaking 过后，这些模块并不会被完全移除。</p> <p data-v-0246861c>可能你会认为这些代码应该保留下来，而实际情况是，这些模块内的副作用代码一般都是为这个模块服务的，例如这里我添加的 console.log，就是希望表示一下当前这个模块被加载了。但是最终整个模块都没用到，也就没必要留下这些副作用代码了。</p> <p data-v-0246861c>所以说，Tree-shaking 只能移除没有用到的代码成员，而想要完整移除没有用到的模块，那就需要开启 sideEffects 特性了。</p> <h3 data-v-0246861c>sideEffects 作用</h3> <p data-v-0246861c>我们打开 Webpack 的配置文件，在 optimization 中开启 sideEffects 特性，具体配置如下：</p> <div class="content__code-optimize13" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  mode<span class="token operator">:</span> <span class="token string">'none'</span><span class="token punctuation">,</span>
  entry<span class="token operator">:</span> <span class="token string">'./src/main.js'</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    filename<span class="token operator">:</span> <span class="token string">'bundle.js'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  optimization<span class="token operator">:</span> <span class="token punctuation">{</span>
    sideEffects<span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>TIPS：注意这个特性在 production 模式下同样会自动开启。</p> <p data-v-0246861c>那此时 Webpack 在打包某个模块之前，会先检查这个模块所属的 package.json 中的 sideEffects 标识，以此来判断这个模块是否有副作用，如果没有副作用的话，这些没用到的模块就不再被打包。换句话说，即便这些没有用到的模块中存在一些副作用代码，我们也可以通过 package.json 中的 sideEffects 去强制声明没有副作用。</p> <p data-v-0246861c>那我们打开项目 package.json 添加一个 sideEffects 字段，把它设置为 false，具体代码如下：</p> <div class="content__code-optimize14" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  <span class="token string">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;09-side-effects&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;version&quot;</span><span class="token operator">:</span> <span class="token string">&quot;0.1.0&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;author&quot;</span><span class="token operator">:</span> <span class="token string">&quot;zce &lt;w@zce.me&gt; (https://zce.me)&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;license&quot;</span><span class="token operator">:</span> <span class="token string">&quot;MIT&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;scripts&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string">&quot;build&quot;</span><span class="token operator">:</span> <span class="token string">&quot;webpack&quot;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token string">&quot;devDependencies&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string">&quot;webpack&quot;</span><span class="token operator">:</span> <span class="token string">&quot;^4.43.0&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;webpack-cli&quot;</span><span class="token operator">:</span> <span class="token string">&quot;^3.3.11&quot;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token string">&quot;sideEffects&quot;</span><span class="token operator">:</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>这样就表示我们这个项目中的所有代码都没有副作用，让 Webpack 放心大胆地去“干”。</p> <p data-v-0246861c>完成以后我们再次运行打包，然后同样找到打包输出的 bundle.js 文件，结果如下：</p> <img src="/blog/webpack/webpack94.png" data-v-0246861c> <p data-v-0246861c>此时那些没有用到的模块就彻底不会被打包进来了。那这就是 sideEffects 的作用。</p> <p data-v-0246861c>这里设置了两个地方：</p> <ul data-v-0246861c><li data-v-0246861c>webpack.config.js 中的 sideEffects 用来开启这个功能；</li> <li data-v-0246861c>package.json 中的 sideEffects 用来标识我们的代码没有副作用。</li></ul> <p data-v-0246861c>目前很多第三方的库或者框架都已经使用了 sideEffects 标识，所以我们再也不用担心为了一个小功能引入一个很大体积的库了。例如，某个 UI 组件库中只有一两个组件会用到，那只要它支持 sideEffects，你就可以放心大胆的直接用了。</p> <h3 data-v-0246861c>sideEffects 注意</h3> <p data-v-0246861c>使用 sideEffects 这个功能的前提是确定你的代码没有副作用，或者副作用代码没有全局影响，否则打包时就会误删掉你那些有意义的副作用代码。</p> <p data-v-0246861c>例如，我这里准备的 extend.js 模块：</p> <div class="content__code-optimize15" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./src/extend.js</span>
<span class="token comment">// 为 Number 的原型添加一个扩展方法</span>
<span class="token class-name">Number</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">pad</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">size</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> leadingZeros <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> leadingZeros <span class="token operator">+</span> <span class="token keyword">this</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>在这个模块中并没有导出任何成员，仅仅是在 Number 的原型上挂载了一个 pad 方法，用来为数字添加前面的导零，这是一种很早以前常见的基于原型的扩展方法。</p> <p data-v-0246861c>我们回到 main.js 中去导入 extend 模块，具体代码如下：</p> <div class="content__code-optimize16" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./src/main.js</span>
<span class="token keyword">import</span> <span class="token string">'./extend'</span> <span class="token comment">// 内部包含影响全局的副作用</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pad</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// =&gt; '0008'</span>

</code></pre></div></div> <p data-v-0246861c>因为这个模块确实没有导出任何成员，所以这里也就不需要提取任何成员。导入过后就可以使用它为 Number 提供扩展方法了。</p> <p data-v-0246861c>这里为 Number 类型做扩展的操作就是 extend 模块对全局产生的副作用。</p> <p data-v-0246861c>此时如果我们还是通过 package.json 标识我们代码没有副作用，那么再次打包过后，就会出现问题。我们可以找到打包结果，如下图所示：</p> <img src="/blog/webpack/webpack95.png" data-v-0246861c> <p data-v-0246861c>我们看到，对 Number 的扩展模块并不会打包进来。</p> <p data-v-0246861c>缺少了对 Number 的扩展操作，我们的代码再去运行的时候，就会出现错误。这种扩展的操作属于对全局产生的副作用。</p> <p data-v-0246861c>这种基于原型的扩展方式，在很多 Polyfill 库中都会大量出现，比较常见的有 es6-promise，这种模块都属于典型的副作用模块。</p> <p data-v-0246861c>除此之外，我们在 JS 中直接载入的 CSS 模块，也都属于副作用模块，同样会面临这种问题。</p> <p data-v-0246861c>所以说不是所有的副作用都应该被移除，有一些必要的副作用需要保留下来。</p> <p data-v-0246861c>最好的办法就是在 package.json 中的 sideEffects 字段中标识需要保留副作用的模块路径（可以使用通配符），具体配置如下：</p> <div class="content__code-optimize17" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  <span class="token string">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;09-side-effects&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;version&quot;</span><span class="token operator">:</span> <span class="token string">&quot;0.1.0&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;author&quot;</span><span class="token operator">:</span> <span class="token string">&quot;zce &lt;w@zce.me&gt; (https://zce.me)&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;license&quot;</span><span class="token operator">:</span> <span class="token string">&quot;MIT&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;scripts&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string">&quot;build&quot;</span><span class="token operator">:</span> <span class="token string">&quot;webpack&quot;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token string">&quot;devDependencies&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string">&quot;webpack&quot;</span><span class="token operator">:</span> <span class="token string">&quot;^4.43.0&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;webpack-cli&quot;</span><span class="token operator">:</span> <span class="token string">&quot;^3.3.11&quot;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token string">&quot;sideEffects&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">&quot;./src/extend.js&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;*.css&quot;</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>这样 Webpack 的 sideEffects 就不会忽略确实有必要的副作用模块了。</p> <h3 data-v-0246861c>总结</h3> <p data-v-0246861c>
    最后我们来总结一下，今天介绍到了两个 Webpack 中的高级特性，分别是 Tree-shaking 和 sideEffects。
    Tree-shaking 的本身没有太多需要你理解和思考的地方，你只需要了解它的效果，以及相关的配置即可。
    而 sideEffects 可能需要你花点时间去理解一下，重点就是想明白哪些副作用代码是可以随着模块的移除而移除，哪些又是不可以移除的。总结下来其实也很简单：对全局有影响的副作用代码不能移除，而只是对模块有影响的副作用代码就可以移除。
    总之不管是 Tree-shaking 还是 sideEffects，我个人认为，它们都是为了弥补 JavaScript 早期在模块系统设计上的不足。随着 Webpack 这类技术的发展，JavaScript 的模块化确实越来越好用，也越来越合理。
    除此之外，我还想强调一点，当你对这些特性有了一定的了解之后，就应该意识到：尽可能不要写影响全局的副作用代码。
  </p> <h3 data-v-0246861c>All in One 的弊端</h3> <p data-v-0246861c>Webpack 另外的一个高级特性，Code Splitting（分块打包）。</p> <p data-v-0246861c>通过 Webpack 实现前端项目整体模块化的优势固然明显，但是它也会存在一些弊端：它最终会将我们所有的代码打包到一起。试想一下，如果我们的应用非常复杂，模块非常多，那么这种 All in One 的方式就会导致打包的结果过大，甚至超过 4～5M。</p> <p data-v-0246861c>在绝大多数的情况下，应用刚开始工作时，并不是所有的模块都是必需的。如果这些模块全部被打包到一起，即便应用只需要一两个模块工作，也必须先把 bundle.js 整体加载进来，而且前端应用一般都是运行在浏览器端，这也就意味着应用的响应速度会受到影响，也会浪费大量的流量和带宽。</p> <p data-v-0246861c>所以这种 All in One 的方式并不合理，更为合理的方案是把打包的结果按照一定的规则分离到多个 bundle 中，然后根据应用的运行需要按需加载。这样就可以降低启动成本，提高响应速度。</p> <p data-v-0246861c>可能你会联想到我们在开篇词中讲过，Webpack 就是通过把项目中散落的模块打包到一起，从而提高加载效率，那么为什么这里又要分离？这不是自相矛盾吗？</p> <p data-v-0246861c>其实这并不矛盾，只是物极必反罢了。Web 应用中的资源受环境所限，太大不行，太碎更不行。因为我们开发过程中划分模块的颗粒度一般都会非常的细，很多时候一个模块只是提供了一个小工具函数，并不能形成一个完整的功能单元。</p> <p data-v-0246861c>如果我们不将这些资源模块打包，直接按照开发过程中划分的模块颗粒度进行加载，那么运行一个小小的功能，就需要加载非常多的资源模块。</p> <p data-v-0246861c>再者，目前主流的 HTTP 1.1 本身就存在一些缺陷，例如：</p> <ul data-v-0246861c><li data-v-0246861c>同一个域名下的并行请求是有限制的；</li> <li data-v-0246861c>每次请求本身都会有一定的延迟；</li> <li data-v-0246861c>每次请求除了传输内容，还有额外的请求头，大量请求的情况下，这些请求头加在一起也会浪费流量和带宽。</li> <li data-v-0246861c>综上所述，模块打包肯定是必要的，但当应用体积越来越大时，我们也要学会变通。</li></ul> <h3 data-v-0246861c>Code Splitting</h3> <p data-v-0246861c>为了解决打包结果过大导致的问题，Webpack 设计了一种分包功能：Code Splitting（代码分割）。</p> <p data-v-0246861c>Code Splitting 通过把项目中的资源模块按照我们设计的规则打包到不同的 bundle 中，从而降低应用的启动成本，提高响应速度。</p> <p data-v-0246861c>Webpack 实现分包的方式主要有两种：</p> <ul data-v-0246861c><li data-v-0246861c>根据业务不同配置多个打包入口，输出多个打包结果；</li> <li data-v-0246861c>结合 ES Modules 的动态导入（Dynamic Imports）特性，按需加载模块。</li></ul> <h3 data-v-0246861c>多入口打包</h3> <p data-v-0246861c>多入口打包一般适用于传统的多页应用程序，最常见的划分规则就是一个页面对应一个打包入口，对于不同页面间公用的部分，再提取到公共的结果中。</p> <p data-v-0246861c>Webpack 配置多入口打包的方式非常简单，这里我准备了一个相应的示例，具体结构如下：</p> <p data-v-0246861c>
    GitHub：https://github.com/zce/webpack-multi-entry
    CodeSandbox：https://codesandbox.io/s/github/zce/webpack-multi-entry
  </p> <div class="content__code-optimize18" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">.</span>
├── dist
├── src
│   ├── common
│   │   ├── fetch<span class="token punctuation">.</span>js
│   │   └── global<span class="token punctuation">.</span>css
│   ├── album<span class="token punctuation">.</span>css
│   ├── album<span class="token punctuation">.</span>html
│   ├── album<span class="token punctuation">.</span>js
│   ├── index<span class="token punctuation">.</span>css
│   ├── index<span class="token punctuation">.</span>html
│   └── index<span class="token punctuation">.</span>js
├── <span class="token keyword">package</span><span class="token punctuation">.</span>json
└── webpack<span class="token punctuation">.</span>config<span class="token punctuation">.</span>js

</code></pre></div></div> <p data-v-0246861c>这个示例中有两个页面，分别是 index 和 album。代码组织的逻辑也很简单：</p> <ul data-v-0246861c><li data-v-0246861c>index.js 负责实现 index 页面功能逻辑；</li> <li data-v-0246861c>album.js 负责实现 album 页面功能逻辑；</li> <li data-v-0246861c>global.css 是公用的样式文件；</li> <li data-v-0246861c>fetch.js 是一个公用的模块，负责请求 API。</li></ul> <p data-v-0246861c>我们回到配置文件中，这里我们尝试为这个案例配置多入口打包，具体配置如下：</p> <div class="content__code-optimize19" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
<span class="token keyword">const</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'html-webpack-plugin'</span><span class="token punctuation">)</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span> <span class="token punctuation">{</span>
    index<span class="token operator">:</span> <span class="token string">'./src/index.js'</span><span class="token punctuation">,</span>
    album<span class="token operator">:</span> <span class="token string">'./src/album.js'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    filename<span class="token operator">:</span> <span class="token string">'[name].bundle.js'</span> <span class="token comment">// [name] 是入口名称</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// ... 其他配置</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      title<span class="token operator">:</span> <span class="token string">'Multi Entry'</span><span class="token punctuation">,</span>
      template<span class="token operator">:</span> <span class="token string">'./src/index.html'</span><span class="token punctuation">,</span>
      filename<span class="token operator">:</span> <span class="token string">'index.html'</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      title<span class="token operator">:</span> <span class="token string">'Multi Entry'</span><span class="token punctuation">,</span>
      template<span class="token operator">:</span> <span class="token string">'./src/album.html'</span><span class="token punctuation">,</span>
      filename<span class="token operator">:</span> <span class="token string">'album.html'</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>一般 entry 属性中只会配置一个打包入口，如果我们需要配置多个入口，可以把 entry 定义成一个对象。</p> <p data-v-0246861c>注意：这里 entry 是定义为对象而不是数组，如果是数组的话就是把多个文件打包到一起，还是一个入口。</p> <p data-v-0246861c>在这个对象中一个属性就是一个入口，属性名称就是这个入口的名称，值就是这个入口对应的文件路径。那我们这里配置的就是 index 和 album 页面所对应的 JS 文件路径。</p> <p data-v-0246861c>一旦我们的入口配置为多入口形式，那输出文件名也需要修改，因为两个入口就有两个打包结果，不能都叫 bundle.js。我们可以在这里使用 [name] 这种占位符来输出动态的文件名，[name] 最终会被替换为入口的名称。</p> <p data-v-0246861c>除此之外，在配置中还通过 html-webpack-plugin 分别为 index 和 album 页面生成了对应的 HTML 文件。</p> <p data-v-0246861c>完成配置之后，我们就可以打开命令行终端，运行 Webpack 打包，那此次打包会有两个入口。打包完成后，我们找到输出目录，这里就能看到两个入口文件各自的打包结果了，如下图所示：</p> <img src="/blog/webpack/webpack96.png" data-v-0246861c> <p data-v-0246861c>但是这里还有一个小问题，我们打开任意一个输出的 HTML 文件，具体结果如下图：</p> <img src="/blog/webpack/webpack97.png" data-v-0246861c> <p data-v-0246861c>你就会发现 index 和 album 两个打包结果都被页面载入了，而我们希望的是每个页面只使用它对应的那个输出结果。</p> <p data-v-0246861c>所以这里还需要修改配置文件，我们回到配置文件中，找到输出 HTML 的插件，默认这个插件会自动注入所有的打包结果，如果需要指定所使用的 bundle，我们可以通过 HtmlWebpackPlugin 的 chunks 属性来设置。我们分别为两个页面配置使用不同的 chunk，具体配置如下：</p> <p data-v-0246861c>TIPS：每个打包入口都会形成一个独立的 chunk（块）。</p> <div class="content__code-optimize20" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
<span class="token keyword">const</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'html-webpack-plugin'</span><span class="token punctuation">)</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span> <span class="token punctuation">{</span>
    index<span class="token operator">:</span> <span class="token string">'./src/index.js'</span><span class="token punctuation">,</span>
    album<span class="token operator">:</span> <span class="token string">'./src/album.js'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    filename<span class="token operator">:</span> <span class="token string">'[name].bundle.js'</span> <span class="token comment">// [name] 是入口名称</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// ... 其他配置</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      title<span class="token operator">:</span> <span class="token string">'Multi Entry'</span><span class="token punctuation">,</span>
      template<span class="token operator">:</span> <span class="token string">'./src/index.html'</span><span class="token punctuation">,</span>
      filename<span class="token operator">:</span> <span class="token string">'index.html'</span><span class="token punctuation">,</span>
      chunks<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'index'</span><span class="token punctuation">]</span> <span class="token comment">// 指定使用 index.bundle.js</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      title<span class="token operator">:</span> <span class="token string">'Multi Entry'</span><span class="token punctuation">,</span>
      template<span class="token operator">:</span> <span class="token string">'./src/album.html'</span><span class="token punctuation">,</span>
      filename<span class="token operator">:</span> <span class="token string">'album.html'</span><span class="token punctuation">,</span>
      chunks<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'album'</span><span class="token punctuation">]</span> <span class="token comment">// 指定使用 album.bundle.js</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>完成以后我们再次回到命令行终端，然后运行打包，打包结果如下图：</p> <img src="/blog/webpack/webpack98.png" data-v-0246861c> <p data-v-0246861c>这一次打包的结果就完全正常了。</p> <p data-v-0246861c>那这就是配置多入口打包的方法，以及如何指定在 HTML 中注入的 bundle。</p> <h3 data-v-0246861c>提取公共模块</h3> <p data-v-0246861c>多入口打包本身非常容易理解和使用，但是它也存在一个小问题，就是不同的入口中一定会存在一些公共使用的模块，如果按照目前这种多入口打包的方式，就会出现多个打包结果中有相同的模块的情况。</p> <p data-v-0246861c>例如我们上述案例中，index 入口和 album 入口中就共同使用了 global.css 和 fetch.js 这两个公共的模块。这里是因为我们的示例比较简单，所以重复的影响没有那么大，但是如果我们公共使用的是 jQuery 或者 Vue.js 这些体积较大的模块，那影响就会比较大，不利于公共模块的缓存。</p> <p data-v-0246861c>所以我们还需要把这些公共的模块提取到一个单独的 bundle 中。Webpack 中实现公共模块提取非常简单，我们只需要在优化配置中开启 splitChunks 功能就可以了，具体配置如下：</p> <div class="content__code-optimize21" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span> <span class="token punctuation">{</span>
    index<span class="token operator">:</span> <span class="token string">'./src/index.js'</span><span class="token punctuation">,</span>
    album<span class="token operator">:</span> <span class="token string">'./src/album.js'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    filename<span class="token operator">:</span> <span class="token string">'[name].bundle.js'</span> <span class="token comment">// [name] 是入口名称</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  optimization<span class="token operator">:</span> <span class="token punctuation">{</span>
    splitChunks<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// 自动提取所有公共模块到单独 bundle</span>
      chunks<span class="token operator">:</span> <span class="token string">'all'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ... 其他配置</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>我们回到配置文件中，这里在 optimization 属性中添加 splitChunks 属性，那这个属性的值是一个对象，这个对象需要配置一个 chunks 属性，我们这里将它设置为 all，表示所有公共模块都可以被提取。</p> <p data-v-0246861c>完成以后我们打开命令行终端，再次运行 Webpack 打包，打包结果如下图：</p> <img src="/blog/webpack/webpack99.png" data-v-0246861c> <p data-v-0246861c>此时在我们的 dist 下就会额外生成一个 JS 文件，在这个文件中就是 index 和 album 中公共的模块部分了。</p> <p data-v-0246861c>除此之外，splitChunks 还支持很多高级的用法，可以实现各种各样的分包策略，这些我们可以在文档中找到对应的介绍。</p> <h3 data-v-0246861c>动态导入</h3> <p data-v-0246861c>除了多入口打包的方式，Code Splitting 更常见的实现方式还是结合 ES Modules 的动态导入特性，从而实现按需加载。</p> <p data-v-0246861c>按需加载是开发浏览器应用中一个非常常见的需求。一般我们常说的按需加载指的是加载数据或者加载图片，但是我们这里所说的按需加载，指的是在应用运行过程中，需要某个资源模块时，才去加载这个模块。这种方式极大地降低了应用启动时需要加载的资源体积，提高了应用的响应速度，同时也节省了带宽和流量。</p> <p data-v-0246861c>Webpack 中支持使用动态导入的方式实现模块的按需加载，而且所有动态导入的模块都会被自动提取到单独的 bundle 中，从而实现分包。</p> <p data-v-0246861c>相比于多入口的方式，动态导入更为灵活，因为我们可以通过代码中的逻辑去控制需不需要加载某个模块，或者什么时候加载某个模块。而且我们分包的目的中，很重要的一点就是让模块实现按需加载，从而提高应用的响应速度。</p> <p data-v-0246861c>接下来，我们具体来看如何使用动态导入特性，这里我已经设计了一个可以发挥按需加载作用的场景，具体效果如下图所示：</p> <img src="/blog/webpack/webpack16.gif" data-v-0246861c> <p data-v-0246861c>在这个应用的主体区域，如果我们访问的是首页，它显示的是一个文章列表，如果我们访问的是相册页，它显示的就是相册列表。</p> <p data-v-0246861c>回到代码中，我们来看目前的实现方式，具体结构如下：</p> <div class="content__code-optimize22" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">.</span>
├── src
│   ├── album
│   │   ├── album<span class="token punctuation">.</span>css
│   │   └── album<span class="token punctuation">.</span>js
│   ├── common
│   │   ├── fetch<span class="token punctuation">.</span>js
│   │   └── global<span class="token punctuation">.</span>css
│   ├── posts
│   │   ├── posts<span class="token punctuation">.</span>css
│   │   └── posts<span class="token punctuation">.</span>js
│   ├── index<span class="token punctuation">.</span>html
│   └── index<span class="token punctuation">.</span>js
├── <span class="token keyword">package</span><span class="token punctuation">.</span>json
└── webpack<span class="token punctuation">.</span>config<span class="token punctuation">.</span>js

</code></pre></div></div> <p data-v-0246861c>文章列表对应的是这里的 posts 组件，而相册列表对应的是 album 组件。我在打包入口（index.js）中同时导入了这两个模块，然后根据页面锚点的变化决定显示哪个组件，核心代码如下：</p> <div class="content__code-optimize23" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./src/index.js</span>
<span class="token keyword">import</span> posts <span class="token keyword">from</span> <span class="token string">'./posts/posts'</span>
<span class="token keyword">import</span> album <span class="token keyword">from</span> <span class="token string">'./album/album'</span>
<span class="token keyword">const</span> <span class="token function-variable function">update</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> hash <span class="token operator">=</span> window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>hash <span class="token operator">||</span> <span class="token string">'#posts'</span>
  <span class="token keyword">const</span> mainElement <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.main'</span><span class="token punctuation">)</span>
  mainElement<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">''</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>hash <span class="token operator">===</span> <span class="token string">'#posts'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mainElement<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token function">posts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>hash <span class="token operator">===</span> <span class="token string">'#album'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mainElement<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token function">album</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'hashchange'</span><span class="token punctuation">,</span> update<span class="token punctuation">)</span>
<span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

</code></pre></div></div> <p data-v-0246861c>在这种情况下，就可能产生资源浪费。试想一下：如果用户只需要访问其中一个页面，那么加载另外一个页面对应的组件就是浪费。</p> <p data-v-0246861c>如果我们采用动态导入的方式，就不会产生浪费的问题了，因为所有的组件都是惰性加载，只有用到的时候才会去加载。具体实现代码如下：</p> <div class="content__code-optimize24" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./src/index.js</span>
<span class="token comment">// import posts from './posts/posts'</span>
<span class="token comment">// import album from './album/album'</span>
<span class="token keyword">const</span> <span class="token function-variable function">update</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> hash <span class="token operator">=</span> window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>hash <span class="token operator">||</span> <span class="token string">'#posts'</span>
  <span class="token keyword">const</span> mainElement <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.main'</span><span class="token punctuation">)</span>
  mainElement<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">''</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>hash <span class="token operator">===</span> <span class="token string">'#posts'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// mainElement.appendChild(posts())</span>
    <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./posts/posts'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> <span class="token keyword">default</span><span class="token operator">:</span> posts <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      mainElement<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token function">posts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>hash <span class="token operator">===</span> <span class="token string">'#album'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// mainElement.appendChild(album())</span>
    <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./album/album'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> <span class="token keyword">default</span><span class="token operator">:</span> album <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      mainElement<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token function">album</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'hashchange'</span><span class="token punctuation">,</span> update<span class="token punctuation">)</span>
<span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

</code></pre></div></div> <p data-v-0246861c>P.S. 为了动态导入模块，可以将 import 关键字作为函数调用。当以这种方式使用时，import 函数返回一个 Promise 对象。这就是 ES Modules 标准中的 Dynamic Imports。</p> <p data-v-0246861c>这里我们先移除 import 这种静态导入，然后在需要使用组件的地方通过 import 函数导入指定路径，那这个方法返回的是一个 Promise。在这个 Promise 的 then 方法中我们能够拿到模块对象。由于我们这里的 posts 和 album 模块是以默认成员导出，所以我们需要解构模块对象中的 default，先拿到导出成员，然后再正常使用这个导出成员。</p> <p data-v-0246861c>完成以后，Webpack Dev Server 自动重新打包，我们再次回到浏览器，此时应用仍然是可以正常工作的。</p> <p data-v-0246861c>那我们再回到命令行终端，重新运行打包，然后看看此时的打包结果具体是怎样的。打包完成以后我们打开 dist 目录，具体结果如下图所示：</p> <img src="/blog/webpack/webpack100.png" data-v-0246861c> <p data-v-0246861c>此时 dist 目录下就会额外多出三个 JS 文件，其中有两个文件是动态导入的模块，另外一个文件是动态导入模块中公共的模块，这三个文件就是由动态导入自动分包产生的。</p> <p data-v-0246861c>以上就是动态导入在 Webpack 中的使用。整个过程我们无需额外配置任何地方，只需要按照 ES Modules 动态导入的方式去导入模块就可以了，Webpack 内部会自动处理分包和按需加载。</p> <p data-v-0246861c>如果你使用的是 Vue.js 之类的 SPA 开发框架的话，那你项目中路由映射的组件就可以通过这种动态导入的方式实现按需加载，从而实现分包。</p> <h3 data-v-0246861c>魔法注释</h3> <p data-v-0246861c>默认通过动态导入产生的 bundle 文件，它的 name 就是一个序号，这并没有什么不好，因为大多数时候，在生产环境中我们根本不用关心资源文件的名称。</p> <p data-v-0246861c>但是如果你还是需要给这些 bundle 命名的话，就可以使用 Webpack 所特有的魔法注释去实现。具体方式如下：</p> <div class="content__code-optimize25" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 魔法注释</span>
<span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/* webpackChunkName: 'posts' */</span><span class="token string">'./posts/posts'</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> <span class="token keyword">default</span><span class="token operator">:</span> posts <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    mainElement<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token function">posts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div></div> <p data-v-0246861c>所谓魔法注释，就是在 import 函数的形式参数位置，添加一个行内注释，这个注释有一个特定的格式：webpackChunkName: ''，这样就可以给分包的 chunk 起名字了。</p> <p data-v-0246861c>完成过后，我们再次打开命令行终端，运行 Webpack 打包，那此时我们生成 bundle 的 name 就会使用刚刚注释中提供的名称了，具体结果如下：</p> <img src="/blog/webpack/webpack100.png" data-v-0246861c> <p data-v-0246861c>除此之外，魔法注释还有个特殊用途：如果你的 chunkName 相同的话，那相同的 chunkName 最终就会被打包到一起，例如我们这里可以把这两个 chunkName 都设置为 components，然后再次运行打包，那此时这两个模块都会被打包到一个文件中，具体操作如下图所示：</p> <img src="/blog/webpack/webpack101.png" data-v-0246861c> <p data-v-0246861c>借助这个特点，你就可以根据自己的实际情况，灵活组织动态加载的模块了。</p> <div class="content__title-speed" data-v-0246861c><h2 id="优化-webpack-的构建速度和打包结果"><a href="#优化-webpack-的构建速度和打包结果" class="header-anchor">#</a> 优化 Webpack 的构建速度和打包结果</h2></div> <p data-v-0246861c>我们了解到的一些用法和特性都是为了在开发阶段能够拥有更好的开发体验。而随着这些体验的提升，一个新的问题出现在我们面前：我们的打包结果会变得越来越臃肿。</p> <p data-v-0246861c>这是因为在这个过程中 Webpack 为了实现这些特性，会自动往打包结果中添加一些内容。例如我们之前用到的 Source Map 和 HMR，它们都会在输出结果中添加额外代码来实现各自的功能。</p> <p data-v-0246861c>但是这些额外的代码对生产环境来说是冗余的。因为生产环境和开发环境有很大的差异，在生产环境中我们强调的是以更少量、更高效的代码完成业务功能，也就是注重运行效率。而开发环境中我们注重的只是开发效率。</p> <p data-v-0246861c>那针对这个问题，Webpack 4 推出了 mode 的用法，为我们提供了不同模式下的一些预设配置，其中生产模式下就已经包括了很多优化配置。</p> <p data-v-0246861c>同时 Webpack 也建议我们为不同的工作环境创建不同的配置，以便于让我们的打包结果可以适用于不同的环境。</p> <p data-v-0246861c>接下来我们一起来探索一下生产环境中的一些优化方式和注意事项。</p> <h3 data-v-0246861c>不同环境下的配置</h3> <p data-v-0246861c>我们先为不同的工作环境创建不同的 Webpack 配置。创建不同环境配置的方式主要有两种：</p> <ul data-v-0246861c><li data-v-0246861c>在配置文件中添加相应的判断条件，根据环境不同导出不同配置；</li> <li data-v-0246861c>为不同环境单独添加一个配置文件，一个环境对应一个配置文件。</li></ul> <p data-v-0246861c>我们分别尝试一下通过这两种方式，为开发环境和生产环境创建不同配置。</p> <p data-v-0246861c>首先我们来看在配置文件中添加判断的方式。我们回到配置文件中，Webpack 配置文件还支持导出一个函数，然后在函数中返回所需要的配置对象。这个函数可以接收两个参数，第一个是 env，是我们通过 CLI 传递的环境名参数，第二个是 argv，是运行 CLI 过程中的所有参数。具体代码如下：</p> <div class="content__code-speed1" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">env<span class="token punctuation">,</span> argv</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token comment">// ... webpack 配置</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>那我们就可以借助这个特点，为开发环境和生产环境创建不同配置。我先将不同模式下公共的配置定义为一个 config 对象，具体代码如下：</p> <div class="content__code-speed2" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">env<span class="token punctuation">,</span> argv</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> config <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// ... 不同模式下的公共配置</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> config
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>然后通过判断，再为 config 对象添加不同环境下的特殊配置。具体如下：</p> <div class="content__code-speed3" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">env<span class="token punctuation">,</span> argv</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> config <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// ... 不同模式下的公共配置</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>env <span class="token operator">===</span> <span class="token string">'development'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 为 config 添加开发模式下的特殊配置</span>
    config<span class="token punctuation">.</span>mode <span class="token operator">=</span> <span class="token string">'development'</span>
    config<span class="token punctuation">.</span>devtool <span class="token operator">=</span> <span class="token string">'cheap-eval-module-source-map'</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>env <span class="token operator">===</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 为 config 添加生产模式下的特殊配置</span>
    config<span class="token punctuation">.</span>mode <span class="token operator">=</span> <span class="token string">'production'</span>
    config<span class="token punctuation">.</span>devtool <span class="token operator">=</span> <span class="token string">'nosources-source-map'</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> config
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>例如这里，我们判断 env 等于 development（开发模式）的时候，我们将 mode 设置为 development，将 devtool 设置为 cheap-eval-module-source-map；而当 env 等于 production（生产模式）时，我们又将 mode 和 devtool 设置为生产模式下需要的值。</p> <p data-v-0246861c>当然，你还可以分别为不同模式设置其他不同的属性、插件，这也都是类似的。</p> <p data-v-0246861c>通过这种方式完成配置过后，我们打开命令行终端，这里我们再去执行 webpack 命令时就可以通过 --env 参数去指定具体的环境名称，从而实现在不同环境中使用不同的配置。</p> <p data-v-0246861c>那这就是通过在 Webpack 配置文件导出的函数中对环境进行判断，从而实现不同环境对应不同配置。这种方式是 Webpack 建议的方式。</p> <p data-v-0246861c>你也可以直接定义环境变量，然后在全局判断环境变量，根据环境变量的不同导出不同配置。这种方式也是类似的，这里我们就不做过多介绍了。</p> <h3 data-v-0246861c>不同环境的配置文件</h3> <p data-v-0246861c>通过判断环境名参数返回不同配置对象的方式只适用于中小型项目，因为一旦项目变得复杂，我们的配置也会一起变得复杂起来。所以对于大型的项目来说，还是建议使用不同环境对应不同配置文件的方式来实现。</p> <p data-v-0246861c>一般在这种方式下，项目中最少会有三个 webpack 的配置文件。其中两个用来分别适配开发环境和生产环境，另外一个则是公共配置。因为开发环境和生产环境的配置并不是完全不同的，所以需要一个公共文件来抽象两者相同的配置。具体配置文件结构如下：</p> <div class="content__code-speed4" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">.</span>
├── webpack<span class="token punctuation">.</span>common<span class="token punctuation">.</span>js ···························· 公共配置
├── webpack<span class="token punctuation">.</span>dev<span class="token punctuation">.</span>js ······························· 开发模式配置
└── webpack<span class="token punctuation">.</span>prod<span class="token punctuation">.</span>js ······························ 生产模式配置

</code></pre></div></div> <p data-v-0246861c>首先我们在项目根目录下新建一个 webpack.common.js，在这个文件中导出不同模式下的公共配置；然后再来创建一个 webpack.dev.js 和一个 webpack.prod.js 分别定义开发和生产环境特殊的配置。</p> <p data-v-0246861c>在不同环境的具体配置中我们先导入公共配置对象，然后这里可以使用 Object.assign 方法把公共配置对象复制到具体环境的配置对象中，并且同时去覆盖其中的一些配置。具体如下：</p> <div class="content__code-speed5" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.common.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// ... 公共配置</span>
<span class="token punctuation">}</span>
<span class="token comment">// ./webpack.prod.js</span>
<span class="token keyword">const</span> common <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./webpack.common'</span><span class="token punctuation">)</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>common<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token comment">// 生产模式配置</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// ./webpack.dev.js</span>
<span class="token keyword">const</span> common <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./webpack.common'</span><span class="token punctuation">)</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>common<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token comment">// 开发模式配置</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div></div> <p data-v-0246861c>如果你熟悉 Object.assign 方法，就应该知道，这个方法会完全覆盖掉前一个对象中的同名属性。这个特点对于普通值类型属性的覆盖都没有什么问题。但是像配置中的 plugins 这种数组，我们只是希望在原有公共配置的插件基础上添加一些插件，那 Object.assign 就做不到了。</p> <p data-v-0246861c>所以我们需要更合适的方法来合并这里的配置与公共的配置。你可以使用 Lodash 提供的 merge 函数来实现，不过社区中提供了更为专业的模块 webpack-merge，它专门用来满足我们这里合并 Webpack 配置的需求。</p> <p data-v-0246861c>我们可以先通过 npm 安装一下 webpack-merge 模块。具体命令如下：</p> <p data-v-0246861c>$ npm i webpack-merge --save-dev</p> <p data-v-0246861c># or yarn add webpack-merge --dev</p> <p data-v-0246861c>安装完成过后我们回到配置文件中，这里先载入这个模块。那这个模块导出的就是一个 merge 函数，我们使用这个函数来合并这里的配置与公共的配置。具体代码如下：</p> <div class="content__code-speed6" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.common.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// ... 公共配置</span>
<span class="token punctuation">}</span>
<span class="token comment">// ./webpack.prod.js</span>
<span class="token keyword">const</span> merge <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack-merge'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> common <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./webpack.common'</span><span class="token punctuation">)</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token function">merge</span><span class="token punctuation">(</span>common<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token comment">// 生产模式配置</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// ./webpack.dev.jss</span>
<span class="token keyword">const</span> merge <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack-merge'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> common <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./webpack.common'</span><span class="token punctuation">)</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token function">merge</span><span class="token punctuation">(</span>common<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token comment">// 开发模式配置</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div></div> <p data-v-0246861c>使用 webpack-merge 过后，我们这里的配置对象就可以跟普通的 webpack 配置一样，需要什么就配置什么，merge 函数内部会自动处理合并的逻辑。</p> <p data-v-0246861c>分别配置完成过后，我们再次回到命令行终端，然后尝试运行 webpack 打包。不过因为这里已经没有默认的配置文件了，所以我们需要通过 --config 参数来指定我们所使用的配置文件路径。例如：</p> <p data-v-0246861c>$ webpack --config webpack.prod.js</p> <p data-v-0246861c>当然，如果你觉得这样操作让我们的命令变得更复杂了，那你可以把这个构建命令定义到 npm scripts 中，方便使用。</p> <h3 data-v-0246861c>生产模式下的优化插件</h3> <p data-v-0246861c>在 Webpack 4 中新增的 production 模式下，内部就自动开启了很多通用的优化功能。对于使用者而言，开箱即用是非常方便的，但是对于学习者而言，这种开箱即用会导致我们忽略掉很多需要了解的东西。以至于出现问题无从下手。</p> <p data-v-0246861c>如果你想要深入了解 Webpack 的使用，我建议你去单独研究每一个配置背后的作用。这里我们先一起学习 production 模式下几个主要的优化功能，顺便了解一下 Webpack 如何优化打包结果。</p> <h4 data-v-0246861c>Define Plugin</h4> <p data-v-0246861c>首先是 DefinePlugin，DefinePlugin 是用来为我们代码中注入全局成员的。在 production 模式下，默认通过这个插件往代码中注入了一个 process.env.NODE_ENV。很多第三方模块都是通过这个成员去判断运行环境，从而决定是否执行例如打印日志之类的操作。</p> <p data-v-0246861c>这里我们来单独使用一下这个插件。我们回到配置文件中，DefinePlugin 是一个内置的插件，所以我们先导入 webpack 模块，然后再到 plugins 中添加这个插件。这个插件的构造函数接收一个对象参数，对象中的成员都可以被注入到代码中。具体代码如下：</p> <div class="content__code-speed7" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
<span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
<span class="token operator">/</span>  <span class="token comment">// ... 其他配置</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>DefinePlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token constant">API_BASE_URL</span><span class="token operator">:</span> <span class="token string">'https://api.example.com'</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>例如我们这里通过 DefinePlugin 定义一个 API_BASE_URL，用来为我们的代码注入 API 服务地址，它的值是一个字符串。</p> <p data-v-0246861c>然后我们回到代码中打印这个 API_BASE_URL。具体代码如下：</p> <div class="content__code-speed8" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./src/main.js</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">API_BASE_URL</span><span class="token punctuation">)</span>

</code></pre></div></div> <p data-v-0246861c>完成以后我们打开控制台，然后运行 webpack 打包。打包完成过后我们找到打包的结果，然后找到 main.js 对应的模块。具体结果如下：</p> <img src="/blog/webpack/webpack102.png" data-v-0246861c> <p data-v-0246861c>这里我们发现 DefinePlugin 其实就是把我们配置的字符串内容直接替换到了代码中，而目前这个字符串的内容为 https://api.example.com，字符串中并没有包含引号，所以替换进来语法自然有问题。</p> <p data-v-0246861c>正确的做法是传入一个字符串字面量语句。具体实现如下：</p> <div class="content__code-speed9" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
<span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// ... 其他配置</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>DefinePlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token comment">// 值要求的是一个代码片段</span>
      <span class="token constant">API_BASE_URL</span><span class="token operator">:</span> <span class="token string">'&quot;https://api.example.com&quot;'</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>这样代码内的 API_BASE_URL 就会被替换为 &quot;https://api.example.com&quot;。具体结果如下：</p> <img src="/blog/webpack/webpack103.png" data-v-0246861c> <p data-v-0246861c>另外，这里有一个非常常用的小技巧，如果我们需要注入的是一个值，就可以通过 JSON.stringify 的方式来得到表示这个值的字面量。这样就不容易出错了。具体实现如下：</p> <div class="content__code-speed10" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
<span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// ... 其他配置</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>DefinePlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token comment">// 值要求的是一个代码片段</span>
      <span class="token constant">API_BASE_URL</span><span class="token operator">:</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token string">'https://api.example.com'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>DefinePlugin 的作用虽然简单，但是却非常有用，我们可以用它在代码中注入一些可能变化的值。</p> <h3 data-v-0246861c>Mini CSS Extract Plugin</h3> <p data-v-0246861c>对于 CSS 文件的打包，一般我们会使用 style-loader 进行处理，这种处理方式最终的打包结果就是 CSS 代码会内嵌到 JS 代码中。</p> <p data-v-0246861c>mini-css-extract-plugin 是一个可以将 CSS 代码从打包结果中提取出来的插件，它的使用非常简单，同样也需要先通过 npm 安装一下这个插件。具体命令如下：</p> <p data-v-0246861c>$ npm i mini-css-extract-plugin --save-dev</p> <p data-v-0246861c>安装完成过后，我们回到 Webpack 的配置文件。具体配置如下：</p> <div class="content__code-speed11" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./src/extend.js</span>
<span class="token comment">// 为 Number 的原型添加一个扩展方法</span>
<span class="token class-name">Number</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">pad</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">size</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> leadingZeros <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> leadingZeros <span class="token operator">+</span> <span class="token keyword">this</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>我们这里先导入这个插件模块，导入过后我们就可以将这个插件添加到配置对象的 plugins 数组中了。这样 Mini CSS Extract Plugin 在工作时就会自动提取代码中的 CSS 了。</p> <p data-v-0246861c>除此以外，Mini CSS Extract Plugin 还需要我们使用 MiniCssExtractPlugin 中提供的 loader 去替换掉 style-loader，以此来捕获到所有的样式。</p> <p data-v-0246861c>这样的话，打包过后，样式就会存放在独立的文件中，直接通过 link 标签引入页面。</p> <p data-v-0246861c>不过这里需要注意的是，如果你的 CSS 体积不是很大的话，提取到单个文件中，效果可能适得其反，因为单独的文件就需要单独请求一次。个人经验是如果 CSS 超过 200KB 才需要考虑是否提取出来，作为单独的文件。</p> <h3 data-v-0246861c>Optimize CSS Assets Webpack Plugin</h3> <p data-v-0246861c>使用了 Mini CSS Extract Plugin 过后，样式就被提取到单独的 CSS 文件中了。但是这里同样有一个小问题。</p> <p data-v-0246861c>我们回到命令行，这里我们以生产模式运行打包。那按照之前的了解，生产模式下会自动压缩输出的结果，我们可以打开打包生成的 JS 文件。具体结果如下：</p> <img src="/blog/webpack/webpack104.png" data-v-0246861c> <p data-v-0246861c>然后我们再打开输出的样式文件。具体结果如下：</p> <img src="/blog/webpack/webpack105.png" data-v-0246861c> <p data-v-0246861c>这里我们发现 JavaScript 文件正常被压缩了，而样式文件并没有被压缩。</p> <p data-v-0246861c>这是因为，Webpack 内置的压缩插件仅仅是针对 JS 文件的压缩，其他资源文件的压缩都需要额外的插件。</p> <p data-v-0246861c>Webpack 官方推荐了一个 Optimize CSS Assets Webpack Plugin 插件。我们可以使用这个插件来压缩我们的样式文件。</p> <p data-v-0246861c>我们回到命令行，先来安装这个插件，具体命令如下：</p> <p data-v-0246861c>$ npm i optimize-css-assets-webpack-plugin --save-dev</p> <p data-v-0246861c>安装完成过后，我们回到配置文件中，添加对应的配置。具体代码如下</p> <div class="content__code-speed12" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
<span class="token keyword">const</span> MiniCssExtractPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'mini-css-extract-plugin'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> OptimizeCssAssetsWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'optimize-css-assets-webpack-plugin'</span><span class="token punctuation">)</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  mode<span class="token operator">:</span> <span class="token string">'none'</span><span class="token punctuation">,</span>
  entry<span class="token operator">:</span> <span class="token punctuation">{</span>
    main<span class="token operator">:</span> <span class="token string">'./src/index.js'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    filename<span class="token operator">:</span> <span class="token string">'[name].bundle.js'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  module<span class="token operator">:</span> <span class="token punctuation">{</span>
    rules<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.css$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>
        use<span class="token operator">:</span> <span class="token punctuation">[</span>
          MiniCssExtractPlugin<span class="token punctuation">.</span>loader<span class="token punctuation">,</span>
          <span class="token string">'css-loader'</span>
        <span class="token punctuation">]</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">MiniCssExtractPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">OptimizeCssAssetsWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>这里同样先导入这个插件，导入完成以后我们把这个插件添加到 plugins 数组中。</p> <p data-v-0246861c>那此时我们再次回到命令行运行打包。</p> <p data-v-0246861c>打包完成过后，我们的样式文件就会以压缩格式输出了。具体结果如下：</p> <img src="/blog/webpack/webpack106.png" data-v-0246861c> <p data-v-0246861c>不过这里还有个额外的小点，可能你会在这个插件的官方文档中发现，文档中的这个插件并不是配置在 plugins 数组中的，而是添加到了 optimization 对象中的 minimizer 属性中。具体如下：</p> <div class="content__code-speed13" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
<span class="token keyword">const</span> MiniCssExtractPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'mini-css-extract-plugin'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> OptimizeCssAssetsWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'optimize-css-assets-webpack-plugin'</span><span class="token punctuation">)</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  mode<span class="token operator">:</span> <span class="token string">'none'</span><span class="token punctuation">,</span>
  entry<span class="token operator">:</span> <span class="token punctuation">{</span>
    main<span class="token operator">:</span> <span class="token string">'./src/index.js'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    filename<span class="token operator">:</span> <span class="token string">'[name].bundle.js'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  optimization<span class="token operator">:</span> <span class="token punctuation">{</span>
    minimizer<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token keyword">new</span> <span class="token class-name">OptimizeCssAssetsWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  module<span class="token operator">:</span> <span class="token punctuation">{</span>
    rules<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.css$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>
        use<span class="token operator">:</span> <span class="token punctuation">[</span>
          MiniCssExtractPlugin<span class="token punctuation">.</span>loader<span class="token punctuation">,</span>
          <span class="token string">'css-loader'</span>
        <span class="token punctuation">]</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">MiniCssExtractPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>那这是为什么呢？</p> <p data-v-0246861c>其实也很简单，如果我们配置到 plugins 属性中，那么这个插件在任何情况下都会工作。而配置到 minimizer 中，就只会在 minimize 特性开启时才工作。</p> <p data-v-0246861c>所以 Webpack 建议像这种压缩插件，应该我们配置到 minimizer 中，便于 minimize 选项的统一控制。</p> <p data-v-0246861c>但是这么配置也有个缺点，此时我们再次运行生产模式打包，打包完成后再来看一眼输出的 JS 文件，此时你会发现，原本可以自动压缩的 JS，现在却不能压缩了。具体 JS 的输出结果如下：</p> <img src="/blog/webpack/webpack107.png" data-v-0246861c> <p data-v-0246861c>那这是因为我们设置了 minimizer，Webpack 认为我们需要使用自定义压缩器插件，那内部的 JS 压缩器就会被覆盖掉。我们必须手动再添加回来。</p> <p data-v-0246861c>内置的 JS 压缩插件叫作 terser-webpack-plugin，我们回到命令行手动安装一下这个模块。</p> <p data-v-0246861c>$ npm i terser-webpack-plugin --save-dev</p> <p data-v-0246861c>安装完成过后，这里我们再手动添加这个模块到 minimizer 配置当中。具体代码如下：</p> <div class="content__code-speed14" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ./webpack.config.js</span>
<span class="token keyword">const</span> MiniCssExtractPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'mini-css-extract-plugin'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> OptimizeCssAssetsWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'optimize-css-assets-webpack-plugin'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> TerserWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'terser-webpack-plugin'</span><span class="token punctuation">)</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  mode<span class="token operator">:</span> <span class="token string">'none'</span><span class="token punctuation">,</span>
  entry<span class="token operator">:</span> <span class="token punctuation">{</span>
    main<span class="token operator">:</span> <span class="token string">'./src/index.js'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    filename<span class="token operator">:</span> <span class="token string">'[name].bundle.js'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  optimization<span class="token operator">:</span> <span class="token punctuation">{</span>
    minimizer<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token keyword">new</span> <span class="token class-name">TerserWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token keyword">new</span> <span class="token class-name">OptimizeCssAssetsWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  module<span class="token operator">:</span> <span class="token punctuation">{</span>
    rules<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.css$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>
        use<span class="token operator">:</span> <span class="token punctuation">[</span>
          MiniCssExtractPlugin<span class="token punctuation">.</span>loader<span class="token punctuation">,</span>
          <span class="token string">'css-loader'</span>
        <span class="token punctuation">]</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">MiniCssExtractPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <p data-v-0246861c>那这样的话，我们再次以生产模式运行打包，JS 文件和 CSS 文件就都可以正常压缩了。</p> <p data-v-0246861c>
    最后再来简单总结一下，本课时我们介绍了如何为 Webpack 添加不同环境下的不同配置，以及在生产模式打包时我们经常用到的几个插件。
    这当中需要你理解的地方并没有太多，更多的是了解这些插件的具体作用和使用方法。除此之外，你也需要更多地了解社区当中其他的常用插件。
  </p> <div class="content__title-deploy" data-v-0246861c><h2 id="webpack配置"><a href="#webpack配置" class="header-anchor">#</a> webpack配置</h2></div> <div class="content__code-deploy1" data-v-0246861c><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
    entry<span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>  <span class="token comment">// 入口文件地址,可以是数组，字符串，对象形式，多入口对应多出口</span>
    mode<span class="token operator">:</span>  <span class="token string">''</span><span class="token punctuation">,</span> <span class="token comment">// 默认为生产模式production   开发模式development  不开启none</span>
    output<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token comment">// 把输出的打包文件放在下面地址，path必须是绝对路径</span>
        path<span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        filename<span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token comment">//打包好的文件名称，'[name].js',[name]占位符</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 单入口文件，一个bundle文件，包含一至多个chunks，一个chunk包含一至多个module</span>
    <span class="token comment">// 多入口文件，多个bundle文件</span>
    devtool<span class="token operator">:</span> <span class="token string">&quot;source-map&quot;</span>
<span class="token comment">//     eval:速度最快,使用eval包裹模块代码,</span>
<span class="token comment">//     source-map： 产生 .map 文件</span>
<span class="token comment">//     cheap:较快，不包含列信息</span>
<span class="token comment">//     Module：第三方模块，包含loader的sourcemap（比如jsx to js ，babel的sourcemap）</span>
<span class="token comment">//     inline： 将 .map 作为DataURI嵌入，不单独生成 .map 文件</span>
    devtool<span class="token operator">:</span><span class="token string">&quot;cheap-module-eval-source-map&quot;</span><span class="token punctuation">,</span><span class="token comment">// 开发环境配置</span>
<span class="token comment">//线上不推荐开启</span>
    devtool<span class="token operator">:</span><span class="token string">&quot;cheap-module-source-map&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 线上⽣生成配置</span>
    <span class="token comment">// webpack默认能解析js和json文件，loader可以让webpack支持更多类型文件</span>
    module<span class="token operator">:</span> <span class="token punctuation">{</span>
        rules<span class="token operator">:</span> <span class="token punctuation">[</span>
            <span class="token punctuation">{</span>
                test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.png$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>
                use<span class="token operator">:</span> <span class="token punctuation">{</span>
                    loader<span class="token operator">:</span> <span class="token string">&quot;file-loader&quot;</span><span class="token punctuation">,</span>
                    options<span class="token operator">:</span> <span class="token punctuation">{</span>
                        name<span class="token operator">:</span> <span class="token string">&quot;[name]_[hash: 6].[ext]&quot;</span><span class="token punctuation">,</span>
                        outputPath<span class="token operator">:</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span>
                        limit<span class="token operator">:</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token comment">//超出限制使用base64</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
                use<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'style-loader'</span><span class="token punctuation">,</span> <span class="token string">'css-loader'</span><span class="token punctuation">]</span> <span class="token comment">// 多个loader从后往前执行</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">]</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 插件是一种作用于webpack整个打包生命周期的机制，每一个插件都会对应一个生命周期</span>
    plugins<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">CleanWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        title<span class="token operator">:</span> <span class="token string">''</span> <span class="token comment">//用来生成页面的 title 元素</span>
        filename<span class="token operator">:</span> <span class="token string">''</span> <span class="token comment">//输出的 HTML 文件名，默认是 index.html, 也可以直接配置带有子目录。</span>
        template<span class="token operator">:</span> <span class="token string">''</span> <span class="token comment">//模板文件路径，支持加载器，比如 html./index.html</span>
        inject<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token operator">|</span> <span class="token string">'head'</span> <span class="token operator">|</span> <span class="token string">'body'</span> <span class="token operator">|</span> <span class="token boolean">false</span> <span class="token comment">//注入所有的资源到特定的 template 或者templateContent 中，如果设置为 true 或者 body，所有的 javascript 资源将被放置到 body元素的底部，'head' 将放置到 head 元素中。</span>
        favicon<span class="token operator">:</span> <span class="token comment">//添加特定的 favicon 路径到输出的 HTML 文件中。</span>
        minify<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">|</span> <span class="token boolean">false</span> <span class="token comment">//传递 html-minifier 选项给 minify 输出</span>
        hash<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token operator">|</span> <span class="token boolean">false</span> <span class="token comment">//如果为 true, 将添加一个唯一的 webpack 编译 hash 到所有包含的脚本和CSS 文件，对于解除 cache 很有用。</span>
        cache<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token operator">|</span> <span class="token boolean">false</span> <span class="token comment">//如果为 true, 这是默认值，仅在文件修改之后才会发布文件。</span>
        showErrors<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token operator">|</span> <span class="token boolean">false</span><span class="token comment">//如果为 true, 这是默认值，错误信息会写入到 HTML 页面中</span>
        chunks<span class="token operator">:</span> <span class="token comment">//允许只添加某些块 (比如，仅 unit test 块)</span>
        chunksSortMode<span class="token operator">:</span> <span class="token comment">//允许控制块在添加到页面之前的排序方式，支持的值：'none' | 'default' | {function}-default:'auto'</span>
        excludeChunks<span class="token operator">:</span> <span class="token comment">//允许跳过某些块，(比如，跳过单元测试的块)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">htmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token comment">// 修改下package.json</span>
<span class="token string">&quot;scripts&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string">&quot;server&quot;</span><span class="token operator">:</span> <span class="token string">&quot;webpack-dev-server&quot;</span> <span class="token comment">//webpack-dev-server需要安装，不需要重新启动并手动刷新页面</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token comment">// 在webpack.config.js配置：</span>
devServer<span class="token operator">:</span> <span class="token punctuation">{</span>
    contentBase<span class="token operator">:</span> <span class="token string">&quot;./dist&quot;</span><span class="token punctuation">,</span>
    open<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    port<span class="token operator">:</span> <span class="token number">8081</span><span class="token punctuation">,</span>
    proxy<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token string">&quot;/api&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            target<span class="token operator">:</span> <span class="token string">&quot;http://localhost:9092&quot;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">//Hot Module Replacement (HMR:热模块替换)</span>
    open<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    hot<span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 开启HMR</span>
    <span class="token comment">//即便HMR不生效，浏览器也不自动刷新，就开启hotOnly</span>
    hotOnly<span class="token operator">:</span><span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>

npm run server <span class="token comment">// 启动，启动服务后，会发现dist目录没有了了，这是因为devServer把打包后的模块不会放在dist目录下，而是放到内存中，从而提升速度</span>
</code></pre></div></div></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/guide/network/network.html" class="prev">
        前端性能优化
      </a></span> <span class="next"><a href="/blog/guide/webpack/Rollup.html">
        Rollup与Parcel
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.5a07472d.js" defer></script><script src="/blog/assets/js/3.1a789601.js" defer></script><script src="/blog/assets/js/77.41135229.js" defer></script><script src="/blog/assets/js/40.cad1baab.js" defer></script>
  </body>
</html>
